#!/usr/bin/perl

use IO::Handle;
use Getopt::Long;

BEGIN {chomp ($root = `configsrch Regreport /`);}
use lib "$ENV{'DV_ROOT'}/tools/perlmod/Regreport/".$root;

use Regreport;

use strict;

my($PROG)       = ($0=~ m%([^/]+)$%);   # regreport real name

# an initial sanity check.
#-------------------------
if(!(defined $ARGV[0])) {die " No arguments specified... please try regreport -h\n"; }

# A cute way to parse the command line. (legacy stuff)
# This assigns a variable directly from command line ..
#=================================================================
eval '$'.$1.'$2;' while $ARGV[0] =~ /^([A-Za-z_]+=)(.*)/ && shift;
print "(debug) $1 =$2\n";

my %opt = ();
my @Options = qw(debug cut_name! sas_only regenerate regress 
                 ver 1 h clean_pass fails_only sim=s);
$opt{debug}     = 0;
$opt{sas_only}  = 0;
$opt{cut_name}  = 1;
$opt{regenerate}= 0;
$opt{regress}   = 0;
$opt{clean_pass}= 0;
$opt{fails_only}= 0;
$opt{ver}       = 0;
$opt{h}         = 0;
$opt{'1'}       = 0;
$opt{sim}="vcs";

GetOptions(\%opt, @Options) or die "Error in arguments!\n";
$debug      = $opt{debug};
$sas_only   = $opt{sas_only};
$cut_name   = $opt{cut_name};
$clean_pass = $opt{clean_pass};
$fails_only = $opt{fails_only} || defined ($ENV{REGREPORT_FAILS_ONLY}) ;
$sim = $opt{sim};
my $regenerate  = $opt{regenerate};
my $regress     = $opt{regress};
my $ver         = $opt{ver};
my $single      = $opt{'1'};
my $h           = $opt{h};

if($h){
  &usage();
  exit 0;
}elsif($ver) {
  print "You are running: $PROG\n";
  exit 0;
}elsif($regenerate){
  &regenerate();
  exit 0;
}elsif($regress) {
  if((defined $ARGV[0]) && (defined $ARGV[1]) && (-d $ARGV[1])){
    if (defined ($ENV{CLEAN_PASS})) {
        $clean_pass = 1;
    }
  my $status = wait_regression($ARGV[0], $ARGV[1]);
  if (!defined ($ENV{REGRESS_MAIL}) || 
      defined ($ENV{REGRESS_MAIL}) && ($ENV{REGRESS_MAIL} !~ /^no$/i)) {
      my $mailto = $ENV{USER};
      $mailto = $mailto.",$ENV{REGRESS_MAIL}" if (defined ($ENV{REGRESS_MAIL}));
      my $finish = "Completed";
      if ($status) {
        $finish = "Incomplete"
      }
      my $subject = "'$finish Regression results for $ARGV[1]'";
    system ("/bin/mailx -s $subject $mailto < $ARGV[0] ");
  }
  exit 0;
  }
  else{
    die " -regress options are not correct. Needs file_name, dir_name, try regreport -h\n";
  }
}elsif($single) {     #1 diag report
  print "(debug) this is single regreport: ARGV[0] =".$ARGV[0]."\n";
  $rsfh = \*STDOUT;
  if(defined $ARGV[0])  { print"(debug) chk_single_diag(ARGV[0])\n"; &chk_single_diag($ARGV[0]); }
  else                  { print"(debug) chk_single_diag(.)\n"; &chk_single_diag("."); }
  exit 0;
}

if((defined $ARGV[0]) && (-d $ARGV[0])) {                     #regression directory
  open (STDOUT, "| tee regreport.log") or 
        die "DIE. Could not open regreport.log for stdout" ;
  $rsfh = \*STDOUT;
  my$total = 1; my $pass = 0;
  $total=(regress_stat(0, @ARGV))[0];
  $pass=(regress_stat(0, @ARGV))[1];
  print STDERR "\n";
  STDERR->autoflush(1);
  STDOUT->autoflush(1);
  &cutitup;

   if ($clean_pass && ($total == $pass)) {
    printf STDOUT "Cleaning Run Directories in $ARGV[0]..\n";
    opendir (DIR, "$ARGV[0]");
    foreach (grep(!/^\.+$/,readdir DIR)) {
        system ("rm -rf $ARGV[0]/$_") if (-d "$ARGV[0]/$_");
    }
    close DIR;
   }

  STDERR->autoflush(1);
  STDOUT->autoflush(1);
  
}else{
  print STDERR "Something went wrong. Probably cannot chdir.Try regreport -h \n";
  exit 1;
}



#=========================================================================

sub usage {
     print <<EOH;
---------------------------------------------------------------------------
Usage: regreport <options> [<directory> [<list>]]

OPTIONS 
  -1 [<regress_dir>]:
     print report for the specified or current-directory diag; [regress dir].

  -regress <output_file> <directory>: 
     in regression mode, regreport writes summary status for finished
     diags to a file until all diags are finished. NOTE: if
     some diag does not produce status, $PROG will wait forever. 

  -ver      
     print version number and exit.

  -sas_only 
     sims.log will not be parsed, only sas.log will get parsed.

  -[no]cut_name 
     cuts the name from  a sss:sss:sss:ddd formatted name. Default is to cut.

  -regenerate   
     will regenerate the status.log files in the diag directories.

  -clean_pass 
     will clean up passing directories. 

  -fails_only 
     will show details for fails only 

  <directory> [<list>]
     print report for all diags under <directory>. <list> is
     0 or more of simulation 'system' names, such as 
     'spc2', 'cmp', 'cmp1', 'cmp8', etc. When nothing
     specified, all systems are included.

ENVIRONMENT VARIABLES:

  CLEAN_PASS : Clean passing dirs
  REGRESS_MAIL : Set to comma seperated list. Default is to send user 
                 email when run in regress mode.  When set to "no" 
                 sends no email at all.
  REGREPORT_FAILS_ONLY : Show details for fails only.

Function:
    Examine all regression .log files for diags under
    regression directory
    and print reports. The most common use is

        $0 <regress_dir>
---------------------------------------------------------------------------
EOH
}

