<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<link rel="STYLESHEET" href="api.css" type='text/css' />
<link rel="SHORTCUT ICON" href="../icons/pyfav.png" type="image/png" />
<link rel='start' href='../index.html' title='Python Documentation Index' />
<link rel="first" href="api.html" title='Python/C API Reference Manual' />
<link rel='contents' href='contents.html' title="Contents" />
<link rel='index' href='genindex.html' title='Index' />
<link rel='last' href='about.html' title='About this document...' />
<link rel='help' href='about.html' title='About this document...' />
<link rel="next" href="mapping-structs.html" />
<link rel="prev" href="common-structs.html" />
<link rel="parent" href="newTypes.html" />
<link rel="next" href="mapping-structs.html" />
<meta name='aesop' content='information' />
<title>10.3 Type Objects </title>
</head>
<body>
<DIV CLASS="navigation">
<div id='top-navigation-panel' xml:id='top-navigation-panel'>
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="10.2 Common Object Structures"
  href="common-structs.html"><img src='../icons/previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></A></td>
<td class='online-navigation'><a rel="parent" title="10. Object Implementation Support"
  href="newTypes.html"><img src='../icons/up.png'
  border='0' height='32'  alt='Up One Level' width='32' /></A></td>
<td class='online-navigation'><a rel="next" title="10.4 Mapping Object Structures"
  href="mapping-structs.html"><img src='../icons/next.png'
  border='0' height='32'  alt='Next Page' width='32' /></A></td>
<td align="center" width="100%">Python/C API Reference Manual</td>
<td class='online-navigation'><a rel="contents" title="Table of Contents"
  href="contents.html"><img src='../icons/contents.png'
  border='0' height='32'  alt='Contents' width='32' /></A></td>
<td class='online-navigation'><img src='../icons/blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><a rel="index" title="Index"
  href="genindex.html"><img src='../icons/index.png'
  border='0' height='32'  alt='Index' width='32' /></A></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="common-structs.html">10.2 Common Object Structures</A>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="newTypes.html">10. Object Implementation Support</A>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="mapping-structs.html">10.4 Mapping Object Structures</A>
</div>
<hr /></div>
</DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION0012300000000000000000"></A><A NAME="type-structs"></A>
<BR>
10.3 Type Objects 
</H1>

<P>
Perhaps one of the most important structures of the Python object
system is the structure that defines a new type: the
<tt class="ctype">PyTypeObject</tt> structure.  Type objects can be handled using any
of the <tt class="cfunction">PyObject_*()</tt> or <tt class="cfunction">PyType_*()</tt> functions,
but do not offer much that's interesting to most Python applications.
These objects are fundamental to how objects behave, so they are very
important to the interpreter itself and to any extension module that
implements new types.

<P>
Type objects are fairly large compared to most of the standard types.
The reason for the size is that each type object stores a large number
of values, mostly C function pointers, each of which implements a
small part of the type's functionality.  The fields of the type object
are examined in detail in this section.  The fields will be described
in the order in which they occur in the structure.

<P>
Typedefs:
unaryfunc, binaryfunc, ternaryfunc, inquiry, coercion, intargfunc,
intintargfunc, intobjargproc, intintobjargproc, objobjargproc,
destructor, freefunc, printfunc, getattrfunc, getattrofunc, setattrfunc,
setattrofunc, cmpfunc, reprfunc, hashfunc

<P>
The structure definition for <tt class="ctype">PyTypeObject</tt> can be found in
<span class="file">Include/object.h</span>.  For convenience of reference, this repeats
the definition found there:

<P>
<div class="verbatim">
<pre>typedef struct _typeobject {
    PyObject_VAR_HEAD
    char *tp_name; /* For printing, in format "&lt;module&gt;.&lt;name&gt;" */
    int tp_basicsize, tp_itemsize; /* For allocation */

    /* Methods to implement standard operations */

    destructor tp_dealloc;
    printfunc tp_print;
    getattrfunc tp_getattr;
    setattrfunc tp_setattr;
    cmpfunc tp_compare;
    reprfunc tp_repr;

    /* Method suites for standard classes */

    PyNumberMethods *tp_as_number;
    PySequenceMethods *tp_as_sequence;
    PyMappingMethods *tp_as_mapping;

    /* More standard operations (here for binary compatibility) */

    hashfunc tp_hash;
    ternaryfunc tp_call;
    reprfunc tp_str;
    getattrofunc tp_getattro;
    setattrofunc tp_setattro;

    /* Functions to access object as input/output buffer */
    PyBufferProcs *tp_as_buffer;

    /* Flags to define presence of optional/expanded features */
    long tp_flags;

    char *tp_doc; /* Documentation string */

    /* Assigned meaning in release 2.0 */
    /* call function for all accessible objects */
    traverseproc tp_traverse;

    /* delete references to contained objects */
    inquiry tp_clear;

    /* Assigned meaning in release 2.1 */
    /* rich comparisons */
    richcmpfunc tp_richcompare;

    /* weak reference enabler */
    long tp_weaklistoffset;

    /* Added in release 2.2 */
    /* Iterators */
    getiterfunc tp_iter;
    iternextfunc tp_iternext;

    /* Attribute descriptor and subclassing stuff */
    struct PyMethodDef *tp_methods;
    struct PyMemberDef *tp_members;
    struct PyGetSetDef *tp_getset;
    struct _typeobject *tp_base;
    PyObject *tp_dict;
    descrgetfunc tp_descr_get;
    descrsetfunc tp_descr_set;
    long tp_dictoffset;
    initproc tp_init;
    allocfunc tp_alloc;
    newfunc tp_new;
    freefunc tp_free; /* Low-level free-memory routine */
    inquiry tp_is_gc; /* For PyObject_IS_GC */
    PyObject *tp_bases;
    PyObject *tp_mro; /* method resolution order */
    PyObject *tp_cache;
    PyObject *tp_subclasses;
    PyObject *tp_weaklist;

} PyTypeObject;
</pre>
<div class="footer">
<a href="typestruct.txt" type="text/plain">Download as text (original file name: <span class="file">typestruct.h</span>).</a>
</div></div>

<P>
The type object structure extends the <tt class="ctype">PyVarObject</tt> structure.
The <tt class="member">ob_size</tt> field is used for dynamic types (created
by  <tt class="function">type_new()</tt>, usually called from a class statement).
Note that <tt class="cdata">PyType_Type</tt> (the metatype) initializes
<tt class="member">tp_itemsize</tt>, which means that its instances (i.e. type
objects) <em>must</em> have the <tt class="member">ob_size</tt> field.

<P>
<dl><dt>PyObject* <b><tt id='l2h-937' xml:id='l2h-937' class="cmember">_ob_next</tt></b></dt>
<dd>
<dt>PyObject* <b><tt id='l2h-1002' xml:id='l2h-1002' class="cmember">_ob_prev</tt></b></dt>
<dd>
  These fields are only present when the macro <code>Py_TRACE_REFS</code> is
  defined.  Their initialization to <tt class="constant">NULL</tt> is taken care of by the
  <code>PyObject_HEAD_INIT</code> macro.  For statically allocated objects,
  these fields always remain <tt class="constant">NULL</tt>.  For dynamically allocated
  objects, these two fields are used to link the object into a
  doubly-linked list of <em>all</em> live objects on the heap.  This
  could be used for various debugging purposes; currently the only use
  is to print the objects that are still alive at the end of a run
  when the environment variable <a class="envvar" id='l2h-1003' xml:id='l2h-1003'>PYTHONDUMPREFS</a> is set.

<P>
These fields are not inherited by subtypes.
</dl>

<P>
<dl><dt>int <b><tt id='l2h-938' xml:id='l2h-938' class="cmember">ob_refcnt</tt></b></dt>
<dd>
  This is the type object's reference count, initialized to <code>1</code>
  by the <code>PyObject_HEAD_INIT</code> macro.  Note that for statically
  allocated type objects, the type's instances (objects whose
  <tt class="member">ob_type</tt> points back to the type) do <em>not</em> count as
  references.  But for dynamically allocated type objects, the
  instances <em>do</em> count as references.

<P>
This field is not inherited by subtypes.
</dl>

<P>
<dl><dt>PyTypeObject* <b><tt id='l2h-939' xml:id='l2h-939' class="cmember">ob_type</tt></b></dt>
<dd>
  This is the type's type, in other words its metatype.  It is
  initialized by the argument to the <code>PyObject_HEAD_INIT</code> macro,
  and its value should normally be <code>&amp;PyType_Type</code>.  However, for
  dynamically loadable extension modules that must be usable on
  Windows (at least), the compiler complains that this is not a valid
  initializer.  Therefore, the convention is to pass <tt class="constant">NULL</tt> to the
  <code>PyObject_HEAD_INIT</code> macro and to initialize this field
  explicitly at the start of the module's initialization function,
  before doing anything else.  This is typically done like this:

<P>
<div class="verbatim"><pre>
Foo_Type.ob_type = &amp;PyType_Type;
</pre></div>

<P>
This should be done before any instances of the type are created.
  <tt class="cfunction">PyType_Ready()</tt> checks if <tt class="member">ob_type</tt> is <tt class="constant">NULL</tt>, and
  if so, initializes it: in Python 2.2, it is set to
  <code>&amp;PyType_Type</code>; in Python 2.2.1 and later it is
  initialized to the <tt class="member">ob_type</tt> field of the base class.
  <tt class="cfunction">PyType_Ready()</tt> will not change this field if it is
  non-zero.

<P>
In Python 2.2, this field is not inherited by subtypes.  In 2.2.1,
  and in 2.3 and beyond, it is inherited by subtypes.
</dl>

<P>
<dl><dt>int <b><tt id='l2h-940' xml:id='l2h-940' class="cmember">ob_size</tt></b></dt>
<dd>
  For statically allocated type objects, this should be initialized
  to zero.  For dynamically allocated type objects, this field has a
  special internal meaning.

<P>
This field is not inherited by subtypes.
</dl>

<P>
<dl><dt>char* <b><tt id='l2h-941' xml:id='l2h-941' class="cmember">tp_name</tt></b></dt>
<dd>
  Pointer to a NUL-terminated string containing the name of the type.
  For types that are accessible as module globals, the string should
  be the full module name, followed by a dot, followed by the type
  name; for built-in types, it should be just the type name.  If the
  module is a submodule of a package, the full package name is part of
  the full module name.  For example, a type named <tt class="class">T</tt> defined
  in module <tt class="module">M</tt> in subpackage <tt class="module">Q</tt> in package <tt class="module">P</tt>
  should have the <tt class="member">tp_name</tt> initializer <code>"P.Q.M.T"</code>.

<P>
For dynamically allocated type objects, this should just be the type
  name, and the module name explicitly stored in the type dict as the
  value for key <code>'__module__'</code>.

<P>
For statically allocated type objects, the tp_name field should
  contain a dot.  Everything before the last dot is made accessible as
  the <tt class="member">__module__</tt> attribute, and everything after the last dot
  is made accessible as the <tt class="member">__name__</tt> attribute.

<P>
If no dot is present, the entire <tt class="member">tp_name</tt> field is made
  accessible as the <tt class="member">__name__</tt> attribute, and the
  <tt class="member">__module__</tt> attribute is undefined (unless explicitly set in
  the dictionary, as explained above).  This means your type will be
  impossible to pickle.

<P>
This field is not inherited by subtypes.
</dl>

<P>
<dl><dt>int <b><tt id='l2h-942' xml:id='l2h-942' class="cmember">tp_basicsize</tt></b></dt>
<dd>
<dt>int <b><tt id='l2h-1004' xml:id='l2h-1004' class="cmember">tp_itemsize</tt></b></dt>
<dd>
  These fields allow calculating the size in bytes of instances of
  the type.

<P>
There are two kinds of types: types with fixed-length instances have
  a zero <tt class="member">tp_itemsize</tt> field, types with variable-length
  instances have a non-zero <tt class="member">tp_itemsize</tt> field.  For a type
  with fixed-length instances, all instances have the same size,
  given in <tt class="member">tp_basicsize</tt>.

<P>
For a type with variable-length instances, the instances must have
  an <tt class="member">ob_size</tt> field, and the instance size is
  <tt class="member">tp_basicsize</tt> plus N times <tt class="member">tp_itemsize</tt>, where N is
  the ``length'' of the object.  The value of N is typically stored in
  the instance's <tt class="member">ob_size</tt> field.  There are exceptions:  for
  example, long ints use a negative <tt class="member">ob_size</tt> to indicate a
  negative number, and N is <code>abs(<tt class="member">ob_size</tt>)</code> there.  Also,
  the presence of an <tt class="member">ob_size</tt> field in the instance layout
  doesn't mean that the instance structure is variable-length (for
  example, the structure for the list type has fixed-length instances,
  yet those instances have a meaningful <tt class="member">ob_size</tt> field).

<P>
The basic size includes the fields in the instance declared by the
  macro PyObject_HEAD or
  PyObject_VAR_HEAD (whichever is used to declare the
  instance struct) and this in turn includes the <tt class="member">_ob_prev</tt> and
  <tt class="member">_ob_next</tt> fields if they are present.  This means that the
  only correct way to get an initializer for the <tt class="member">tp_basicsize</tt>
  is to use the <tt class="keyword">sizeof</tt> operator on the struct used to
  declare the instance layout.  The basic size does not include the GC
  header size (this is new in Python 2.2; in 2.1 and 2.0, the GC
  header size was included in <tt class="member">tp_basicsize</tt>).

<P>
These fields are inherited separately by subtypes.  If the base type
  has a non-zero <tt class="member">tp_itemsize</tt>, it is generally not safe to set
  <tt class="member">tp_itemsize</tt> to a different non-zero value in a subtype
  (though this depends on the implementation of the base type).

<P>
A note about alignment: if the variable items require a particular
  alignment, this should be taken care of by the value of
  <tt class="member">tp_basicsize</tt>.  Example: suppose a type implements an array
  of <code>double</code>. <tt class="member">tp_itemsize</tt> is <code>sizeof(double)</code>.
  It is the programmer's responsibility that <tt class="member">tp_basicsize</tt> is
  a multiple of <code>sizeof(double)</code> (assuming this is the alignment
  requirement for <code>double</code>).
</dl>

<P>
<dl><dt>destructor <b><tt id='l2h-943' xml:id='l2h-943' class="cmember">tp_dealloc</tt></b></dt>
<dd>
  A pointer to the instance destructor function.  This function must
  be defined unless the type guarantees that its instances will never
  be deallocated (as is the case for the singletons <code>None</code> and
  <code>Ellipsis</code>).

<P>
The destructor function is called by the <tt class="cfunction">Py_DECREF()</tt> and
  <tt class="cfunction">Py_XDECREF()</tt> macros when the new reference count is
  zero.  At this point, the instance is still in existence, but there
  are no references to it.  The destructor function should free all
  references which the instance owns, free all memory buffers owned by
  the instance (using the freeing function corresponding to the
  allocation function used to allocate the buffer), and finally (as
  its last action) call the type's <tt class="member">tp_free</tt> function.  If the
  type is not subtypable (doesn't have the
  <tt class="constant">Py_TPFLAGS_BASETYPE</tt> flag bit set), it is permissible to
  call the object deallocator directly instead of via
  <tt class="member">tp_free</tt>.  The object deallocator should be the one used to
  allocate the instance; this is normally <tt class="cfunction">PyObject_Del()</tt>
  if the instance was allocated using <tt class="cfunction">PyObject_New()</tt> or
  <tt class="cfunction">PyOject_VarNew()</tt>, or <tt class="cfunction">PyObject_GC_Del()</tt> if
  the instance was allocated using <tt class="cfunction">PyObject_GC_New()</tt> or
  <tt class="cfunction">PyObject_GC_VarNew()</tt>.

<P>
This field is inherited by subtypes.
</dl>

<P>
<dl><dt>printfunc <b><tt id='l2h-944' xml:id='l2h-944' class="cmember">tp_print</tt></b></dt>
<dd>
  An optional pointer to the instance print function.

<P>
The print function is only called when the instance is printed to a
  <em>real</em> file; when it is printed to a pseudo-file (like a
  <tt class="class">StringIO</tt> instance), the instance's <tt class="member">tp_repr</tt> or
  <tt class="member">tp_str</tt> function is called to convert it to a string.  These
  are also called when the type's <tt class="member">tp_print</tt> field is <tt class="constant">NULL</tt>.  A
  type should never implement <tt class="member">tp_print</tt> in a way that produces
  different output than <tt class="member">tp_repr</tt> or <tt class="member">tp_str</tt> would.

<P>
The print function is called with the same signature as
  <tt class="cfunction">PyObject_Print()</tt>: <code>int tp_print(PyObject *self, FILE
  *file, int flags)</code>.  The <var>self</var> argument is the instance to be
  printed.  The <var>file</var> argument is the stdio file to which it is
  to be printed.  The <var>flags</var> argument is composed of flag bits.
  The only flag bit currently defined is <tt class="constant">Py_PRINT_RAW</tt>.
  When the <tt class="constant">Py_PRINT_RAW</tt> flag bit is set, the instance
  should be printed the same way as <tt class="member">tp_str</tt> would format it;
  when the <tt class="constant">Py_PRINT_RAW</tt> flag bit is clear, the instance
  should be printed the same was as <tt class="member">tp_repr</tt> would format it.
  It should return <code>-1</code> and set an exception condition when an
  error occurred during the comparison.

<P>
It is possible that the <tt class="member">tp_print</tt> field will be deprecated.
  In any case, it is recommended not to define <tt class="member">tp_print</tt>, but
  instead to rely on <tt class="member">tp_repr</tt> and <tt class="member">tp_str</tt> for
  printing.

<P>
This field is inherited by subtypes.
</dl>

<P>
<dl><dt>getattrfunc <b><tt id='l2h-945' xml:id='l2h-945' class="cmember">tp_getattr</tt></b></dt>
<dd>
  An optional pointer to the get-attribute-string function.

<P>
This field is deprecated.  When it is defined, it should point to a
  function that acts the same as the <tt class="member">tp_getattro</tt> function,
  but taking a C string instead of a Python string object to give the
  attribute name.  The signature is the same as for
  <tt class="cfunction">PyObject_GetAttrString()</tt>.

<P>
This field is inherited by subtypes together with
  <tt class="member">tp_getattro</tt>: a subtype inherits both <tt class="member">tp_getattr</tt>
  and <tt class="member">tp_getattro</tt> from its base type when the subtype's
  <tt class="member">tp_getattr</tt> and <tt class="member">tp_getattro</tt> are both <tt class="constant">NULL</tt>.
</dl>

<P>
<dl><dt>setattrfunc <b><tt id='l2h-946' xml:id='l2h-946' class="cmember">tp_setattr</tt></b></dt>
<dd>
  An optional pointer to the set-attribute-string function.

<P>
This field is deprecated.  When it is defined, it should point to a
  function that acts the same as the <tt class="member">tp_setattro</tt> function,
  but taking a C string instead of a Python string object to give the
  attribute name.  The signature is the same as for
  <tt class="cfunction">PyObject_SetAttrString()</tt>.

<P>
This field is inherited by subtypes together with
  <tt class="member">tp_setattro</tt>: a subtype inherits both <tt class="member">tp_setattr</tt>
  and <tt class="member">tp_setattro</tt> from its base type when the subtype's
  <tt class="member">tp_setattr</tt> and <tt class="member">tp_setattro</tt> are both <tt class="constant">NULL</tt>.
</dl>

<P>
<dl><dt>cmpfunc <b><tt id='l2h-947' xml:id='l2h-947' class="cmember">tp_compare</tt></b></dt>
<dd>
  An optional pointer to the three-way comparison function.

<P>
The signature is the same as for <tt class="cfunction">PyObject_Compare()</tt>.
  The function should return <code>1</code> if <var>self</var> greater than
  <var>other</var>, <code>0</code> if <var>self</var> is equal to <var>other</var>, and
  <code>-1</code> if <var>self</var> less than <var>other</var>.  It should return
  <code>-1</code> and set an exception condition when an error occurred
  during the comparison.

<P>
This field is inherited by subtypes together with
  <tt class="member">tp_richcompare</tt> and <tt class="member">tp_hash</tt>: a subtypes inherits
  all three of <tt class="member">tp_compare</tt>, <tt class="member">tp_richcompare</tt>, and
  <tt class="member">tp_hash</tt> when the subtype's <tt class="member">tp_compare</tt>,
  <tt class="member">tp_richcompare</tt>, and <tt class="member">tp_hash</tt> are all <tt class="constant">NULL</tt>.
</dl>

<P>
<dl><dt>reprfunc <b><tt id='l2h-948' xml:id='l2h-948' class="cmember">tp_repr</tt></b></dt>
<dd>
  An optional pointer to a function that implements the built-in
  function <tt class="function">repr()</tt>.<a id='l2h-949' xml:id='l2h-949'></a>
<P>
The signature is the same as for <tt class="cfunction">PyObject_Repr()</tt>; it
  must return a string or a Unicode object.  Ideally, this function
  should return a string that, when passed to <tt class="function">eval()</tt>, given
  a suitable environment, returns an object with the same value.  If
  this is not feasible, it should return a string starting with
  "<tt class="character">&lt;</tt>" and ending with "<tt class="character">&gt;</tt>" from
  which both the type and the value of the object can be deduced.

<P>
When this field is not set, a string of the form "<tt class="samp">&lt;%s object
  at %p&gt;</tt>" is returned, where <code>%s</code> is replaced by the type name,
  and <code>%p</code> by the object's memory address.

<P>
This field is inherited by subtypes.
</dl>

<P>
PyNumberMethods *tp_as_number;

<P>
XXX

<P>
PySequenceMethods *tp_as_sequence;

<P>
XXX

<P>
PyMappingMethods *tp_as_mapping;

<P>
XXX

<P>
<dl><dt>hashfunc <b><tt id='l2h-950' xml:id='l2h-950' class="cmember">tp_hash</tt></b></dt>
<dd>
  An optional pointer to a function that implements the built-in
  function <tt class="function">hash()</tt>.<a id='l2h-951' xml:id='l2h-951'></a>
<P>
The signature is the same as for <tt class="cfunction">PyObject_Hash()</tt>; it
  must return a C long.  The value <code>-1</code> should not be returned as
  a normal return value; when an error occurs during the computation
  of the hash value, the function should set an exception and return
  <code>-1</code>.

<P>
When this field is not set, two possibilities exist: if the
  <tt class="member">tp_compare</tt> and <tt class="member">tp_richcompare</tt> fields are both
  <tt class="constant">NULL</tt>, a default hash value based on the object's address is
  returned; otherwise, a <tt class="exception">TypeError</tt> is raised.

<P>
This field is inherited by subtypes together with
  <tt class="member">tp_richcompare</tt> and <tt class="member">tp_compare</tt>: a subtypes inherits
  all three of <tt class="member">tp_compare</tt>, <tt class="member">tp_richcompare</tt>, and
  <tt class="member">tp_hash</tt>, when the subtype's <tt class="member">tp_compare</tt>,
  <tt class="member">tp_richcompare</tt> and <tt class="member">tp_hash</tt> are all <tt class="constant">NULL</tt>.
</dl>

<P>
<dl><dt>ternaryfunc <b><tt id='l2h-952' xml:id='l2h-952' class="cmember">tp_call</tt></b></dt>
<dd>
  An optional pointer to a function that implements calling the
  object.  This should be <tt class="constant">NULL</tt> if the object is not callable.  The
  signature is the same as for <tt class="cfunction">PyObject_Call()</tt>.

<P>
This field is inherited by subtypes.
</dl>

<P>
<dl><dt>reprfunc <b><tt id='l2h-953' xml:id='l2h-953' class="cmember">tp_str</tt></b></dt>
<dd>
  An optional pointer to a function that implements the built-in
  operation <tt class="function">str()</tt>.  (Note that <tt class="class">str</tt> is a type now,
  and <tt class="function">str()</tt> calls the constructor for that type.  This
  constructor calls <tt class="cfunction">PyObject_Str()</tt> to do the actual work,
  and <tt class="cfunction">PyObject_Str()</tt> will call this handler.)

<P>
The signature is the same as for <tt class="cfunction">PyObject_Str()</tt>; it must
  return a string or a Unicode object.  This function should return a
  ``friendly'' string representation of the object, as this is the
  representation that will be used by the print statement.

<P>
When this field is not set, <tt class="cfunction">PyObject_Repr()</tt> is called to
  return a string representation.

<P>
This field is inherited by subtypes.
</dl>

<P>
<dl><dt>getattrofunc <b><tt id='l2h-954' xml:id='l2h-954' class="cmember">tp_getattro</tt></b></dt>
<dd>
  An optional pointer to the get-attribute function.

<P>
The signature is the same as for <tt class="cfunction">PyObject_GetAttr()</tt>.  It
  is usually convenient to set this field to
  <tt class="cfunction">PyObject_GenericGetAttr()</tt>, which implements the normal
  way of looking for object attributes.

<P>
This field is inherited by subtypes together with
  <tt class="member">tp_getattr</tt>: a subtype inherits both <tt class="member">tp_getattr</tt> and
  <tt class="member">tp_getattro</tt> from its base type when the subtype's
  <tt class="member">tp_getattr</tt> and <tt class="member">tp_getattro</tt> are both <tt class="constant">NULL</tt>.
</dl>

<P>
<dl><dt>setattrofunc <b><tt id='l2h-955' xml:id='l2h-955' class="cmember">tp_setattro</tt></b></dt>
<dd>
  An optional pointer to the set-attribute function.

<P>
The signature is the same as for <tt class="cfunction">PyObject_SetAttr()</tt>.  It
  is usually convenient to set this field to
  <tt class="cfunction">PyObject_GenericSetAttr()</tt>, which implements the normal
  way of setting object attributes.

<P>
This field is inherited by subtypes together with
  <tt class="member">tp_setattr</tt>: a subtype inherits both <tt class="member">tp_setattr</tt> and
  <tt class="member">tp_setattro</tt> from its base type when the subtype's
  <tt class="member">tp_setattr</tt> and <tt class="member">tp_setattro</tt> are both <tt class="constant">NULL</tt>.
</dl>

<P>
<dl><dt>PyBufferProcs* <b><tt id='l2h-956' xml:id='l2h-956' class="cmember">tp_as_buffer</tt></b></dt>
<dd>
  Pointer to an additional structure that contains fields relevant only to
  objects which implement the buffer interface.  These fields are
  documented in ``Buffer Object Structures'' (section
  <A href="buffer-structs.html#buffer-structs">10.7</A>).

<P>
The <tt class="member">tp_as_buffer</tt> field is not inherited, but the contained
  fields are inherited individually.
</dl>

<P>
<dl><dt>long <b><tt id='l2h-957' xml:id='l2h-957' class="cmember">tp_flags</tt></b></dt>
<dd>
  This field is a bit mask of various flags.  Some flags indicate
  variant semantics for certain situations; others are used to
  indicate that certain fields in the type object (or in the extension
  structures referenced via <tt class="member">tp_as_number</tt>,
  <tt class="member">tp_as_sequence</tt>, <tt class="member">tp_as_mapping</tt>, and
  <tt class="member">tp_as_buffer</tt>) that were historically not always present are
  valid; if such a flag bit is clear, the type fields it guards must
  not be accessed and must be considered to have a zero or <tt class="constant">NULL</tt>
  value instead.

<P>
Inheritance of this field is complicated.  Most flag bits are
  inherited individually, i.e. if the base type has a flag bit set,
  the subtype inherits this flag bit.  The flag bits that pertain to
  extension structures are strictly inherited if the extension
  structure is inherited, i.e. the base type's value of the flag bit
  is copied into the subtype together with a pointer to the extension
  structure.  The <tt class="constant">Py_TPFLAGS_HAVE_GC</tt> flag bit is inherited
  together with the <tt class="member">tp_traverse</tt> and <tt class="member">tp_clear</tt> fields,
  i.e. if the <tt class="constant">Py_TPFLAGS_HAVE_GC</tt> flag bit is clear in the
  subtype and the <tt class="member">tp_traverse</tt> and <tt class="member">tp_clear</tt> fields in
  the subtype exist (as indicated by the
  <tt class="constant">Py_TPFLAGS_HAVE_RICHCOMPARE</tt> flag bit) and have <tt class="constant">NULL</tt>
  values.

<P>
The following bit masks are currently defined; these can be or-ed
  together using the <code>|</code> operator to form the value of the
  <tt class="member">tp_flags</tt> field.  The macro <tt class="cfunction">PyType_HasFeature()</tt>
  takes a type and a flags value, <var>tp</var> and <var>f</var>, and checks
  whether <code><var>tp</var>-&gt;tp_flags &amp; <var>f</var></code> is non-zero.

<P>
<dl><dt><b><tt id='l2h-958' xml:id='l2h-958'>Py_TPFLAGS_HAVE_GETCHARBUFFER</tt></b></dt>
<dd>
    If this bit is set, the <tt class="ctype">PyBufferProcs</tt> struct referenced by
    <tt class="member">tp_as_buffer</tt> has the <tt class="member">bf_getcharbuffer</tt> field.
  </dd></dl>

<P>
<dl><dt><b><tt id='l2h-959' xml:id='l2h-959'>Py_TPFLAGS_HAVE_SEQUENCE_IN</tt></b></dt>
<dd>
    If this bit is set, the <tt class="ctype">PySequenceMethods</tt> struct
    referenced by <tt class="member">tp_as_sequence</tt> has the <tt class="member">sq_contains</tt>
    field.
  </dd></dl>

<P>
<dl><dt><b><tt id='l2h-960' xml:id='l2h-960'>Py_TPFLAGS_GC</tt></b></dt>
<dd>
    This bit is obsolete.  The bit it used to name is no longer in
    use.  The symbol is now defined as zero.
  </dd></dl>

<P>
<dl><dt><b><tt id='l2h-961' xml:id='l2h-961'>Py_TPFLAGS_HAVE_INPLACEOPS</tt></b></dt>
<dd>
    If this bit is set, the <tt class="ctype">PySequenceMethods</tt> struct
    referenced by <tt class="member">tp_as_sequence</tt> and the
    <tt class="ctype">PyNumberMethods</tt> structure referenced by
    <tt class="member">tp_as_number</tt> contain the fields for in-place operators.
    In particular, this means that the <tt class="ctype">PyNumberMethods</tt>
    structure has the fields <tt class="member">nb_inplace_add</tt>,
    <tt class="member">nb_inplace_subtract</tt>, <tt class="member">nb_inplace_multiply</tt>,
    <tt class="member">nb_inplace_divide</tt>, <tt class="member">nb_inplace_remainder</tt>,
    <tt class="member">nb_inplace_power</tt>, <tt class="member">nb_inplace_lshift</tt>,
    <tt class="member">nb_inplace_rshift</tt>, <tt class="member">nb_inplace_and</tt>,
    <tt class="member">nb_inplace_xor</tt>, and <tt class="member">nb_inplace_or</tt>; and the
    <tt class="ctype">PySequenceMethods</tt> struct has the fields
    <tt class="member">sq_inplace_concat</tt> and <tt class="member">sq_inplace_repeat</tt>.
  </dd></dl>

<P>
<dl><dt><b><tt id='l2h-962' xml:id='l2h-962'>Py_TPFLAGS_CHECKTYPES</tt></b></dt>
<dd>
    If this bit is set, the binary and ternary operations in the
    <tt class="ctype">PyNumberMethods</tt> structure referenced by
    <tt class="member">tp_as_number</tt> accept arguments of arbitrary object types,
    and do their own type conversions if needed.  If this bit is
    clear, those operations require that all arguments have the
    current type as their type, and the caller is supposed to perform
    a coercion operation first.  This applies to <tt class="member">nb_add</tt>,
    <tt class="member">nb_subtract</tt>, <tt class="member">nb_multiply</tt>, <tt class="member">nb_divide</tt>,
    <tt class="member">nb_remainder</tt>, <tt class="member">nb_divmod</tt>, <tt class="member">nb_power</tt>,
    <tt class="member">nb_lshift</tt>, <tt class="member">nb_rshift</tt>, <tt class="member">nb_and</tt>,
    <tt class="member">nb_xor</tt>, and <tt class="member">nb_or</tt>.
  </dd></dl>

<P>
<dl><dt><b><tt id='l2h-963' xml:id='l2h-963'>Py_TPFLAGS_HAVE_RICHCOMPARE</tt></b></dt>
<dd>
    If this bit is set, the type object has the
    <tt class="member">tp_richcompare</tt> field, as well as the <tt class="member">tp_traverse</tt>
    and the <tt class="member">tp_clear</tt> fields.
  </dd></dl>

<P>
<dl><dt><b><tt id='l2h-964' xml:id='l2h-964'>Py_TPFLAGS_HAVE_WEAKREFS</tt></b></dt>
<dd>
    If this bit is set, the <tt class="member">tp_weaklistoffset</tt> field is
    defined.  Instances of a type are weakly referenceable if the
    type's <tt class="member">tp_weaklistoffset</tt> field has a value greater than
    zero.
  </dd></dl>

<P>
<dl><dt><b><tt id='l2h-965' xml:id='l2h-965'>Py_TPFLAGS_HAVE_ITER</tt></b></dt>
<dd>
    If this bit is set, the type object has the <tt class="member">tp_iter</tt> and
    <tt class="member">tp_iternext</tt> fields.
  </dd></dl>

<P>
<dl><dt><b><tt id='l2h-966' xml:id='l2h-966'>Py_TPFLAGS_HAVE_CLASS</tt></b></dt>
<dd>
    If this bit is set, the type object has several new fields defined
    starting in Python 2.2: <tt class="member">tp_methods</tt>, <tt class="member">tp_members</tt>,
    <tt class="member">tp_getset</tt>, <tt class="member">tp_base</tt>, <tt class="member">tp_dict</tt>,
    <tt class="member">tp_descr_get</tt>, <tt class="member">tp_descr_set</tt>,
    <tt class="member">tp_dictoffset</tt>, <tt class="member">tp_init</tt>, <tt class="member">tp_alloc</tt>,
    <tt class="member">tp_new</tt>, <tt class="member">tp_free</tt>, <tt class="member">tp_is_gc</tt>,
    <tt class="member">tp_bases</tt>, <tt class="member">tp_mro</tt>, <tt class="member">tp_cache</tt>,
    <tt class="member">tp_subclasses</tt>, and <tt class="member">tp_weaklist</tt>.
  </dd></dl>

<P>
<dl><dt><b><tt id='l2h-967' xml:id='l2h-967'>Py_TPFLAGS_HEAPTYPE</tt></b></dt>
<dd>
    This bit is set when the type object itself is allocated on the
    heap.  In this case, the <tt class="member">ob_type</tt> field of its instances
    is considered a reference to the type, and the type object is
    INCREF'ed when a new instance is created, and DECREF'ed when an
    instance is destroyed (this does not apply to instances of
    subtypes; only the type referenced by the instance's ob_type gets
    INCREF'ed or DECREF'ed).
  </dd></dl>

<P>
<dl><dt><b><tt id='l2h-968' xml:id='l2h-968'>Py_TPFLAGS_BASETYPE</tt></b></dt>
<dd>
    This bit is set when the type can be used as the base type of
    another type.  If this bit is clear, the type cannot be subtyped
    (similar to a "final" class in Java).
  </dd></dl>

<P>
<dl><dt><b><tt id='l2h-969' xml:id='l2h-969'>Py_TPFLAGS_READY</tt></b></dt>
<dd>
    This bit is set when the type object has been fully initialized by
    <tt class="cfunction">PyType_Ready()</tt>.
  </dd></dl>

<P>
<dl><dt><b><tt id='l2h-970' xml:id='l2h-970'>Py_TPFLAGS_READYING</tt></b></dt>
<dd>
    This bit is set while <tt class="cfunction">PyType_Ready()</tt> is in the process
    of initializing the type object.
  </dd></dl>

<P>
<dl><dt><b><tt id='l2h-971' xml:id='l2h-971'>Py_TPFLAGS_HAVE_GC</tt></b></dt>
<dd>
    This bit is set when the object supports garbage collection.  If
    this bit is set, instances must be created using
    <tt class="cfunction">PyObject_GC_New()</tt> and destroyed using
    <tt class="cfunction">PyObject_GC_Del()</tt>.  More information in section XXX
    about garbage collection.  This bit also implies that the
    GC-related fields <tt class="member">tp_traverse</tt> and <tt class="member">tp_clear</tt> are
    present in the type object; but those fields also exist when
    <tt class="constant">Py_TPFLAGS_HAVE_GC</tt> is clear but
    <tt class="constant">Py_TPFLAGS_HAVE_RICHCOMPARE</tt> is set.
  </dd></dl>

<P>
<dl><dt><b><tt id='l2h-972' xml:id='l2h-972'>Py_TPFLAGS_DEFAULT</tt></b></dt>
<dd>
    This is a bitmask of all the bits that pertain to the existence of
    certain fields in the type object and its extension structures.
    Currently, it includes the following bits:
    <tt class="constant">Py_TPFLAGS_HAVE_GETCHARBUFFER</tt>,
    <tt class="constant">Py_TPFLAGS_HAVE_SEQUENCE_IN</tt>,
    <tt class="constant">Py_TPFLAGS_HAVE_INPLACEOPS</tt>,
    <tt class="constant">Py_TPFLAGS_HAVE_RICHCOMPARE</tt>,
    <tt class="constant">Py_TPFLAGS_HAVE_WEAKREFS</tt>,
    <tt class="constant">Py_TPFLAGS_HAVE_ITER</tt>, and
    <tt class="constant">Py_TPFLAGS_HAVE_CLASS</tt>.
  </dd></dl>
</dl>

<P>
<dl><dt>char* <b><tt id='l2h-973' xml:id='l2h-973' class="cmember">tp_doc</tt></b></dt>
<dd>
  An optional pointer to a NUL-terminated C string giving the
  docstring for this type object.  This is exposed as the
  <tt class="member">__doc__</tt> attribute on the type and instances of the type.

<P>
This field is <em>not</em> inherited by subtypes.
</dl>

<P>
The following three fields only exist if the
<tt class="constant">Py_TPFLAGS_HAVE_RICHCOMPARE</tt> flag bit is set.

<P>
<dl><dt>traverseproc <b><tt id='l2h-974' xml:id='l2h-974' class="cmember">tp_traverse</tt></b></dt>
<dd>
  An optional pointer to a traversal function for the garbage
  collector.  This is only used if the <tt class="constant">Py_TPFLAGS_HAVE_GC</tt>
  flag bit is set.  More information in section
  <A href="supporting-cycle-detection.html#supporting-cycle-detection">10.9</A> about garbage collection.

<P>
This field is inherited by subtypes together with <tt class="member">tp_clear</tt>
  and the <tt class="constant">Py_TPFLAGS_HAVE_GC</tt> flag bit: the flag bit,
  <tt class="member">tp_traverse</tt>, and <tt class="member">tp_clear</tt> are all inherited from
  the base type if they are all zero in the subtype <em>and</em> the
  subtype has the <tt class="constant">Py_TPFLAGS_HAVE_RICHCOMPARE</tt> flag bit set.
</dl>

<P>
<dl><dt>inquiry <b><tt id='l2h-975' xml:id='l2h-975' class="cmember">tp_clear</tt></b></dt>
<dd>
  An optional pointer to a clear function for the garbage collector.
  This is only used if the <tt class="constant">Py_TPFLAGS_HAVE_GC</tt> flag bit is
  set.  More information in section
  <A href="supporting-cycle-detection.html#supporting-cycle-detection">10.9</A> about garbage collection.

<P>
This field is inherited by subtypes together with <tt class="member">tp_clear</tt>
  and the <tt class="constant">Py_TPFLAGS_HAVE_GC</tt> flag bit: the flag bit,
  <tt class="member">tp_traverse</tt>, and <tt class="member">tp_clear</tt> are all inherited from
  the base type if they are all zero in the subtype <em>and</em> the
  subtype has the <tt class="constant">Py_TPFLAGS_HAVE_RICHCOMPARE</tt> flag bit set.
</dl>

<P>
<dl><dt>richcmpfunc <b><tt id='l2h-976' xml:id='l2h-976' class="cmember">tp_richcompare</tt></b></dt>
<dd>
  An optional pointer to the rich comparison function.

<P>
The signature is the same as for <tt class="cfunction">PyObject_RichCompare()</tt>.
  The function should return <code>1</code> if the requested comparison
  returns true, <code>0</code> if it returns false.  It should return
  <code>-1</code> and set an exception condition when an error occurred
  during the comparison.

<P>
This field is inherited by subtypes together with
  <tt class="member">tp_compare</tt> and <tt class="member">tp_hash</tt>: a subtype inherits all
  three of <tt class="member">tp_compare</tt>, <tt class="member">tp_richcompare</tt>, and
  <tt class="member">tp_hash</tt>, when the subtype's <tt class="member">tp_compare</tt>,
  <tt class="member">tp_richcompare</tt>, and <tt class="member">tp_hash</tt> are all <tt class="constant">NULL</tt>.

<P>
The following constants are defined to be used as the third argument
  for <tt class="member">tp_richcompare</tt> and for <tt class="cfunction">PyObject_RichCompare()</tt>:

<P>
<div class="center"><table class="realtable">
  <thead>
    <tr>
      <th class="left"  >Constant</th>
      <th class="center">Comparison</th>
      </tr>
    </thead>
  <tbody>
    <tr><td class="left"   valign="baseline"><tt class="constant">Py_LT</tt></td>
        <td class="center"><code>&lt;</code></td></tr>
    <tr><td class="left"   valign="baseline"><tt class="constant">Py_LE</tt></td>
        <td class="center"><code>&lt;=</code></td></tr>
    <tr><td class="left"   valign="baseline"><tt class="constant">Py_EQ</tt></td>
        <td class="center"><code>==</code></td></tr>
    <tr><td class="left"   valign="baseline"><tt class="constant">Py_NE</tt></td>
        <td class="center"><code>!=</code></td></tr>
    <tr><td class="left"   valign="baseline"><tt class="constant">Py_GT</tt></td>
        <td class="center"><code>&gt;</code></td></tr>
    <tr><td class="left"   valign="baseline"><tt class="constant">Py_GE</tt></td>
        <td class="center"><code>&gt;=</code></td></tr></tbody>
</table></div>
</dl>

<P>
The next field only exists if the <tt class="constant">Py_TPFLAGS_HAVE_WEAKREFS</tt>
flag bit is set.

<P>
<dl><dt>long <b><tt id='l2h-977' xml:id='l2h-977' class="cmember">tp_weaklistoffset</tt></b></dt>
<dd>
  If the instances of this type are weakly referenceable, this field
  is greater than zero and contains the offset in the instance
  structure of the weak reference list head (ignoring the GC header,
  if present); this offset is used by
  <tt class="cfunction">PyObject_ClearWeakRefs()</tt> and the
  <tt class="cfunction">PyWeakref_*()</tt> functions.  The instance structure needs
  to include a field of type <tt class="ctype">PyObject*</tt> which is initialized to
  <tt class="constant">NULL</tt>.

<P>
Do not confuse this field with <tt class="member">tp_weaklist</tt>; that is the
  list head for weak references to the type object itself.

<P>
This field is inherited by subtypes, but see the rules listed below.
  A subtype may override this offset; this means that the subtype uses
  a different weak reference list head than the base type.  Since the
  list head is always found via <tt class="member">tp_weaklistoffset</tt>, this
  should not be a problem.

<P>
When a type defined by a class statement has no <tt class="member">__slots__</tt>
  declaration, and none of its base types are weakly referenceable,
  the type is made weakly referenceable by adding a weak reference
  list head slot to the instance layout and setting the
  <tt class="member">tp_weaklistoffset</tt> of that slot's offset.

<P>
When a type's <tt class="member">__slots__</tt> declaration contains a slot named
  <tt class="member">__weakref__</tt>, that slot becomes the weak reference list head
  for instances of the type, and the slot's offset is stored in the
  type's <tt class="member">tp_weaklistoffset</tt>.

<P>
When a type's <tt class="member">__slots__</tt> declaration does not contain a slot
  named <tt class="member">__weakref__</tt>, the type inherits its
  <tt class="member">tp_weaklistoffset</tt> from its base type.
</dl>

<P>
The next two fields only exist if the
<tt class="constant">Py_TPFLAGS_HAVE_CLASS</tt> flag bit is set.

<P>
<dl><dt>getiterfunc <b><tt id='l2h-978' xml:id='l2h-978' class="cmember">tp_iter</tt></b></dt>
<dd>
  An optional pointer to a function that returns an iterator for the
  object.  Its presence normally signals that the instances of this
  type are iterable (although sequences may be iterable without this
  function, and classic instances always have this function, even if
  they don't define an <tt class="method">__iter__()</tt> method).

<P>
This function has the same signature as
  <tt class="cfunction">PyObject_GetIter()</tt>.

<P>
This field is inherited by subtypes.
</dl>

<P>
<dl><dt>iternextfunc <b><tt id='l2h-979' xml:id='l2h-979' class="cmember">tp_iternext</tt></b></dt>
<dd>
  An optional pointer to a function that returns the next item in an
  iterator, or raises <tt class="exception">StopIteration</tt> when the iterator is
  exhausted.  Its presence normally signals that the instances of this
  type are iterators (although classic instances always have this
  function, even if they don't define a <tt class="method">next()</tt> method).

<P>
Iterator types should also define the <tt class="member">tp_iter</tt> function, and
  that function should return the iterator instance itself (not a new
  iterator instance).

<P>
This function has the same signature as <tt class="cfunction">PyIter_Next()</tt>.

<P>
This field is inherited by subtypes.
</dl>

<P>
The next fields, up to and including <tt class="member">tp_weaklist</tt>, only exist
if the <tt class="constant">Py_TPFLAGS_HAVE_CLASS</tt> flag bit is set.

<P>
<dl><dt>struct PyMethodDef* <b><tt id='l2h-980' xml:id='l2h-980' class="cmember">tp_methods</tt></b></dt>
<dd>
  An optional pointer to a static <tt class="constant">NULL</tt>-terminated array of
  <tt class="ctype">PyMethodDef</tt> structures, declaring regular methods of this
  type.

<P>
For each entry in the array, an entry is added to the type's
  dictionary (see <tt class="member">tp_dict</tt> below) containing a method
  descriptor.

<P>
This field is not inherited by subtypes (methods are
  inherited through a different mechanism).
</dl>

<P>
<dl><dt>struct PyMemberDef* <b><tt id='l2h-981' xml:id='l2h-981' class="cmember">tp_members</tt></b></dt>
<dd>
  An optional pointer to a static <tt class="constant">NULL</tt>-terminated array of
  <tt class="ctype">PyMemberDef</tt> structures, declaring regular data members
  (fields or slots) of instances of this type.

<P>
For each entry in the array, an entry is added to the type's
  dictionary (see <tt class="member">tp_dict</tt> below) containing a member
  descriptor.

<P>
This field is not inherited by subtypes (members are inherited
  through a different mechanism).
</dl>

<P>
<dl><dt>struct PyGetSetDef* <b><tt id='l2h-982' xml:id='l2h-982' class="cmember">tp_getset</tt></b></dt>
<dd>
  An optional pointer to a static <tt class="constant">NULL</tt>-terminated array of
  <tt class="ctype">PyGetSetDef</tt> structures, declaring computed attributes of
  instances of this type.

<P>
For each entry in the array, an entry is added to the type's
  dictionary (see <tt class="member">tp_dict</tt> below) containing a getset
  descriptor.

<P>
This field is not inherited by subtypes (computed attributes are
  inherited through a different mechanism).

<P>
Docs for PyGetSetDef (XXX belong elsewhere):

<P>
<div class="verbatim"><pre>
typedef PyObject *(*getter)(PyObject *, void *);
typedef int (*setter)(PyObject *, PyObject *, void *);

typedef struct PyGetSetDef {
    char *name;    /* attribute name */
    getter get;    /* C function to get the attribute */
    setter set;    /* C function to set the attribute */
    char *doc;     /* optional doc string */
    void *closure; /* optional additional data for getter and setter */
} PyGetSetDef;
</pre></div>
</dl>

<P>
<dl><dt>PyTypeObject* <b><tt id='l2h-983' xml:id='l2h-983' class="cmember">tp_base</tt></b></dt>
<dd>
  An optional pointer to a base type from which type properties are
  inherited.  At this level, only single inheritance is supported;
  multiple inheritance require dynamically creating a type object by
  calling the metatype.

<P>
This field is not inherited by subtypes (obviously), but it defaults
  to <code>&amp;PyBaseObject_Type</code> (which to Python programmers is known
  as the type <tt class="class">object</tt>).
</dl>

<P>
<dl><dt>PyObject* <b><tt id='l2h-984' xml:id='l2h-984' class="cmember">tp_dict</tt></b></dt>
<dd>
  The type's dictionary is stored here by <tt class="cfunction">PyType_Ready()</tt>.

<P>
This field should normally be initialized to <tt class="constant">NULL</tt> before
  PyType_Ready is called; it may also be initialized to a dictionary
  containing initial attributes for the type.  Once
  <tt class="cfunction">PyType_Ready()</tt> has initialized the type, extra
  attributes for the type may be added to this dictionary only if they
  don't correspond to overloaded operations (like <tt class="method">__add__()</tt>).

<P>
This field is not inherited by subtypes (though the attributes
  defined in here are inherited through a different mechanism).
</dl>

<P>
<dl><dt>descrgetfunc <b><tt id='l2h-985' xml:id='l2h-985' class="cmember">tp_descr_get</tt></b></dt>
<dd>
  An optional pointer to a "descriptor get" function.

<P>
XXX blah, blah.

<P>
This field is inherited by subtypes.
</dl>

<P>
<dl><dt>descrsetfunc <b><tt id='l2h-986' xml:id='l2h-986' class="cmember">tp_descr_set</tt></b></dt>
<dd>
  An optional pointer to a "descriptor set" function.

<P>
XXX blah, blah.

<P>
This field is inherited by subtypes.
</dl>

<P>
<dl><dt>long <b><tt id='l2h-987' xml:id='l2h-987' class="cmember">tp_dictoffset</tt></b></dt>
<dd>
  If the instances of this type have a dictionary containing instance
  variables, this field is non-zero and contains the offset in the
  instances of the type of the instance variable dictionary; this
  offset is used by <tt class="cfunction">PyObject_GenericGetAttr()</tt>.

<P>
Do not confuse this field with <tt class="member">tp_dict</tt>; that is the
  dictionary for attributes of the type object itself.

<P>
If the value of this field is greater than zero, it specifies the
  offset from the start of the instance structure.  If the value is
  less than zero, it specifies the offset from the <em>end</em> of the
  instance structure.  A negative offset is more expensive to use, and
  should only be used when the instance structure contains a
  variable-length part.  This is used for example to add an instance
  variable dictionary to subtypes of <tt class="class">str</tt> or <tt class="class">tuple</tt>.
  Note that the <tt class="member">tp_basicsize</tt> field should account for the
  dictionary added to the end in that case, even though the dictionary
  is not included in the basic object layout.  On a system with a
  pointer size of 4 bytes, <tt class="member">tp_dictoffset</tt> should be set to
  <code>-4</code> to indicate that the dictionary is at the very end of the
  structure.

<P>
The real dictionary offset in an instance can be computed from a
  negative <tt class="member">tp_dictoffset</tt> as follows:

<P>
<div class="verbatim"><pre>
dictoffset = tp_basicsize + abs(ob_size)*tp_itemsize + tp_dictoffset
if dictoffset is not aligned on sizeof(void*):
    round up to sizeof(void*)
</pre></div>

<P>
where <tt class="member">tp_basicsize</tt>, <tt class="member">tp_itemsize</tt> and
  <tt class="member">tp_dictoffset</tt> are taken from the type object, and
  <tt class="member">ob_size</tt> is taken from the instance.  The absolute value is
  taken because long ints use the sign of <tt class="member">ob_size</tt> to store
  the sign of the number.  (There's never a need to do this
  calculation yourself; it is done for you by
  <tt class="cfunction">_PyObject_GetDictPtr()</tt>.)

<P>
This field is inherited by subtypes, but see the rules listed below.
  A subtype may override this offset; this means that the subtype
  instances store the dictionary at a difference offset than the base
  type.  Since the dictionary is always found via
  <tt class="member">tp_dictoffset</tt>, this should not be a problem.

<P>
When a type defined by a class statement has no <tt class="member">__slots__</tt>
  declaration, and none of its base types has an instance variable
  dictionary, a dictionary slot is added to the instance layout and
  the <tt class="member">tp_dictoffset</tt> is set to that slot's offset.

<P>
When a type defined by a class statement has a <tt class="member">__slots__</tt>
  declaration, the type inherits its <tt class="member">tp_dictoffset</tt> from its
  base type.

<P>
(Adding a slot named <tt class="member">__dict__</tt> to the <tt class="member">__slots__</tt>
  declaration does not have the expected effect, it just causes
  confusion.  Maybe this should be added as a feature just like
  <tt class="member">__weakref__</tt> though.)
</dl>

<P>
<dl><dt>initproc <b><tt id='l2h-988' xml:id='l2h-988' class="cmember">tp_init</tt></b></dt>
<dd>
  An optional pointer to an instance initialization function.

<P>
This function corresponds to the <tt class="method">__init__()</tt> method of
  classes.  Like <tt class="method">__init__()</tt>, it is possible to create an
  instance without calling <tt class="method">__init__()</tt>, and it is possible to
  reinitialize an instance by calling its <tt class="method">__init__()</tt> method
  again.

<P>
The function signature is

<P>
<div class="verbatim"><pre>
int tp_init(PyObject *self, PyObject *args, PyObject *kwds)
</pre></div>

<P>
The self argument is the instance to be initialized; the <var>args</var>
  and <var>kwds</var> arguments represent positional and keyword arguments
  of the call to <tt class="method">__init__()</tt>.

<P>
The <tt class="member">tp_init</tt> function, if not <tt class="constant">NULL</tt>, is called when an
  instance is created normally by calling its type, after the type's
  <tt class="member">tp_new</tt> function has returned an instance of the type.  If
  the <tt class="member">tp_new</tt> function returns an instance of some other type
  that is not a subtype of the original type, no <tt class="member">tp_init</tt>
  function is called; if <tt class="member">tp_new</tt> returns an instance of a
  subtype of the original type, the subtype's <tt class="member">tp_init</tt> is
  called.  (VERSION NOTE: described here is what is implemented in
  Python 2.2.1 and later.  In Python 2.2, the <tt class="member">tp_init</tt> of the
  type of the object returned by <tt class="member">tp_new</tt> was always called, if
  not <tt class="constant">NULL</tt>.)

<P>
This field is inherited by subtypes.
</dl>

<P>
<dl><dt>allocfunc <b><tt id='l2h-989' xml:id='l2h-989' class="cmember">tp_alloc</tt></b></dt>
<dd>
  An optional pointer to an instance allocation function.

<P>
The function signature is

<P>
<div class="verbatim"><pre>
PyObject *tp_alloc(PyTypeObject *self, int nitems)
</pre></div>

<P>
The purpose of this function is to separate memory allocation from
  memory initialization.  It should return a pointer to a block of
  memory of adequate length for the instance, suitably aligned, and
  initialized to zeros, but with <tt class="member">ob_refcnt</tt> set to <code>1</code>
  and <tt class="member">ob_type</tt> set to the type argument.  If the type's
  <tt class="member">tp_itemsize</tt> is non-zero, the object's <tt class="member">ob_size</tt> field
  should be initialized to <var>nitems</var> and the length of the
  allocated memory block should be <code>tp_basicsize +
  <var>nitems</var>*tp_itemsize</code>, rounded up to a multiple of
  <code>sizeof(void*)</code>; otherwise, <var>nitems</var> is not used and the
  length of the block should be <tt class="member">tp_basicsize</tt>.

<P>
Do not use this function to do any other instance initialization,
  not even to allocate additional memory; that should be done by
  <tt class="member">tp_new</tt>.

<P>
This field is inherited by static subtypes, but not by dynamic
  subtypes (subtypes created by a class statement); in the latter,
  this field is always set to <tt class="cfunction">PyType_GenericAlloc()</tt>, to
  force a standard heap allocation strategy.  That is also the
  recommended value for statically defined types.
</dl>

<P>
<dl><dt>newfunc <b><tt id='l2h-990' xml:id='l2h-990' class="cmember">tp_new</tt></b></dt>
<dd>
  An optional pointer to an instance creation function.

<P>
If this function is <tt class="constant">NULL</tt> for a particular type, that type cannot
  be called to create new instances; presumably there is some other
  way to create instances, like a factory function.

<P>
The function signature is

<P>
<div class="verbatim"><pre>
PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds)
</pre></div>

<P>
The subtype argument is the type of the object being created; the
  <var>args</var> and <var>kwds</var> arguments represent positional and keyword
  arguments of the call to the type.  Note that subtype doesn't have
  to equal the type whose <tt class="member">tp_new</tt> function is called; it may
  be a subtype of that type (but not an unrelated type).

<P>
The <tt class="member">tp_new</tt> function should call
  <code><var>subtype</var>-&gt;tp_alloc(<var>subtype</var>, <var>nitems</var>)</code> to
  allocate space for the object, and then do only as much further
  initialization as is absolutely necessary.  Initialization that can
  safely be ignored or repeated should be placed in the
  <tt class="member">tp_init</tt> handler.  A good rule of thumb is that for
  immutable types, all initialization should take place in
  <tt class="member">tp_new</tt>, while for mutable types, most initialization should
  be deferred to <tt class="member">tp_init</tt>.

<P>
This field is inherited by subtypes, except it is not inherited by
  static types whose <tt class="member">tp_base</tt> is <tt class="constant">NULL</tt> or
  <code>&amp;PyBaseObject_Type</code>.  The latter exception is a precaution so
  that old extension types don't become callable simply by being
  linked with Python 2.2.
</dl>

<P>
<dl><dt>destructor <b><tt id='l2h-991' xml:id='l2h-991' class="cmember">tp_free</tt></b></dt>
<dd>
  An optional pointer to an instance deallocation function.

<P>
The signature of this function has changed slightly: in Python
  2.2 and 2.2.1, its signature is <tt class="ctype">destructor</tt>:

<P>
<div class="verbatim"><pre>
void tp_free(PyObject *)
</pre></div>

<P>
In Python 2.3 and beyond, its signature is <tt class="ctype">freefunc</tt>:

<P>
<div class="verbatim"><pre>
void tp_free(void *)
</pre></div>

<P>
The only initializer that is compatible with both versions is
  <code>_PyObject_Del</code>, whose definition has suitably adapted in
  Python 2.3.

<P>
This field is inherited by static subtypes, but not by dynamic
  subtypes (subtypes created by a class statement); in the latter,
  this field is set to a deallocator suitable to match
  <tt class="cfunction">PyType_GenericAlloc()</tt> and the value of the
  <tt class="constant">Py_TPFLAGS_HAVE_GC</tt> flag bit.
</dl>

<P>
<dl><dt>inquiry <b><tt id='l2h-992' xml:id='l2h-992' class="cmember">tp_is_gc</tt></b></dt>
<dd>
  An optional pointer to a function called by the garbage collector.

<P>
The garbage collector needs to know whether a particular object is
  collectible or not.  Normally, it is sufficient to look at the
  object's type's <tt class="member">tp_flags</tt> field, and check the
  <tt class="constant">Py_TPFLAGS_HAVE_GC</tt> flag bit.  But some types have a
  mixture of statically and dynamically allocated instances, and the
  statically allocated instances are not collectible.  Such types
  should define this function; it should return <code>1</code> for a
  collectible instance, and <code>0</code> for a non-collectible instance.
  The signature is

<P>
<div class="verbatim"><pre>
int tp_is_gc(PyObject *self)
</pre></div>

<P>
(The only example of this are types themselves.  The metatype,
  <tt class="cdata">PyType_Type</tt>, defines this function to distinguish between
  statically and dynamically allocated types.)

<P>
This field is inherited by subtypes.  (VERSION NOTE: in Python
  2.2, it was not inherited.  It is inherited in 2.2.1 and later
  versions.)
</dl>

<P>
<dl><dt>PyObject* <b><tt id='l2h-993' xml:id='l2h-993' class="cmember">tp_bases</tt></b></dt>
<dd>
  Tuple of base types.

<P>
This is set for types created by a class statement.  It should be
  <tt class="constant">NULL</tt> for statically defined types.

<P>
This field is not inherited.
</dl>

<P>
<dl><dt>PyObject* <b><tt id='l2h-994' xml:id='l2h-994' class="cmember">tp_mro</tt></b></dt>
<dd>
  Tuple containing the expanded set of base types, starting with the
  type itself and ending with <tt class="class">object</tt>, in Method Resolution
  Order.

<P>
This field is not inherited; it is calculated fresh by
  <tt class="cfunction">PyType_Ready()</tt>.
</dl>

<P>
<dl><dt>PyObject* <b><tt id='l2h-995' xml:id='l2h-995' class="cmember">tp_cache</tt></b></dt>
<dd>
  Unused.  Not inherited.  Internal use only.
</dl>

<P>
<dl><dt>PyObject* <b><tt id='l2h-996' xml:id='l2h-996' class="cmember">tp_subclasses</tt></b></dt>
<dd>
  List of weak references to subclasses.  Not inherited.  Internal
  use only.
</dl>

<P>
<dl><dt>PyObject* <b><tt id='l2h-997' xml:id='l2h-997' class="cmember">tp_weaklist</tt></b></dt>
<dd>
  Weak reference list head, for weak references to this type
  object.  Not inherited.  Internal use only.
</dl>

<P>
The remaining fields are only defined if the feature test macro
<tt class="constant">COUNT_ALLOCS</tt> is defined, and are for internal use only.
They are documented here for completeness.  None of these fields are
inherited by subtypes.

<P>
<dl><dt>int <b><tt id='l2h-998' xml:id='l2h-998' class="cmember">tp_allocs</tt></b></dt>
<dd>
  Number of allocations.
</dl>

<P>
<dl><dt>int <b><tt id='l2h-999' xml:id='l2h-999' class="cmember">tp_frees</tt></b></dt>
<dd>
  Number of frees.
</dl>

<P>
<dl><dt>int <b><tt id='l2h-1000' xml:id='l2h-1000' class="cmember">tp_maxalloc</tt></b></dt>
<dd>
  Maximum simultaneously allocated objects.
</dl>

<P>
<dl><dt>PyTypeObject* <b><tt id='l2h-1001' xml:id='l2h-1001' class="cmember">tp_next</tt></b></dt>
<dd>
  Pointer to the next type object with a non-zero <tt class="member">tp_allocs</tt>
  field.
</dl>

<P>
Also, note that, in a garbage collected Python, tp_dealloc may be
called from any Python thread, not just the thread which created the
object (if the object becomes part of a refcount cycle, that cycle
might be collected by a garbage collection on any thread).  This is
not a problem for Python API calls, since the thread on which
tp_dealloc is called will own the Global Interpreter Lock (GIL).
However, if the object being destroyed in turn destroys objects from
some other C or C++ library, care should be taken to ensure that
destroying those objects on the thread which called tp_dealloc will
not violate any assumptions of the library.

<P>

<DIV CLASS="navigation">
<div class='online-navigation'>
<p></p><hr />
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="10.2 Common Object Structures"
  href="common-structs.html"><img src='../icons/previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></A></td>
<td class='online-navigation'><a rel="parent" title="10. Object Implementation Support"
  href="newTypes.html"><img src='../icons/up.png'
  border='0' height='32'  alt='Up One Level' width='32' /></A></td>
<td class='online-navigation'><a rel="next" title="10.4 Mapping Object Structures"
  href="mapping-structs.html"><img src='../icons/next.png'
  border='0' height='32'  alt='Next Page' width='32' /></A></td>
<td align="center" width="100%">Python/C API Reference Manual</td>
<td class='online-navigation'><a rel="contents" title="Table of Contents"
  href="contents.html"><img src='../icons/contents.png'
  border='0' height='32'  alt='Contents' width='32' /></A></td>
<td class='online-navigation'><img src='../icons/blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><a rel="index" title="Index"
  href="genindex.html"><img src='../icons/index.png'
  border='0' height='32'  alt='Index' width='32' /></A></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="common-structs.html">10.2 Common Object Structures</A>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="newTypes.html">10. Object Implementation Support</A>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="mapping-structs.html">10.4 Mapping Object Structures</A>
</div>
</div>
<hr />
<span class="release-info">Release 2.4.2, documentation updated on 28 September 2005.</span>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
See <i><a href="about.html">About this document...</a></i> for information on suggesting changes.
</ADDRESS>
</BODY>
</HTML>
