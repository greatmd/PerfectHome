#!/usr/bin/perl
################################################################################
# OpenSPARC T2 build/regression script
################################################################################
# 
# %sims -help 
# OR
# %sims -h
# for help
# 
#                        sims
#                         |
#                         |
#                         |
#     +----------------+---------+--------+--------+--------+-----+-------+
#     |                |         |        |        |        |     |       |
#     |                |         |        |        |        |     |       |
#     |                |         |        |        |        |     |       |
#     |                |         |        |        |        |     |       |
# ncverilog    ncverilog+sas    vcs    vcs+sas   sas     build   run  regression
#
#
################################################################################

use warnings;
use strict;
# use diagnostics;

use Cwd;
use Cwd 'chdir';
use File::Basename ;
use File::Find ;
use File::Spec ;
use File::stat ;
use Getopt::Long ;
use TRELoad 'DiagList', 'Sims' => [':all'] ;
use Fcntl ':flock' ;
use Socket;
use Digest::MD5 qw(md5);

#define SYSTEMC_SUPPORT

################################################################################
# patch PWD just in case
################################################################################

$ENV{PWD} = Cwd::cwd () ;
$| = 1 ;

################################################################################
# install signal handlers
################################################################################

$SIG{INT} = \&sighandler ;
$SIG{TERM} = \&sighandler ;
$SIG{QUIT} = \&sighandler ;
$SIG{__DIE__} = \&sighandler ;

################################################################################
# declare all global variables {{{
################################################################################

my $prg = $0 ;
$prg =~ s/.*\/// ;
my $version = $prg ;
$prg =~ s/,.*// ;          # name of this program
$version =~ s/.*,// ;      # tre version of script
my $pid = $$ ;             # process id of this job
my $sas_pid = 0 ;          # process id of simics run
my $tcl_pid = 0 ;	   # process id of tcl_tap expect process
my $opt_debug = 0 ;        # debug flag
my $user = $ENV{USER} ;    # user name
my $work_dir = undef ;       # work directory
my $launch_dir = $ENV{PWD};  # work directory
my $home_dir = (exists $ENV{HOME}) ? $ENV{HOME} : "~";
my %opt = () ;             # all command line arguments
                           # + config file arguments are concatenated
                           # and stored here
my $orig_tre_search = $ENV{TRE_SEARCH} ;

## for ClearCase usage
my $CLEARCASE_ROOT;
my $CC_VIEW_NAME;
my $CLEARTOOL		= "/usr/atria/bin/cleartool";
my $PROJ_CSHRC		= File::Spec->catfile(
					$home_dir,
					".cshrc." . uc( $proj_vars{proj} )
					     );
if ( exists $ENV{CLEARCASE_ROOT} ) {
    $CLEARCASE_ROOT	= $ENV{CLEARCASE_ROOT};
    my @fields		= split(/\//, $CLEARCASE_ROOT);
    $CC_VIEW_NAME	= $fields[2];
}
my $cc_dv_root ;
my $pre_process_done = 0;
my $cache_clean_time=24;
my $sas_timer=10;

print "(debug) delclaration of all global variables complete...\n";
#############################################################################}}}
# configure Getopt::Long {{{
################################################################################

# Getopt::Long::Configure ('debug') ;
Getopt::Long::Configure ('prefix=-') ;
Getopt::Long::Configure ('no_ignore_case') ;
Getopt::Long::Configure ('permute') ;
Getopt::Long::Configure ('pass_through') ;
Getopt::Long::Configure ('no_auto_abbrev') ;

print "(debug) configure Getopt::Long complete...\n";
#############################################################################}}}
# declare hash to hold command line arguments + config arguments {{{
################################################################################

%opt = (
        'alias' => "",
        'asm_diag_name' => "",
        'asm_diag_path' => "",
        'asm_diag_root' => [],
        'auditr_args' => [],
        'build' => 1,
        'cc_dv_root' => "",
        'cdms_rel_name' => "",
        'clearcase' => 0,
        'config_rtl' => [],
        'config_cpp_args' => [],
        'debug' => \$opt_debug,
        'debussy' => 0,
        'dftvert' => 0,
        'diag_pl_args' => [],
        'diaglist' => "",
        'diaglist_cpp_args' => [],
        'diff_cdms_rel' => 0,
        'diff_cdms_curr' => 0,
        'drmlog' => 1,
        'drmlog_name' => "dream.log",
        'drmcommand_name' => "drm_command",
        'drmconstraints_name' => "drm_constraints",
        'drm_constraints_file' => "",
        'drm_cpufreq' => "",
        'drm_disk' => "",
        'drm_freeprocessor' => "1.0",
        'drm_freeram' => "1000",
        'drm_freeswap' => "1000",
        'drm_license' => "[vcs=1,vera=1]",
        'drm_priority' => "",
        'drm_project' => $proj_vars{proj},
        'drm_totprocessor' => "",
        'drm_type' => "vcs",
        'drm_on' => 0,
        'drm_osver' => "",
        'drm_window' => "",
        'dv_root' => "",
        'efc' => 0,
        'efc_args' => [],
        'efuse_image_name' => "",
        'efuse_image_path' => "",
        'efuse_image_root' => [],
        'env_base' => "",
        'fast_boot' => 0,
        'finish_mask' => "",
        'flist' => [],
        'fsdb2vcd' => 0,
        'fsdbfile' => "",
        'fsdbDumplimit' => "",
        'fsdb_glitch' => 0,
        'graft_flist' => "",
        'group' => [],
        'group_name' => "",
        'gzip' => 1,
        'h' => 0,
        'hcs_build' => 0,
        'hcs_build_args' => [],
        'hcs_run' => 0,
        'hcs_run_args' => [],
        'hcs_drm_tokens' => 1,
        'axis_build' => 0,
        'axis_build_args' => [],
        'axis_run' => 0,
        'axis_run_args' => [],
        'help' => 0,
        'image_diag_name' => "",
        'image_diag_path' => "",
        'image_diag_root' => [],
        'indrm' => -1,
        'max_cycle' => 0,
        'midas_args' => [],
        'midas_only' => 0,
        'midas_use_tgseed' => 0,
        'model_dir' => "",
        'ntb_lib' => 0,
        'overwrite' => 0,
        'palladium_build' => 0,
        'palladium_build_args' => [],
        'palladium_run' => 0,
        'palladium_run_args' => [],
        'pal_use_tgseed' => 0,
        'pci' => 0,
        'pci_args' => [],
        'pci_diag_name' => "",
        'pci_diag_path' => "",
        'pci_diag_root' => [],
        'post_process_cmd' => [],
        'pre_process_cmd' => [],
        'reg_count' => 0,
        'regress' => 0,
        'regress_date' => "",
        'regress_id' => "",
        'regress_time' => "",
        'report' => 0,
        'rerun' => 0,
        'result_dir' => "",
        'rtl_timeout' => 5000,
        'run_diag_pl' => 1,
        'sas' => 0,
        'saslog' => 1,
        'sas_run_args' => [],
        'sims_config' => "",
        'sims_env' => [],
        'simslog' => 1,
        'simslog_name' => "sims.log",
        'sjm' => 0,
        'sjm_args' => [],
        'sjm_diag_name' => "",
        'sjm_diag_path' => "",
        'sjm_diag_root' => [],
        'spis_diag_name' => "",
        'spis_diag_path' => "",
        'spis_diag_root' => [],
        'start_dump' => 0,
        'stop_dump' => 0,
        'stub_mask' => "",
        'sunv_args' => [],
        'sunv_nonprim_list' => "",
        'sunv_run' => 0,
        'sunv_use_nonprim' => 0,
        'sys' => "",
#ifdef SYSTEMC_SUPPORT
        'sysc_build' => 0,
        'syscan_build_args' => [],
#endif
        'tap_diag_name' => "",
        'tap_diag_path' => "",
        'tap_diag_root' => [],
        'tcl_tap' => 0,
        'tcl_tap_diag' => "",
        'tg_seed' => -1,
        'tomatillo' => 0,
        'tpt_diag_name' => "",
        'tpt_diag_path' => "",
        'tpt_diag_root' => [],
        'use_auditr' => 0,
        'use_cdms_iver' => 1,
        'use_config' => 1,
        'use_denalirc' => "",
        'use_iver' => "",
        'use_sims_iver' => 1,
        'vcd' => 0,
        'vcdfile' => "",
        'sim' => "vcs",  # default simulator is assumed to be VCS from synopsys
        'ncv_build'=>0,
        'ncv_build_args'=>[],
        'ncv_clean'=>0,
        'ncv_run'=>0,
        'ncv_run_args'=>[],
        'vcs_build' => 0,
        'vcs_build_args' => [],
        'vcs_clean' => 0,
        'vcs_cm_args' => "",
        'vcs_cm_cond' => "",
        'vcs_cm_config' => "",
        'vcs_cm_fsmcfg' => "",
        'vcs_cm_merge' => 0,
        'vcs_cm_name' => "cm_data",
        'vcs_finish' => 0,
        'vcs_full64' => 0,
        'vcs_prof' => 0,
        'model_rel_name' => "",
        'vcs_run' => 0,
        'vcs_run_args' => [],
        'vcs_use_cm' => 0,
        'vcs_use_cli' => 0,
        'vcs_use_ucli' => 0,
        'vcs_use_fsdb' => 1, # linhai88, fix pli issue ??         'vcs_use_fsdb' => 1
        'vcs_use_initreg' => 0,
        'vcs_use_ntb' => 0,
        'vcs_use_rad' => 0,
        'vcs_use_radincr' => 0,
        'vcs_use_sdf' => 0,
        'vcs_use_vcsd' => 1,
        'vcs_use_vera' => 0,
        'vera_build' => -1,
        'vera_build_args' => [],
        'vera_clean' => 0,
        'vera_config_name' => "",
        'vera_config_path' => "",
        'vera_config_root' => [],
        'vera_cov_obj' => [],
        'vera_diag_args' => [],
        'vera_dummy_diag' => "",
        'vera_pal_diag_args' => [],
        'vera_diag_name' => "",
        'vera_diag_path' => "",
        'vera_diag_root' => [],
        'vera_gmake' => 1,
        'vera_proj_args' => [],
        'vera_run' => 1,
        'vera_vcon_file' => "",
        'version' => 0,
        'vfile' => [],
        'vlint_args' => [],
        'vlint_run' => 0,
        'vlint_top' => "",
        'illust_run' => 0,
        'illust_args' => [],
        'verix_args' => [],
        'verix_libs' => [],
        'verix_run' => 0,
        'verix_top' => "",
        'wait_cycle_to_kill' => 0,
        'zeroIn_build' => 0,
        'zeroIn_dbg_args' => [],
        'zeroIn_checklist' => 0,
        'zeroInSearch_build' => 0,
        'zeroIn_build_args' => [],
        'sim_q_command' => "/bin/sh",
	'parallel' => 0,
    'exe_dir' => "",
    'cache' => 0,
       );

  print "(debug) opt hash declaration complete...\n";
#############################################################################}}}
# parse initial command line options {{{
################################################################################

GetOptions (\%opt,
            'h!',
            'help!',
            'version!',
            'use_iver=s',
           ) ;

#############################################################################}}}
# relaunch sims with a new iver {{{
# Donguk : not executed bc we use default iver
################################################################################

if ($opt{sim} eq 'ncv') {
foreach (@ARGV) {
    if (m/-vcs_build/) { s/-vcs_build/-ncv_build/; }
    elsif (m/-vcs_run/) { s/-vcs_run/-ncv_run/; }
}
}
my @argv_copy = @ARGV ;    # copy of original command line arguments

if ($opt{use_iver} ne "") {

  die ("DIE. Could not read specified iver \"file\" $opt{use_iver}") if (! -r $opt{use_iver}) ;

  $ENV{TRE_SEARCH} = "$opt{use_iver} $ENV{TRE_SEARCH}" ;

  my $cmd ;
  $cmd .= "$prg " ;
  $cmd .= "-h " if ($opt{h}) ;
  $cmd .= "-help " if ($opt{help}) ;
  $cmd .= "-version " if ($opt{version}) ;
  $cmd .= "-cache = 1";

  foreach my $x (@ARGV)
  {
    ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/)) ;
    ($x =~ s/"/\\"/go) if ($opt{use_auditr}); # Escape quote if using auditr "
    $cmd .= "$x " ;
  }

  # Don't use cdms_iver if using use_iver ..
  $cmd .= "-nouse_cdms_iver ";
  system ($cmd) ;
  exit (0) ;
}
  print "(debug) ncv setting complete...\n";
 
#############################################################################}}}
# print out version {{{
################################################################################

if ($opt{version}) {
  print "$prg version: $version\n";
  exit (0);
}
  print "(debug) version print complete...\n";

#############################################################################}}}
# print out help {{{
################################################################################

if ($opt{help} or $opt{h}) {
#  system ("perldoc $0") ;
    &usage;
  exit (0);
}

  print "(debug) print-out-help complete...\n";
#############################################################################}}}
# rerun a diag {{{
################################################################################

GetOptions (\%opt,
            'overwrite!',
            'rerun!',
            'dv_root=s',
            'use_sims_iver!',
            'use_cdms_iver!',
           ) ;

if ($opt{rerun}) {
  &rerun () ;
  exit (0) ;
}

  print "(debug) rerun-a-diag complete...\n";

#############################################################################}}}
# define $dv_root {{{
################################################################################

my $dv_root ;

if ($opt{dv_root} ne "") { $dv_root = $opt{dv_root} ; }
elsif (defined $ENV{DV_ROOT}) { $dv_root = $ENV{DV_ROOT} ; }
else { die ("DIE. could not initialize dv_root") ; }

$ENV{DV_ROOT} = $dv_root;
print "(Debug) define DV_ROOT = $dv_root\n";

#############################################################################}}}
# use a set of tools frozen under cdms {{{
################################################################################

# DRP 3/22/07 - comment out the following 2 lines to disable using the sims.iver/tver files

# my $iver_file = "$dv_root/verif/env/config/tre/sims.iver" ;
# $ENV{TRE_SEARCH} = $iver_file if ((-f $iver_file) and $opt{use_cdms_iver}) ;

#############################################################################}}}
# if this diag must be run in DReAM send ourselves back out {{{
################################################################################

GetOptions (\%opt,
            'indrm!',
            'interactive!',
           ) ;

if (($opt{indrm} == 1) or $opt{interactive})
{
  run_indrm (\@argv_copy, []) ;
  exit (0) ;
}

  print "(debug) run_indrm is not called..\n";

#############################################################################}}}
# parse second set of command line options {{{
################################################################################

#print "(debug) @ARGV\n";
GetOptions (\%opt,
            'alias=s',
            'cc_dv_root=s',
            'clearcase!',
            'config_cpp_args=s@',
            'debug' => \$opt_debug,
            'diaglist=s',
            'diaglist_cpp_args=s@',
            'group=s@',
            'model_dir=s',
            'regress!',
            'regress_id=s',
            'report!',
            'result_dir=s',
            'sim_q_command=s',
            'sims_config=s',
           ) ;

#print "(debug) @ARGV\n";

#############################################################################}}}
# define $cc_dv_root {{{
# Donguk : ClearCase (cc) ??
################################################################################

if ( $opt{clearcase} ) {
    if ($opt{cc_dv_root} ne "") { $cc_dv_root = $opt{cc_dv_root} ; }
    elsif (defined $ENV{CC_DV_ROOT}) { $cc_dv_root = $ENV{CC_DV_ROOT} ; }
    elsif (defined $proj_vars{cc_dv_root}) {
	$cc_dv_root = $proj_vars{cc_dv_root}; }
    else { die ("DIE. could not initialize cc_dv_root") ; }
}
  print "(debug) clearCase is complete..\n";

#############################################################################}}}
# define $result_dir {{{
# Donguk : by default, result_deir = PWD
################################################################################

my $result_dir ;

if ($opt{result_dir} ne "") { $result_dir = $opt{result_dir} ; }
else { if (exists $ENV{PWD}) { $result_dir = $ENV{PWD} ; } }
print "(Debug) define result_dir = $result_dir\n";

#############################################################################}}}
# define $sims_config {{{
################################################################################

GetOptions (\%opt, 'sys=s') ;
if ($opt{sys} ne "") {
    push (@ARGV, "-sys=$opt{sys}"); # Restore argv
}
my $sims_config ;

if ($opt{sims_config} ne "") { 
    $sims_config = $opt{sims_config} ; 
} elsif ($opt{sys} ne "" && -r "$dv_root/$proj_vars{sims_config}/$opt{sys}.config") {
    $sims_config = "$dv_root/$proj_vars{sims_config}/$opt{sys}.config";
} else { 
    	$sims_config = "$dv_root/$proj_vars{sims_config}/sims.config" ; 
}
print "(Debug) define sims_config = $sims_config\n";

#############################################################################}}}
# define $model_dir {{{
################################################################################

my $model_dir ;

if ($opt{model_dir} ne "") { $model_dir = $opt{model_dir} ; }
elsif (defined $ENV{MODEL_DIR}) { $model_dir = $ENV{MODEL_DIR}; }
else { die ("DIE. could not initialize model_dir") ; }

$ENV{MODEL_DIR} = $model_dir ;
print "(Debug) define model_dir = $model_dir\n";

#############################################################################}}}
# define $diaglist {{{
################################################################################

my $diaglist ;
if ($opt{diaglist} ne "")
{
  $diaglist = $opt{diaglist} ;

  if (!($diaglist =~ /^\//))
  {
    $diaglist = "$ENV{PWD}/$diaglist" ;
  }
}
elsif ($opt{sys} ne "" && 
       -r "$dv_root/$proj_vars{diaglist}/$opt{sys}.diaglist") {
  $diaglist = "$dv_root/$proj_vars{diaglist}/$opt{sys}.diaglist" ;
}
else
{
  $diaglist = "$dv_root/$proj_vars{diaglist}/master_diaglist" ;
}
print "(Debug) define diaglist = $diaglist\n";

#############################################################################}}}
# get diag options from diaglist {{{
################################################################################

if (($#{$opt{group}} != -1) and ($opt{alias} ne ""))
{
  print "(Debug) get diag options from $diaglist\n";
  &get_opt_from_diaglist () ;
}


#############################################################################}}}
# Regular run, get opt{sys} {{{
################################################################################

GetOptions (\%opt,
            'sys=s',
           ) ;

#############################################################################}}}
# Header and Logs {{{
################################################################################

&redirect () ;
print "(Debug) redirect() complete\n";
&print_header () ;
print "(Debug) print_header complete\n";

#############################################################################}}}
# if this is not a regression a sys must be defined {{{
################################################################################

die ("DIE. -sys argument not defined") if ($opt{sys} eq "") ;
&parse_args ($opt{sys}, 1) ;
print "$prg: group_name = $opt{group_name}\n" if ($opt{regress}) ;
print "$prg: regress_date = $opt{regress_date}\n" if ($opt{regress}) ;
print "$prg: regress_time = $opt{regress_time}\n" if ($opt{regress}) ;

#############################################################################}}}
# first check that the model and model_rel_name are defined {{{
################################################################################

my $model_path ; my $model_def_name = "rel-0.1" ;

if ($opt{model_rel_name} eq "") { $model_path = "$model_dir/$opt{sys}/$model_def_name" ; }
else { $model_path = "$model_dir/$opt{sys}/$opt{model_rel_name}" ; }

if ( $opt{vera_build} ) { $opt{vera_clean}=1; }
if ( $opt{vcs_build} ) { $opt{vcs_clean}=1; }
elsif ( $opt{ncv_build} ) { $opt{ncv_clean}=1; }

if ( $opt{vcs_run} or $opt{ncv_run} ) 
{ # do not build by default
    $opt{build}=0; 
    $opt{vera_build}=0; $opt{vera_clean}=0;
    if ($opt{sim} eq 'ncv') 
    {
        $opt{ncv_build}=0; $opt{ncv_clean}=0; 
	}
    elsif ($opt{sim} eq 'vcs') 
    { 
	$opt{vcs_build}=0; $opt{vcs_clean}=0; 
	}
}
if ( $opt{build} ) 
{
    $opt{vera_clean}=1;
if ( ($opt{sys} =~ m/fpga/)) {   ###vera not required for fpga models
     $opt{vera_build}=0;
     } 
else {
    $opt{vera_build}=1;  
     }
if ($opt{sim} eq 'ncv') 
{
    $opt{ncv_clean}=1;
    $opt{ncv_build}=1;
}
elsif ($opt{sim} eq 'vcs') 
{
    $opt{vcs_clean}=1;
    $opt{vcs_build}=1;
} 
}
print "(debug) model_path = $model_path\n";
print "(debug) build = $opt{build}\n";
print "(debug) vera_build = $opt{vera_build}\n";
print "(debug) vera_clean = $opt{vera_clean}\n";
print "(debug) vcs_build = $opt{vcs_build}\n";
print "(debug) vcs_clean = $opt{vcs_clean}\n";
print "(debug) vcs_run = $opt{vcs_run}\n";

#	push @{$opt{config_cpp_args}},"-DT2";
	my $uname=`uname -s`;chomp $uname;
	if ($uname eq "Linux") { push @{$opt{config_cpp_args}},"-DLINUX"; }

    if ( ($opt{sys} eq "fc1") or ($opt{sys} eq "fc8") ) 
    {
#    if ( !(grep {$_ eq '-DFC_NO_NIU_T2'} @{$opt{config_cpp_args}}) ) 
#    {
#        if ($uname ne "SunOS") {
#        print "$prg: >>>>> The option you are trying to run is NOT presently supported!\n"; exit(0);
#        }
#    }
    }
print "(debug) definition of model_path/vcs_build/vera_build complete...\n";

#############################################################################}}}
# run a regression instead of a single diag {{{
################################################################################

if (scalar @{$opt{group}} != 0)
{
  print "(debug) run regress  becuase group is defined ($opt{group})\n";
  $opt{report}=1; $opt{gzip}=0;
  &regress();
  exit (0) ;
}

#############################################################################}}}
# create the model area if necessary {{{
################################################################################

&create_model_path () if (($opt{zeroIn_build}) or
                          ($opt{zeroInSearch_build}) or
                          ($opt{zeroIn_checklist}) or
                          ($opt{sunv_run}) or
                          ($opt{vera_build}) or
                          ($opt{vcs_build}) or 
                          ($opt{ncv_build}) or
                          ($opt{hcs_build}) or
                          ($opt{axis_build})or
                          ($opt{palladium_build})) ;

#############################################################################}}}
# run sunv {{{
################################################################################

&sunv_run () if ($opt{sunv_run}) ;
print "(debug) sunv_run() passed...\n";

#############################################################################}}}
# build the vera/ntb testbench {{{
################################################################################

&vera_build () if ((   (($opt{vcs_build}) and ($opt{vera_build} == -1)) or
                    (($opt{ncv_build}) and ($opt{vera_build} == -1))  or
                    ($opt{vera_build} == 1)) and
                   (! $opt{dftvert})) ;

print "(debug) vera_build() passed...\n";
##&vera_build () if (($opt{vera_build} == 1) and
 ##                  (! $opt{dftvert})) ;

#############################################################################}}}
# do some pre building stuff - generate flist and graft model {{{
################################################################################

&pre_build () if (($opt{vlint_run}) or ($opt{vcs_build}) or ($opt{ncv_build}) or ($opt{hcs_build})
                  or ($opt{verix_run}) or $opt{axis_build} or
                  $opt{palladium_build}) ;
print "(debug) prebuild()(config.v flist) passed...\n";

#############################################################################}}}
# compile zeroIn {{{
################################################################################

&zeroIn_build () if (($opt {zeroIn_build}) or ($opt {zeroInSearch_build}) or ($opt {zeroIn_checklist})) ;
print "(debug) zeroIn_build() passed...\n";

#############################################################################}}}
# run vlint on the model {{{
################################################################################

&vlint_run () if ($opt{vlint_run}) ;
print "(debug) vlint_run() passed...\n";

#############################################################################}}}
# run verix on the model {{{
################################################################################

&verix_run () if ($opt{verix_run}) ;
print "(debug) verix_run() passed...\n";

#############################################################################}}}
# build the ncverilog/vcs model {{{
################################################################################

&vcs_build () if ($opt{vcs_build});
print "(debug) vcs_build() passed...\n";

&ncv_build () if ($opt{ncv_build});


#############################################################################}}}
# assemble .s diag {{{
################################################################################

print "(debug) asm_diag_name($opt{asm_diag_name}) ..\n";
&assemble_diag () if ($opt{asm_diag_name} ne "") ;
print "(debug) assemble_diag() passed...\n";

#############################################################################}}}
# assemble .tap diag {{{
################################################################################

&assemble_tap_diag () if ($opt{tap_diag_name} ne "") ;
print "(debug) assemble_tap_diag() passed...\n";

#############################################################################}}}
# copy .image diag {{{
################################################################################

&copy_image () if ($opt{image_diag_name} ne "") ;
print "(debug) copy_image() passed...\n";

#############################################################################}}}
# copy efuse image {{{
################################################################################

&copy_efuse_image () if ($opt{efuse_image_name} ne "" and 
                        ($opt{vcs_run} or
                        $opt{ncv_run} or $opt{hcs_run} or $opt{axis_run} or
                        $opt{palladium_run})) ;
print "(debug) copy_efuse_image() passed...\n";

#############################################################################}}}
# generate an efuse image {{{
################################################################################

&generate_efuse_image () if ($opt{efc}) ;
print "(debug) generate_efuse_image() passed...\n";

#############################################################################}}}
# partition test mem image for fpga model memory configuration  {{{
################################################################################

if ( ($opt{sys} =~ m/fpga/)) 
{

my $uname=`uname -s`;chomp $uname;
 if ($uname eq "Linux") { 
  system("$dv_root/tools/fpga/Linux/partition_mem") ;
 }
 else {
  system("$dv_root/tools/fpga/partition_mem") ;
 }
}
print "(debug) fpga memory configuration passed...\n";

#############################################################################}}}
# copy .tpt diag {{{
################################################################################

&copy_tpt () if ($opt{tpt_diag_name} ne "") ;

print "(debug) copy_tpt() passed...\n";

#############################################################################}}}
# compile .vr config {{{
################################################################################

&compile_vera_config () if ($opt{vera_config_name} ne "") ;
print "(debug) compile_vera_config() ($opt{vera_config_name}) passed...\n";

#############################################################################}}}
# compile .vr diag when -dftvert is also present {{{
################################################################################

&compile_dftvert_diag () if (($opt{vera_diag_name} ne "") and
                             ($opt{dftvert})) ;
print "(debug) compile_dftvert_diag() ($opt{vera_diag_name} $opt{dftvert}) passed...\n";

#############################################################################}}}
# compile .vr diag {{{
################################################################################


&compile_vera_diag () if (($opt{vera_diag_name} ne "" or 
                           $opt{vera_dummy_diag} ne "") and 
                          !$opt{dftvert}) ;
print "(debug) compile_vera_diag() ($opt{vera_diag_name} $opt{vera_dummy_diag} $opt{dftvert}) passed...\n";

#############################################################################}}}
# generate an sjm diag {{{
################################################################################

&generate_sjm_diag () if ($opt{sjm} or $opt{tomatillo} or ($opt{sjm_diag_name} ne "")) ;
print "(debug) generate_sjm_diag() ($opt{sjm} $opt{tomatillo} $opt{sjm_diag_name}) passed...\n";

#############################################################################}}}
# generate a pci diag {{{
################################################################################

&generate_pci_diag () if ($opt{pci} or $opt{tomatillo} or ($opt{pci_diag_name} ne "")) ;
print "(debug) generate_pci_diag() ($opt{pci} $opt{tomatillo} $opt{pci_diag_name}) passed...\n";

#############################################################################}}}
# launch sas/simics {{{
################################################################################

&sas_run () if ($opt{sas}) ;
print "(debug) sas_run() ($opt{sas}) passed...\n";

#############################################################################}}}
# launch tcl_tap {{{
################################################################################

if ( $opt{tcl_tap} and  $opt{vcs_run} ){ &tcl_tap_run (); }
print "(debug) tcl_tap_run() ($opt{tcl_tap} $opt{vcs_run}) passed...\n";
    

#############################################################################}}}
# dram specific stuff {{{
################################################################################

if ($opt{vcs_run} or $opt{ncv_run} or $opt{hcs_run} or $opt{axis_run} or $opt{palladium_run})
{
  my $file;
  print "(debug) DRAM specific Stuff  use_denalirc = $opt{use_denalirc}...\n";
  if ($opt{use_denalirc} eq "") {
    $file = "$opt{env_base}/.denalirc" ;
  } else {
    $file = "$opt{use_denalirc}" ;
     die ("DIE. could not find \"$file\" for -use_denalirc") if (! -f $file);
  }
  print "(debug) DRAM specific Stuff  denalirc file = $file\n";

  if (-f $file) {
    `cp $file .denalirc` ;
        die ("DIE. could not copy $file to run area\n") if ($?) ;
    `chmod +w .denalirc` ;
        die ("DIE. could not change permission of .denalirc\n") if ($?) ;
     print "(debug) DRAM specific Stuff \"cp $file .denalirc chmod +w .denalirc\" \n";
  }
}

if (($opt{sys} eq "dram") and ($opt{vcs_run} or $opt{ncv_run} or $opt{hcs_run} or $opt{axis_run} or $opt{palladium_run}))
{

  print("$prg: Add this to your config file instead: -pre_process_cmd=\"ln -s \$DV_ROOT/verif/env/whatever/mem.data .\"\n");
  print("$prg: Remove the code in sims that does the bench specific copy!\n");

  my @files = ("dram_config.doc", "mem.data", "mem1.data", "mem2.data") ;

  foreach my $file (@files)
  {
    die ("DIE. $opt{env_base}/$file not found") if (!(-f "$opt{env_base}/$file")) ;
    `cp $opt{env_base}/$file .` ;
    die ("DIE. could not copy $file to $ENV{PWD}\n") if ($?) ;
    `chmod +w $file` ;
    die ("DIE. could not change permission of $file\n") if ($?) ;
  }
}
print "(debug) DRAM specific Stuff  passed...\n";

#############################################################################}}}
# launch ncsim/simv {{{
################################################################################

&vcs_run () if ($opt{vcs_run}) ;
print "(debug) vcs_run() ($opt{vcs_run} passed...\n";

&ncv_run () if ($opt{ncv_run}) ;


#############################################################################}}}
# run diag.pl if present {{{
################################################################################

if (    -e "diag.pl" and
	( $opt{vcs_run} or $opt{ncv_run} or $opt{hcs_run} or $opt{sas} or $opt{axis_run} or
      $opt{palladium_run}) and $opt{run_diag_pl}
   )
{
  my $diag_pl_args = join (" ", @{$opt{diag_pl_args}}) ;

  print "$prg: executing diag.pl $diag_pl_args\n";

    my $waitstatus = call_program("perl diag.pl $diag_pl_args","diag_pl.log");
    print ("$prg: Warning diag.pl run exited with error\n") if ($waitstatus) ;
}

#############################################################################}}}
# post process the output {{{
################################################################################

  print "$prg: stop_time ";
  system ("date") ;

exit (0);

#############################################################################}}}
# run simulation in dream {{{
################################################################################

sub run_indrm
{
  my $argv_ref = shift ;
  my $drm_opt_ref = shift ;
  my @argv_copy = @ARGV ;
  # Save global options because they get modified by drm_opt ..
  my %opt_copy = %{&deep_copy(\%opt)} ;

  unshift (@ARGV, @{$drm_opt_ref}) ;

  GetOptions (\%opt,
              'auditr_args=s@',
	      'clearcase!',
              'drmlog!',
              'drmlog_name=s',
              'drmcommand_name=s',
              'drmconstraints_name=s',
              'drm_constraints_file=s',
              'drm_cpufreq=s',
              'drm_disk=s',
              'drm_freeram=s',
              'drm_freeswap=s',
              'drm_freeprocessor=s',
              'drm_license=s',
              'drm_on!',
              'drm_osver=s',
              'drm_project=s',
              'drm_priority=s',
              'drm_type=s',
              'drm_totprocessor=s',
              'drm_window=s',
              'group=s',
              'use_auditr!',
              'sim_q_command=s',
             ) ;

  @ARGV = @argv_copy ;

  if ( $opt{clearcase} ) {
    if ($opt{cc_dv_root} ne "") { $cc_dv_root = $opt{cc_dv_root} ; }
    elsif (defined $ENV{CC_DV_ROOT}) { $cc_dv_root = $ENV{CC_DV_ROOT} ; }
    elsif ($opt{dv_root} ne "") { $cc_dv_root = $opt{dv_root}; }
    elsif (defined $proj_vars{cc_dv_root}) {
	    $cc_dv_root = $proj_vars{cc_dv_root}; }
    else { die ("DIE. could not initialize cc_dv_root") ; }
    printf("sims: cc_dv_root is $cc_dv_root\n");
    printf("sims: set to work with ClearCase view: $CC_VIEW_NAME\n");
  }
  
  # create a dream constraint file

  if ($opt{drm_constraints_file} eq "") {

    # Add tharas license requirements
    if ($opt{hcs_build} || $opt{hcs_run}) {
      $opt{drm_license} =~ s/\]/,hcs=$opt{hcs_drm_tokens}]/;
      $opt{drm_type} = 'tharas' ;
    }

    if ($opt{vcs_use_ntb}) {
        $opt{drm_license} =~ s/,*vera=1//o;   # No Vera license required ..
    }

    open (DRMCONST, "> $opt{drmconstraints_name}") or die ("DIE. Could not open DReAM constraints file") ;
    print DRMCONST "project=$opt{drm_project}\n" if ($opt{drm_project} ne "") ;
    print DRMCONST "type=$opt{drm_type}\n" if ($opt{drm_type} ne "") ;
    print DRMCONST "cpufreq=$opt{drm_cpufreq}\n" if ($opt{drm_cpufreq} ne "") ;
    print DRMCONST "disk=$opt{drm_disk}\n" if ($opt{drm_disk} ne "") ;
    print DRMCONST "freeram=$opt{drm_freeram}\n" if ($opt{drm_freeram} ne "") ;
    print DRMCONST "freeswap=$opt{drm_freeswap}\n" if ($opt{drm_freeswap} ne "") ;
    print DRMCONST "freeprocessor=$opt{drm_freeprocessor}\n" if ($opt{drm_freeprocessor} ne "") ;
    print DRMCONST "totprocessor=$opt{drm_totprocessor}\n" if ($opt{drm_totprocessor} ne "") ;
    print DRMCONST "priority=$opt{drm_priority}\n" if ($opt{drm_priority} ne "") ;
    # print DRMCONST "priority=-900\n" if ($opt{group} ne "") ;
    print DRMCONST "license=$opt{drm_license}\n" if ($opt{drm_license} ne "") ;
    print DRMCONST "window=$opt{drm_window}\n" if ($opt{drm_window} ne "") ;
    print DRMCONST "osver=$opt{drm_osver}\n" if ($opt{drm_osver} ne "") ;
    close (DRMCONST) ;

  } else {
    if (!($opt{drm_constraints_file} =~ /^\//)) {
      $opt{drm_constraints_file} = "$ENV{PWD}/$opt{drm_constraints_file}" ;
    }
    die ("DIE. Could not find DREAM constraints file $opt{drm_constraints_file}") if (! -r $opt{drm_constraints_file}) ;
    $opt{drmconstraints_name} = $opt{drm_constraints_file};
  }
  # create the dream command

  `rm -rf $opt{drmcommand_name}` ;

  open (DRMCMD, "> $opt{drmcommand_name}") or die ("DIE. Could not open DReAM command file") ;
  
  if ( $opt{clearcase} ) {
    print DRMCMD "TRE_SEARCH='$ENV{TRE_SEARCH}';export TRE_SEARCH; ";
  }
  print DRMCMD "auditr \\\n" if ($opt{use_auditr}) ;
  print DRMCMD (join (" \\\n", @{$opt{auditr_args}})) if ($opt{use_auditr}) ;
  print DRMCMD " \\\n" if ($opt{use_auditr}) ;

  if ( $opt{clearcase} ) {
    print DRMCMD "$prg " ;
  }
  else {
    print DRMCMD "$prg \\\n" ;
  }

  foreach my $x (@{$argv_ref})
  {
    next if (($x =~ /-indrm/) or ($x =~ /-interactive/));
    ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/)); #"
    ($x =~ s/"/\\"/go) if ($opt{use_auditr}); # Escape quote if using auditr

    if ( $opt{clearcase} ) {
      print DRMCMD "$x " ;
    }
    else {
      print DRMCMD "$x \\\n" ;
    }
  }
  close (DRMCMD) ;

  `chmod 0777 $opt{drmcommand_name}` ;

  # submit to dream

  my $cmd ;

  if ($opt{drm_on})
  {
    $cmd = "drmon " ;
  }
  else
  {
    if ( $opt{clearcase} ) {
      $cmd = "cd ; drmsubmit " ;
    }
    else {
      $cmd = "drmsubmit " ;
    }
  } # else !drm_on

  $cmd .= "-m -i " if ($opt{interactive}) ;


  if (!($opt{drmconstraints_name} =~ /^\//)) {
    $opt{drmconstraints_name} = "$ENV{PWD}/$opt{drmconstraints_name}" ;
  }
  if ( $opt{clearcase} ) {
    $cmd .= " -f $opt{drmconstraints_name} ";
    $cmd .= " $CLEARTOOL setview -exec \'source  ${PROJ_CSHRC};";
    $cmd .= " setenv DV_ROOT $cc_dv_root; cd $ENV{PWD}; ";
    # Don't know how to use constraints file
    $cmd .= " $ENV{PWD}/$opt{drmcommand_name} " ;
    $cmd .= "\' $CC_VIEW_NAME";
    print "sims: $cmd \n";
  }
  else {
    $cmd .= "-f $opt{drmconstraints_name} $ENV{PWD}/$opt{drmcommand_name} " ;
    $cmd .= " \'>&\' $ENV{PWD}/$opt{drmlog_name} " if ($opt{drmlog} and (!$opt {interactive})) ;
    print "sims: $cmd \n";
  }

  system ($cmd)  ;

  # Restore global options ..
  %opt = %opt_copy ;
}

#############################################################################}}}
# update sims cycle database {{{
################################################################################

sub update_db
{
  my $cycles = shift ;
  my $start = shift ;
  my $stop = shift ;
  my $status = shift ;
  chomp ($start) ;
  chomp ($stop) ;
  my $regress_date = sprintf "%4.4d_%2.2d_%2.2d", 1900 + (localtime) [5], 1 + (localtime) [4], (localtime) [3] ;

  my $db_dir = undef ;

  foreach my $x (@{$proj_vars{sims_db}})
  {
    $db_dir = $x if (-d $x) ;
  }

  return if (!defined $db_dir) ;

  my $dbfile = "$db_dir/$regress_date";

  open (DB, ">> $dbfile") or return ;
  flock (DB, LOCK_EX) ;
  seek (DB, 0, 2) ;
  print DB "$opt{sys}|$cycles|$start|$stop|$status\n" ;
  flock (DB, LOCK_UN) ;
  close (DB) ;
  system("chmod -f go+rw $dbfile") if (-o $dbfile);
}

#############################################################################}}}
# redirect all output to tee {{{
################################################################################

sub redirect
{
  my $logfile = $opt{simslog_name} ;

  if ($opt{regress})
  {
    $logfile = "$launch_dir/$opt{simslog_name}" ;
  }

  if ($opt{simslog})
  {
    tee_stdout ($logfile) ;
    open(STDERR, ">&=STDOUT") or die "DIE. Could not make stderr an alias to stdout: $!";
  }
}

#############################################################################}}}
# tee stdout to log file {{{
################################################################################

sub tee_stdout {
  my $file = shift;
  die "DIE. tee_stdout() called without a filename" unless defined $file;
  return if my $pid = open(STDOUT, '|-');
  die "DIE. Cannot fork when trying to tee stdout: $!" unless defined $pid;

  open(SIMSLOG, ">$file") or die "DIE.  Could not open $file for writing: $!";
  my $old_fh = select SIMSLOG;
  $| = 1;
  select $old_fh;
  $| = 1;
  while(<STDIN>) {
    print;
    print SIMSLOG;
  }
  exit(0);
}

#############################################################################}}}
# print out a header when sims starts {{{
################################################################################

sub print_header
{
  # print "$prg @argv_copy\n";
  open (SIMS_HISTORY, ">> history.sims") ;
  my $date = `date` ;
  chomp ($date) ;

  print "$prg ";
  print SIMS_HISTORY "$date $prg ";

  foreach my $x (@argv_copy)
  {
    ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/)) ;
    print "$x " ;    
    print SIMS_HISTORY "$x " ;    
  }

  print "\n" ;
  print SIMS_HISTORY "\n" ;

  chomp(my $hostname = `hostname`);

  print "$prg: #####################################################################\n";
  print "$prg: \t   SIMS 1.272 running for OpenSparc T2 \n"; 
  print "$prg: #####################################################################\n";

  print "$prg: start_time $date\n";
  print "$prg: running on $hostname \n";
  print "$prg: uname is ";
  system ("uname -a") ;
  print "$prg: version $version (pid=$pid)\n";
  print "$prg: dv_root $dv_root\n";
  print "$prg: cc_dv_root $cc_dv_root\n" if $opt{clearcase};
  print "$prg: model_dir $model_dir\n";
  print "$prg: tre_search $ENV{TRE_SEARCH}\n" ;
  print "$prg: Frozen tre_search $orig_tre_search\n" if (($#{$opt{group}} != -1) and ($opt{alias} eq "")) ;
}


#############################################################################}}}
# regress subroutine {{{
# 1. create a regression test directory 
#    regression running dir : $result_dir/$opt{sys}_$opt{sim}_regression_${regress_date}__${cpp_args}_${count}
# 2. model_path  = model_dir/$opt{sys}/$opt{model_rel_name}  
# 3. place master_diaglist,tre_files under model_path
################################################################################

sub regress
{
  # figure out the name of the regression
  print "$prg: Starting regression...\n";

  my $regress_date = sprintf "%4.4d_%2.2d_%2.2d", 1900 + (localtime) [5], 1 + (localtime) [4], (localtime) [3] ;
  my $regress_time = sprintf "%2.2d_%2.2d_%2.2d", (localtime) [2], (localtime) [1], (localtime) [0] ;
  my $a='';
  my @a=sort grep{!/^T2$/}map{substr $_,2}grep{/^-D/}@{$opt{config_cpp_args}};
  if (scalar @a != 0) { $a=join('__',@a); }
  my $regress_id ;
  ## get the test # for the same day ( =count).
  if ($opt{regress_id} eq "")
  {
    $regress_id = $opt{sys} . "_" . $opt{sim} . "_regression_" . $regress_date . '__' . $a;
    my $count = 0 ;
    while (-d "$result_dir/$opt{sys}_$opt{sim}_regression_${regress_date}__${a}_${count}") {
      $count++;}
    $regress_id .= "_$count" ;
  }
  else
  {
    $regress_id = $opt{regress_id} ;
  }

  # create the directory where regression will be run

  system ("mkdir -p $result_dir/$regress_id") ;
  print "(debug) mkdir -p $result_dir/$regress_id \n";
  die  ("DIE. Could not create result area for regression") if ($?) ;
   
  chdir ("$result_dir/$regress_id") or die ("DIE. Could not change directory into $result_dir/$regress_id") ;
  print "(debug) cd $result_dir/$regress_id \n";

  # recreate a copy of all the tre files in this directory
  my $tre_search = &freeze_tre( "$result_dir/$regress_id" );
  $ENV{TRE_SEARCH} = $tre_search if $tre_search ne "";

  @argv_copy = @ARGV ;

  # Pass the config_cpp_args through ..
  foreach my $x ( @{$opt{config_cpp_args}} ) {
    print "(debug) config_cpp_args=$x added to argv_copy\n";
    push(@argv_copy, "-config_cpp_args $x"); 
  }

  foreach my $x (@argv_copy)
  {
    if ($x =~ /-fast_boot/) {
      push (@{$opt{diaglist_cpp_args}}, "-DFAST_BOOT") ;
      push (@{$opt{config_cpp_args}}, "-DFAST_BOOT") ;
      print "(debug) config_cpp_args= -DFAST_BOOT added to argv_copy\n";
      push(@argv_copy, "-config_cpp_args -DFAST_BOOT");
    }
  }

    my $model_rel_name;
    my $count_diags=0;
    my $exe_dir;
  foreach my $gname (@{$opt{group}})
  {
    # put the pre-processed diaglist in here

    die ("DIE. Diag list $diaglist not found") if (! -f $diaglist) ;

    my $diagcppargs = join(' ', @{$opt{diaglist_cpp_args}});
    print "$prg: processing diaglist $diaglist (diag_cppargs = $diagcppargs) ..\n" ;
    print "(debug) $result_dir/$regress_id/master_diaglist.$gname has been created ..\n" ;
    system ("bw_cpp -B $diagcppargs -undef -I$dv_root/verif/diag $diaglist > $result_dir/$regress_id/master_diaglist.$gname") ;
    die  ("DIE. Could not pre-process the master_diaglist") if ($?) ;

    # open the diaglist and look for the group in it

    my $diagList = DiagList->new ("$result_dir/$regress_id/master_diaglist.$gname", $opt{null}, $gname) ;

    # gname = cmp1_mini_T2
    my $group = $diagList->find_group ($gname) ;
    print "(debug) find_group $gname = $group\n";

    die ("DIE. Group name $gname not found in diag list $diaglist") if (! defined $group) ;
    print "$prg: processing group $gname\n";

    foreach my $tag ($group->build_tags ())
    {
      my $buildargs = $diagList->build_args ($tag) ;
      # ex) tag = CMP1_mini_T2 
      print "(debug) tag = $tag of master_diaglist.$gname in group $gname\n";
      print "(debug) buildargs = $buildargs\n";

      # read the config file for this sys
      my @argv_config ;
      print "(debug) read config file and extract $opt{sys} portion and save them in argv_config\n";
      &get_config ($opt{sys}, \@argv_config) ;

      # extract the dream options from the config file
      my @dream_options  = () ;

      foreach my $x (@argv_config)
      {
        push (@dream_options, $x) if ($x =~ /\-drm\_/) ;  
        push (@dream_options, $x) if ($x =~ /\-vcs_use_ntb/) ;
      }

      # figure out the name of the model release
        if ($opt{build} ) # do a build
        {
      if ($opt{model_rel_name} eq "")  
      {
        $model_rel_name = sprintf "%4.4d_%2.2d_%2.2d", 1900 + (localtime) [5], 1 + (localtime) [4], (localtime) [3] ;
        open (MODEL_LOCK, "> lock") or die "DIE. Could not lock model" ;
        flock (MODEL_LOCK, LOCK_EX) ;
        my $count = 0 ;
        while (-d "$model_dir/$opt{sys}/$opt{sim}_build_${model_rel_name}_${count}") {$count++;}
        $model_rel_name = "$opt{sim}_build_${model_rel_name}_${count}" ;
        system ("mkdir -p $model_dir/$opt{sys}/$model_rel_name") ;
        print "(debug) mkdir -p $model_dir/$opt{sys}/$model_rel_name\n";
        die "DIE. Could not create model_rel_name for regression" if ($?) ;
        flock (MODEL_LOCK, LOCK_UN) ;
        close (MODEL_LOCK) ;
      }
      else { $model_rel_name = $opt{model_rel_name} ; } # use user-supplied name
      }
      else # do not do a build
      {
      if ($opt{model_rel_name} eq "")
      {
        $model_rel_name = $model_def_name ; # use the model's default name 
      }
      else
      {
        $model_rel_name = $opt{model_rel_name} ; # use user-supplied name
      }
      }

      print "$prg: DV_ROOT is $ENV{DV_ROOT}\n";
      print "$prg: MODEL_DIR is $ENV{MODEL_DIR}\n";
      print "$prg: ",'#' x 50,"\n";

      print "(debug) model_rel_name $model_rel_name\n";

      print "(debug) sim = $opt{sim}\n";

if ($opt{sim} eq 'vcs') { $opt{cache}=0; }
else { $opt{cache}=1; }
      # call sims to build this model
      my $cmd = "$prg " ;
      $cmd .= "-sim=$opt{sim} " ;
      $cmd .= "-nobuild " if (!$opt{build}) ;
      $cmd .= "-vcs_build "  if( $opt{vcs_build} ) ;
      $cmd .= "-ncv_build "  if( $opt{ncv_build} ) ;
      $cmd .= "-vera_build " if( $opt{vera_build} ) ;
      $cmd .= "$buildargs "  if ($opt{build}) ;
      $cmd .= "-model_rel_name=$model_rel_name ";
      $cmd .= "-nouse_cdms_iver " ;
      $cmd .= "-sims_config=$sims_config " ;
	  $cmd .= "-novcs_use_fsdb " if (!$opt{vcs_use_fsdb});
	  $cmd .= "-novcs_use_vcsd " if (!$opt{vcs_use_vcsd});
	$cmd .= "-parallel " if ($opt{sim_q_command} ne "/bin/sh") ;
    $cmd .= "-nocache " if (!$opt{cache}) ;
    $cmd .= "-vcs_full64 " if ($opt{vcs_full64}) ;
    # if ($opt{build}) {
    # if (!$opt{cache}) { print "$prg: >>>>> will NOT cache your build !\n"; }
    # else { print "$prg: >>>>> will cache your build !\n"; }
    # }
    print "(debug) intermediate sim cmd = $cmd\n";
    foreach my $x (@{$opt{vcs_build_args}}) {
	  $x =~ s/^"(.*?)"$/$1/ ;
	  if ($x=~m/^-f flist$/) { $x=~s/flist/$model_path\/flist/; }
	  if ($x=~m/^ \+vc (vera\/\w+\.(o|a))$/) { my $y = " +vc " . $model_path . "/" . $1; $x = $y; }
	  $cmd .= "$x " ;
          print "(debug)vcs_build_args $cmd \n";
	}

    print "(debug) intermediate sim cmd = $cmd\n";

    foreach my $x (@argv_copy)
      {
        ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/)); #"
        $cmd .= " $x " ;
          print "(debug)argv_copy element $x is added to cmd \n";
      }
    print "(debug) intermediate sim cmd = $cmd\n";

        if ( $opt{vcs_build} or $opt{ncv_build} ) 
        {
            print "$prg: building regression model\n";

        print "(debug) final sim cmd is running for vcs_build!! (ST_REG0) $cmd\n";
        system ($cmd) ; my $build_stat = $?;
        print "(debug) final sim cmd for vcs_build complete and returned!! (ST_REG1) $cmd\n";

        `cp -f $model_dir/$opt{sys}/$model_rel_name/diff_rel.log $result_dir/$regress_id/diff_rel_$tag.log` if (-f "$model_dir/$opt{sys}/$model_rel_name/diff_rel.log") ;

        die  ("DIE. Could not build model for regression") if ($build_stat) ;

          my $dir = $model_dir."/".$opt{sys}."/".$model_rel_name; my @a=() ;
          opendir D, "$dir" or die ( "cannot open build dir $dir for reading!\n");
            if ( $opt{vcs_build} ) {
                @a =grep {/simv/} readdir D ; closedir D;
		if (scalar @a == 0) { print "$prg: no VCS binary found inside $dir ! \n"; exit (0) ; }
        } elsif ( $opt{ncv_build} ) {
                    @a =grep {/INCA_libs/} readdir D ;  closedir D;
                    if ( scalar @a != 0 ) { 
                        opendir D, "$dir/INCA_libs/worklib" or die ( "cannot open dir for reading!\n");
                        my @b = grep {/^inca.*pak$/}  readdir D ; closedir D;
			if ( scalar @b == 0 ) { print "$prg: no NC-Verilog snapshot found inside $dir ! \n"; exit (0) ; }
                    }
                    else { print "$prg: no NC-Verilog snapshot found inside $dir ! \n"; exit (0) ; }
        }

# build is finished, now time for runs....
        print "$prg: finished building the model for simulation, will start regression runs now.....\n";
            $exe_dir=$dir;
    if ($opt{sim_q_command} eq "/bin/sh") 
    {
        if ($opt{cache})
        {
            if ($opt{sim} eq 'vcs' )  {
            open F, "$dir/compile.log" or die ("DIE. could not open $dir/compile.log");
            my @l=<F>; close F; my @ll=grep{/^OpenSPARC_T2 compile dir is: /}@l; chomp @ll;
            my $s; ($s=$ll[-1])=~s/^OpenSPARC_T2 compile dir is: (.*)/$1/;
            $exe_dir=$s;
            }
            elsif ($opt{sim} eq 'ncv' )  {
            open F, "$dir/ncelab.log" or die ("DIE. could not open $dir/ncelab.log");
            my @l=<F>; close F; my @ll=grep{/^OpenSPARC_T2 compile dir is: /}@l; chomp @ll;
            my $s; ($s=$ll[-1])=~s/^OpenSPARC_T2 compile dir is: (.*)/$1/;
            $exe_dir=$s;
            }
        }
    }
      }
      else 
      {
          print "$prg: will now run regression using a pre-built simulation model...\n";
          my $dir = $model_dir."/".$opt{sys}."/".$model_rel_name ; my @a=() ;
          opendir D, "$dir" or die ( " cannot open build dir $dir for reading!\n");
            if ($opt{sim} eq 'vcs' ) 
                { 
                @a =grep {/simv/} readdir D ; closedir D;
                if ( scalar @a != 0 ) { print "$prg: using the VCS model built inside $dir/simv \n"; }
                else { print "$prg: no VCS binary found inside $dir ! \n"; exit (0) ; }
                }
            elsif ($opt{sim} eq 'ncv' ) 
                { 
                    @a =grep {/INCA_libs/} readdir D ;  closedir D;
                    if ( scalar @a != 0 ) { 
                        opendir D, "$dir/INCA_libs/worklib" or die ( " cannot open dir for reading!\n");
                        my @b = grep {/^inca.*pak$/}  readdir D ; closedir D;
                        print "$prg: using the NC-Verilog model built inside $dir/INCA_libs/worklib/$b[-1] \n"; 
                    }
                    else { print "$prg: no NC-Verilog snapshot found inside $dir ! \n"; exit (0) ; }
                }
                $exe_dir=$dir;
    
    if ($opt{sim_q_command} eq "/bin/sh") 
    {
        if ($opt{cache}) 
        {
    my $cache_dir_prefix = $ENV{TEMPDIR} ;
    if ( !( -d $ENV{TEMPDIR} ) ) { system ("mkdir -p $ENV{TEMPDIR}") ; }
    die ( "DIE. Could not access your temporary cache directory. \n") if ( !( -d $ENV{TEMPDIR} ) ) ;
    my $cache_dir;
    if (-d $cache_dir_prefix ) 
    {
    opendir D, $cache_dir_prefix or die (" Could not open directory \" ${cache_dir_prefix} \" for reading!\n");
    my @d = map { $cache_dir_prefix . "/" . $_  } grep { !/^\./ && -d "$cache_dir_prefix/$_" } readdir D ; closedir D;
    
    foreach (@d) {
        if ( ( time - ( (stat $_ )->mtime ) ) > ( 60*60*$cache_clean_time ) ) {
            system ( "/bin/rm -rf $_" ) ;
        }
    }
        if ($opt{sim} eq 'vcs' )
        {
    $cache_dir = $cache_dir_prefix . "/OpenSPARC_T2___VCS___" . $opt{sys} . "___build" ;
    my $count = 0;
    while ( -d "${cache_dir}_${count}" ) { ++$count; }
    $cache_dir .= "_$count" ;
    system ("mkdir -p $cache_dir") ;
    die ("DIE. Could not create temporary cache sub-directory for VCS compilation ") if ($?) ;
      print "$prg: will now copy the simulation binary (simv) and the direct access interface directory (simv.daidir) from the original build directory to the cache. \n"; 
        system ("/bin/cp $dir/simv $cache_dir") ;
        system ("/bin/cp -rf $dir/simv.daidir $cache_dir") ;
        if (-d "$dir/simv.cm") { system ("/bin/cp -rf $dir/simv.cm $cache_dir") ; }
        if (-d "$dir/simv.vdb") { system ("/bin/cp -rf $dir/simv.vdb $cache_dir") ; }
    }
    elsif ($opt{sim} eq 'ncv' ) 
    {
    $cache_dir = $cache_dir_prefix . "/OpenSPARC_T2___NC_Verilog___" . $opt{sys} . "___build" ;
    my $count = 0;
    while ( -d "${cache_dir}_${count}" ) { ++$count; }
    $cache_dir .= "_$count" ;
    system ("mkdir -p $cache_dir") ;
    die ("DIE. Could not create temporary cache sub-directory for NC-Verilog compilation ") if ($?) ;
      print "$prg: will now copy the NC-Verilog simulation snapshot (INCA_libs) from the original build directory to the cache. \n"; 
    system ("/bin/cp -rf $dir/INCA_libs $cache_dir") ; 
    system ("/bin/cp $dir/ncsim.args $cache_dir") ;
    system ("/bin/cp $dir/cds.lib $cache_dir") ;
    system ("/bin/cp $dir/hdl.var $cache_dir") ;
    }
    }
    $exe_dir=$cache_dir;
    }
    }
    }

        $count_diags += scalar ($group->list_diags($tag)) ;
        print '=' x 100 . "\n";
        print "$prg: ----->   Total of " . scalar ($group->list_diags($tag)) . " diags to run...\n";
        print '=' x 100 . "\n";

      chdir "$result_dir/$regress_id" or die  ("DIE. Could not cd to result area for regression") ; 

      my $i=0; 
      foreach my $diagname ($group->list_diags($tag))
      {
        my $diag    = $group->find_diag($tag, $diagname) ;
        my @runargs = $diag->get_cmd_argv() ;
        my @run_dream_options = @dream_options ;
        print "(debug) diagname = $diagname\n";
        print "(debug) diag = $diag\n";
        print "(debug) runargs = @runargs\n";
        print "(debug) run_dream_options = @run_dream_options\n";

        my @argv = @argv_copy ;
        unshift (@argv, @runargs) ;
        # unshift (@argv, @dream_options) ;
  
        foreach my $x (@runargs)
        {
          push (@run_dream_options, $x) if ($x =~ /\-drm\_/) ;  
        }

        my $reg_count = 0 ;

        foreach my $x (@argv)
        {
          if ($x =~ /\-reg\_count/)
          {
            $reg_count = $x ;
            $reg_count =~ s/\-reg\_count=(.*)/$1/ ;
            $reg_count-- ;
          }
        }

        my $alias = $diag->get_full_name () ;
        print "(debug) alias = $alias\n";

        while ($reg_count >= 0)
        {
          my $dirname = "$alias:$reg_count" ;

          `rm -rf $dirname` ;
          die  ("DIE. Could not remove diag area $dirname for regression") if ($?) ;
          `mkdir $dirname` ;
          print "(debug) mkdir $dirname\n";
          die  ("DIE. Could not create diag area $dirname for regression") if ($?) ;
  
          chdir $dirname or die  ("DIE. Could not cd to diag area $dirname") ;
  
if ($opt{sim} eq 'vcs') { $opt{cache}=0; }
else { $opt{cache}=1; }
          my @cmd ;
          push (@cmd, "-sys=$opt{sys}") ;
          push (@cmd, "-model_rel_name=${model_rel_name}") ;
          push (@cmd, "-regress_id=${regress_id}") ;
          push (@cmd, "-alias=${dirname}") ;
          push (@cmd, "-dv_root=${dv_root}") ;
          push (@cmd, "-model_dir=${model_dir}") ;
          push (@cmd, "-result_dir=${result_dir}") ;
          push (@cmd, "-sims_config=${sims_config}") ;
          push (@cmd, "-group_name=$gname") ;
          push (@cmd, "-regress_date=$regress_date") ;
          push (@cmd, "-regress_time=$regress_time") ;
          if ($opt{sim} eq 'vcs')  { push (@cmd, "-vcs_run");  }
          elsif ($opt{sim} eq 'ncv') { push (@cmd, "-ncv_run") ; }
          if ($opt{clearcase}) {
            push (@cmd, "-use_iver=$result_dir/$regress_id/tre/sims.iver") ;
          } else {
            push (@cmd, "-nouse_cdms_iver") ;
          }

	my $u=`uname -s`;chomp $u;
	if ($u eq "SunOS") { push (@cmd, "-sas") ; }
	else { push (@cmd, "-nosas") ; }
          push (@cmd, @argv) ;
          push (@cmd, "-nobuild") ;
          push (@cmd, "-regress") ;
          if (!$opt{cache}) { push (@cmd, "-nocache") ; }
    # if (!$opt{cache}) { print "$prg: >>>>> will NOT cache your runs!\n"; }
    # else { print "$prg: >>>>> will cache your runs!\n"; }
	push (@cmd, "-parallel") if ($opt{sim_q_command} ne "/bin/sh") ;
    push (@cmd, "-exe_dir=${exe_dir}");
	if ($u ne "SunOS") { push (@cmd, "-nosas") ; }

            ++$i; 
            print "$prg: Run directory: ${result_dir}/${regress_id}/${dirname}     ( No. $i )\n" ;
            if ($opt{sim} eq 'ncv') { foreach (@cmd) {s/-vcs/-ncv/;} }

            if ($opt{sim_q_command} ne "/bin/sh") # submit command to DReAM
            {
		my $cmd1 = $opt{sim_q_command} . " $prg @cmd";
		# print "$prg: Run command is : $cmd1\n";
              system ($cmd1);
            }
		else # or run it locally
            {
             my $cmd1 = "$prg @cmd";
	     print "(debug) Running command: $cmd1\n";
             system ($cmd1);
            }
          $reg_count-- ;
          chdir ".." or die  ("DIE. Could not cd up to result directory") ;
        }
      }
      if ( ($opt{cache}) and ($opt{sim_q_command} eq "/bin/sh") ) {
      `/bin/rm -rf $exe_dir` ;
      }
    }
  }

  chdir "$result_dir" or die  ("DIE. Could not cd to result directory for regression report") ;
  if ($opt{report})
  {
    print "$prg: launching regreport !!!\n" ;
    print '=' x 100 . "\n" . "\t\tWill track " . $count_diags . " jobs as time progresses...\n";
    print "\t\tUsing " . ( ($opt{sim} eq 'vcs') ? "VCS" : "NC-Verilog" ) . "\n";
    print "\t\tRunning group(s): " . join (', ', @{$opt{group}}) . "\n";


    if ( $opt{vcs_build} or $opt{ncv_build} ) 
	{ print "\t\tUsing binary under: " . $model_dir."/".$opt{sys}."/".$model_rel_name . "\n"; }
	else
	{ print "\t\tUsing binary under: " . $model_dir."/".$opt{sys}."/".$opt{model_rel_name} . "\n"; }    

    if ($opt{sim} eq 'vcs') { `regreport wait_sec=300 -regress $result_dir/$regress_id/regress.log $result_dir/$regress_id` ; }
    elsif ($opt{sim} eq 'ncv') { `regreport wait_sec=300 -regress $result_dir/$regress_id/regress.log $result_dir/$regress_id -sim ncv` ; }
  }

  print "$prg: stop_time ";
  system ("date") ;
}


#############################################################################}}}
# rerun a diag from the sims.log {{{
################################################################################

sub rerun
{
  if (! -f "sims.log") {die ("DIE. Could not find original run command");}
  open (CMD, "< sims.log") or die ("DIE. Could not open sims.log") ;
  my $cmd = <CMD> ;
  close (CMD) ;

  chomp $cmd ;
  $cmd =~ s/\s+-regress_id=\S+//g ;
  $cmd =~ s/\s+-regress_date=\S+//g ;
  $cmd =~ s/\s+-regress_time=\S+//g ;
  $cmd =~ s/\s+-regress//g ;
  $cmd =~ s/\s+-result_dir=\S+//g ;
	$cmd =~ s/\s+-parallel//g ;

  my @sims_tg_seed = `grep 'using random' sims.log` ;
  my $sims_tg_seed = $sims_tg_seed[0] ;
  $sims_tg_seed =~ s/.*?(\d+)/$1/ ;
  chomp $sims_tg_seed ;
 
  if ($opt{use_sims_iver})
  {
    my @sims_iver = `grep tre_search sims.log` ;

    my $sims_iver = $sims_iver[0] ;
    $sims_iver =~ s/^.*?:\stre_search\s// ;
    chomp $sims_iver ;
    $ENV{TRE_SEARCH} = $sims_iver ;
  }

  if (!$opt{overwrite})
  {
    my $count = 0 ;
    while (-d "rerun_${count}") {$count++;}
    my $rerun_dir = "rerun_${count}" ;

    system ("mkdir -p $rerun_dir") ;
    die ("DIE. could not create rerun directory $rerun_dir") if ($?) ;
   
    chdir $rerun_dir or die ("DIE. could not change to rerun directory $rerun_dir") ;
  }

$cmd .= " -parallel -nocache " ;
  if ( $sims_tg_seed ne "" ) {
      system ("$cmd -tg_seed=$sims_tg_seed ") ; 
  } else {
      system ("$cmd ") ; 
  }
}

#############################################################################}}}
# replace the source files in the flist with new ones from the graft file{{{
################################################################################

sub graft_flist
{
  print "$prg: grafting flist\n" ;

  open (IFLIST, "< flist") or die ("DIE. can't open flist") ;
  my @iflist = <IFLIST> ;
  close (IFLIST) ;

  my $graft_file	= $opt{graft_flist};
  $graft_file =~ s/\$(\w+)/$ENV{$1}/g ;
  open (GFLIST, "< $graft_file")
	    or die ("DIE. can't open graft file: $graft_file") ;
  my @gflist = <GFLIST> ;
  close (GFLIST) ;
  @gflist = map { s/\$(\w+)/$ENV{$1}/g } @gflist;

  my $ifile = join ('', @iflist) ;

  foreach my $gfile_path (@gflist)
  {
    my $gfile = $gfile_path ;
    $gfile =~ s/^.*\/(\S+)\s*/$1/ ;
    chomp $gfile ;
    chomp $gfile_path ;
    print "gfile: $gfile $gfile_path\n" if $opt_debug ;
    $ifile =~ s/^.*\/$gfile/$gfile_path/m ;
  } 

  open (OFLIST, "> flist") or die ("DIE. can't open graft flist") ;
  print OFLIST $ifile ;
  close (OFLIST) ;
}

#############################################################################}}}
# Generate the verilog config file{{{
################################################################################

sub gen_config
{
  open (OCONF, ">config.v") or die ("DIE. can't open file config.v") ;

  print OCONF "`timescale 1ps/1ps\n" ;

  foreach my $unit (@{$opt{config_rtl}})
  {
    print OCONF "`define $unit\n";
  }
  
  my $sims_build_args;
  if ($opt{vcs_build}) {
  $sims_build_args = "-config_rtl ". join (' -config_rtl ', @{$opt{config_rtl}}). " ".
                        "-vcs_build_args ". join (' -vcs_build_args ', @{$opt{vcs_build_args}});
  }
  elsif ($opt{ncv_build}) {
      @{$opt{ncv_build_args}} =  grep{/(\.v|\+define)/} @{$opt{vcs_build_args}} ;
  $sims_build_args = "-config_rtl ". join (' -config_rtl ', @{$opt{config_rtl}}). " ".
                        "-ncv_build_args ". join (' -ncv_build_args ', @{$opt{ncv_build_args}});
  }
 


  $sims_build_args =~ s/"//g;#"
  my $sims_cmd = join(' ', @argv_copy);
  $sims_cmd =~ s/"//g;

  print OCONF "`define EMBED_SIMS_BUILD_CMD \$display(\"\\nSims Build Cmd: $sims_cmd\\n\");\n";
  print OCONF "`define EMBED_SIMS_BUILD_ARGS \$display(\"\\nSims Build Args: $sims_build_args\\n\");\n";
  close (OCONF);
}

#############################################################################}}}
# Generate the flist file {{{
################################################################################

sub gen_flist
{
  # add sunv flist if it exists
  if (-f "$model_path/flist_sunv")
  {
    unshift (@{$opt{flist}}, "$model_path/flist_sunv");
  }

  open (OFLIST, ">flist") or die ("DIE. can't open flist file") ;

  print "(gen_flist) put $ENV{PWD}/config.v to flist\n";
  print OFLIST "$ENV{PWD}/config.v\n";

  foreach my $flist (@{$opt{flist}})
  {
    print "(gen_flist) processing $flist for flist\n";
    $flist =~ s/\$(\w+)/$ENV{$1}/g ;

    open (IFLIST, "< $flist") or die ("DIE. can't open flist file $flist") ;

    while (<IFLIST>)
    {
      my $line = $_ ;
      my $base = dirname ($flist) ;
     
      $line =~ s/^\s*(.*?)\s*$/$1/ ;
      $line .= "\n" ;

      if (($line =~ /^\s*\/\//) or
          ($line =~ /^\s*$/))
      {
        next ;
      }

      $line =~ s/\$(\w+)/$ENV{$1}/g ;

      if ($line =~ /^\+incdir\+\//)
      {
      }
      elsif ($line =~ /^\+incdir\+/)
      {
        $line =~ s/^\+incdir\+(.*)/\+incdir\+$base\/$1/ ;
      }
      elsif ($line =~ /^\-v\s\//)
      {
      }
      elsif ($line =~ /^\-v/)
      {
        $line =~ s/-v\s*(.*)/-v $base\/$1/ ;
      } 
      elsif ($line =~ /^-y\s\//)
      {
      }
      elsif ($line =~ /^-y/)
      {
        $line =~ s/-y\s*(.*)/-y $base\/$1/ ;
      }
      elsif (($line =~ /^\+define/) or
             ($line =~ /^\+libext/) or
             ($line =~ /^\+librescan/))
      {
      }
      elsif ($line !~ /^\//)
      {
        $line = "$base/$line" ; 
      }

      print OFLIST $line ;
    }

    close (IFLIST) ;
  }

  foreach my $file (@{$opt{vfile}})
  {
    chomp $file ;
    $file =~ s/\$(\w+)/$ENV{$1}/g ;
    print OFLIST "$file\n" ;
    print "vfile $file has been added to flist\n" ;
  }

  if ($opt{vera_build} and !$opt{vcs_use_ntb}) # original Vera
  {
    print OFLIST "$model_path/$opt{sys}_top_shell.v\n" if (!$opt{dftvert}) ;
    print "$opt{sys}_top_shell.v has been added to flist\n" ;
  }

  close (OFLIST) ;
}

#############################################################################}}}
# if a signal is received do some cleanup - kill sas, delete tmp directories{{{
################################################################################

sub sighandler
{
  my $sig = shift ;

  print "$prg: Caught a SIG${sig}\n" ;
  print "$prg: Trying to clean up ..\n" ;

  if ((defined $sas_pid) and ($sas_pid != 0))
  {
    print "Killing sas ($sas_pid)\n";
    kill -9, $sas_pid ;
  }

  if ((defined $tcl_pid) and ($tcl_pid != 0))
  {
    kill -9, $tcl_pid ;
  }

  if ($opt{vcs_run}) {
  `regreport -1 > status.log` ; }
  elsif ($opt{ncv_run}) {
  `regreport -1 -sim ncv > status.log` ; }

  if ($opt{regress})
  {
    if ((defined ($work_dir)) and (-d "$work_dir"))
    {
      chdir $launch_dir ;
      `/bin/cp -r $work_dir/* $launch_dir` ;
      `/bin/rm -rf $work_dir` ;
      `/bin/rmdir $work_dir` ;
    }
  }

my $s=`uname -s`; chomp $s; if ($s eq "SunOS") {
  my @cpids = map {/\s+(\d+)\s+/} 
        grep(/simv|ncsim|python|nas|midas|perl/, split(/\n/, `/bin/ptree $pid $$ `));
  kill -9, reverse(@cpids);

  exit (1) ;
}
}


#############################################################################}}}
# create model area{{{
################################################################################

sub create_model_path
{
    my $cur_dir = $ENV{PWD};

    print "$prg: creating model directory $model_path\n" ;
    `mkdir -p $model_path` ;
    die ("DIE. could not create directory $model_path") if ($?) ;
    chdir ($model_path) or die ("DIE. Could not cd to $model_path") ;

    # clean up the model area as needed

    if ($opt{vcs_clean})
    {
      print "$prg: cleaning up VCS build directory\n" ;
        print "$prg: [ % /bin/rm -rf simv simv.daidir (and also simv.cm and simv.vdb if applicable) ]\n" ;
        system ( " /bin/rm -rf simv simv.daidir simv.cm simv.vdb " ) ;
    }
    elsif ($opt{ncv_clean})
    {
      print "$prg: cleaning up NC-Verilog build directory\n" ;
        print "$prg: [ % /bin/rm -rf cds.lib hdl.var ncprep.log ncvlog.log ncelab.log ncvlog.args ncelab.args ncsim.args RUN_NC INCA_libs ]\n" ;
        `rm -rf cds.lib hdl.var ncprep.log ncvlog.log ncelab.log ncvlog.args ncelab.args ncsim.args RUN_NC INCA_libs` ;
    }

 
    # get the diff_release if needed
    if ($opt{diff_cdms_rel} && $opt{diff_cdms_curr} 
        && $opt{cdms_rel_name} ne "") {
        chomp(my ($relnum) = (grep(/Editing\s+S\s+:/, `show_release $opt{cdms_rel_name} -local -dirs 0`))[0] =~ m/v=(\w+:\d+\.\d+)/o );
        $opt{cdms_rel_name} = "-v $relnum $opt{cdms_rel_name}" ;
    }
    if ($opt{diff_cdms_rel})
    {
      $opt{cdms_rel_name} =~ s/"//g; #"
      print "$prg: diffing release $opt{cdms_rel_name}\n";
      system ("diff_release $opt{cdms_rel_name} > diff_rel.log") ;
    }

    print "(debug) mkdir -p vera\n" ;
    `mkdir -p vera` ;
    die ("DIE. could not create directory vera under $model_path") if ($?) ;

    print "(debug) mkdir -p lib\n" ;
    `mkdir -p lib` ;
    die ("DIE. could not create directory lib under $model_path") if ($?) ;

    # go back to where the script was invoked
    print "(debug) cd $cur_dir\n" ;
    chdir $cur_dir ;
}

#############################################################################}}}
# build the traditional vera testbench files or {{{
# build the NTB vshell file if $opt{vcs_use_ntb} and $opt{ntb_lib} or
# build an flilst of openVera files for the VCS build if $opt{vcs_use_ntb} and !$opt{ntb_lib}
################################################################################

sub vera_build
{
    my $cur_dir = $ENV{PWD};

    print "$prg: vera_build start (vera or NTB build start) ",`date`;

    if ($opt{vcs_use_ntb} and $opt{ntb_lib}) {
      print "$prg: building NTB (NTB LIB) shell file and flist file\n" ;
    } elsif ($opt{vcs_use_ntb} and !$opt{ntb_lib}) {
      print "$prg: building NTB (NTB ALL) flist file\n" ;
    } else {
      print "$prg: building traditional vera files (not NTB)\n" ;
    }

    # change to the build area
    my $vera_dir = "$opt{env_base}/vera" ;
    chdir $vera_dir or die ("DIE. Can't cd to $vera_dir") ;

    $ENV{VERA_LIBDIR} = "$model_path/vera";
    print "$prg: setenv VERA_LIBDIR $ENV{VERA_LIBDIR}\n";

#     if($proj_vars{has_denali}) {
#       # figure out the location of denali from tre
#       my $denali_home = (defined $ENV{DENALI_HOME})? $ENV{DENALI_HOME} :
#                         "/import/datools/vendor/denali/v" ;
#       $denali_home .= `configsrch denali_pcie /` ;
#       chomp ($denali_home) ;
#       die ("DIE. Append _64bit to your denali version in your tver file to work with 64 bit vcs") if (($denali_home !~ /_64bit/) && ($opt{vcs_full64}));
#       die ("DIE. Conflict between 64 bit denali version in your tver file and 32 bit vcs") if (($denali_home =~ /_64bit/) && (!$opt{vcs_full64}));
#       $ENV{DENALI} = $denali_home ;
#       print "$prg: setenv DENALI $ENV{DENALI}\n";
#     }
    # create the gmake command

    foreach my $obj (@{$opt{vera_cov_obj}})
    {
      $obj =~ tr/a-z/A-Z/ ;
      push (@{$opt{vera_build_args}}, "$obj=1") ;
    }

    my $vera_build_cmd = "gmake ";
    $vera_build_cmd .= join (" ", @{$opt{vera_build_args}}) ;
    $vera_build_cmd .= " VERA_LIBDIR=$model_path/vera";
    $vera_build_cmd .= " SIMS_64BIT=1" if ($opt{vcs_full64});

    # if NTB ntb_lib
    if ($opt{vcs_use_ntb} && $opt{ntb_lib}) {
      if ($opt{vcs_use_cli}) {
        $vera_build_cmd .= " VCS_USE_CLI=\"+cli -line\"";
      }
      if ($opt{vcs_use_ucli}) {
        $vera_build_cmd .= " VCS_USE_CLI=\"-debug_all\"";
      }
      if ($opt{vcs_use_fsdb} or $opt{vcs_use_vcsd}) {
        $vera_build_cmd .= " VCS_USE_VCSD=+vcsd";
      }
    }


    # clean the vera/NTB testbench
    if ($opt{vera_clean} && $opt{vera_gmake})
    {
      print "$prg: $vera_build_cmd clean\n" ;
        system ("$vera_build_cmd clean") ;
        die ("DIE. failed cleaning vera testbench in $ENV{PWD}") if ($?) ;
    }


    # if NTB is in use
    if ($opt{vcs_use_ntb} and $opt{vera_build} and $opt{vcs_build} and $opt{vera_gmake}) {
      # if ntb_lib, this is first pass of 2 pass NTB libtb.so compile process.
      if ($opt{ntb_lib}) {
        if ($opt{vera_dummy_diag} eq "" and $opt{vera_diag_name} eq "") {
          print ("NOTICE: failed to specify either an openVera diag or dummy diag (-vera_dummy_diag).\nOne of these is normally required to build when using -ntb_lib!!!\n");
        }
        my $tmp_diag_name;
        if ($opt{vera_diag_name} ne "") {
          my $full_path = &find_diag_path ($opt{vera_diag_name},
                                           $opt{vera_diag_path}, 
                                           $opt{vera_diag_root});
          $tmp_diag_name = $full_path;
        } else {
          $tmp_diag_name = $opt{vera_dummy_diag};
        }
        print "$prg: gmaking NTB (NTB LIB) shell file, using openVera diag $tmp_diag_name\n";
        $vera_build_cmd .= " NTB_DIAG=$tmp_diag_name USE_NTB_LIB=1 ntb_build";
      } else { # NTB all in one compile in use
        print "$prg: gmaking NTB (NTB ALL) related flist (\$VERA_LIBDIR/ntb_flist) for VCS build to use\n";
        $vera_build_cmd .= " USE_NTB_ALL=1 ntb_build";
      }


      # build the vshell file if -ntb_lib or make the ntb_all flist
      print "$prg: $vera_build_cmd\n";
    if ($opt{vera_gmake}) {
        system ($vera_build_cmd) ;
        die ("DIE. failed making NTB testbench in $ENV{PWD}") if ($?) ;
      }
    } 


    # traditional vera only
    if (! $opt{vcs_use_ntb}) {

      # build the vera source files
      print "$prg: $vera_build_cmd\n" ;
    if ($opt{vera_gmake} && $vera_build_cmd ne "") {
        system ($vera_build_cmd) ;
        die ("DIE. failed making vera testbench in $ENV{PWD}") if ($?) ;
      }

      # generate a project file in the model area
      chdir $model_path or die ("DIE. Can't cd to $model_path") ;

      print "$prg: creating vera project file\n" ;
      open (PROJFILE, "> vera/$opt{sys}_top.proj") or die ("DIE. could not create project file") ;

      print PROJFILE "main $opt{sys}_top\n" ;
      print PROJFILE "$ENV{PWD}/vera/$opt{vera_vcon_file}\n" if ($opt{vera_vcon_file} ne "") ;

      opendir (LIBDIR, "vera") or die ("DIE. can't open vera directory") ;
      my @filenames = readdir LIBDIR ;
      closedir (LIBDIR) ;

      foreach my $filename (@filenames)
      {
        if ($filename =~ /\.vro/)
        {
          print PROJFILE ("$ENV{PWD}/vera/$filename\n") ;
        }
      }

      close (PROJFILE) ;


      # generate the vera shell verilog file

      print "$prg: creating vera shell file\n" ;

      foreach my $obj (@{$opt{vera_cov_obj}})
      {
        $obj =~ tr/a-z/A-Z/ ;
        push (@{$opt{vera_proj_args}}, "-D$obj") ;
      }

      push (@{$opt{vera_proj_args}}, "vera/$opt{sys}_top.proj") ;

      my $vera_proj_cmd = "vera -proj " ;
      $vera_proj_cmd .= join (" ", @{$opt{vera_proj_args}}) ;

      print "$prg: $vera_proj_cmd\n" ;

        system ($vera_proj_cmd) ;
        die ("DIE. vera shell creation failed") if ($?) ;
    }

    print "$prg: vera_stop (vera or NTB build done) ",`date` ;

    # go back to where the script was invoked
    chdir $cur_dir ;
}

#############################################################################}}}
# pre build vcs code{{{
# config.v + flist are created
################################################################################

sub pre_build
{
  my $cur_dir = $ENV{PWD};
  print "(debug)(pre_build) cur_dir : $cur_dir \n";

  # go to the model area
  chdir $model_path or die ("DIE. Can't cd to $model_path\n") ;
  print "(debug)(pre_build) cd $model_path \n";

  # generate the rtl config file
  &gen_config ($opt{sys});

  # Generate the flist file
  &gen_flist ();

  system("cp -f flist $cur_dir");
  # merge in the graft flist
  if ($opt{graft_flist} ne "")
  {
    print "(debug)call graft_flist\n";
    &graft_flist () ;
  }

  # go back to where this block was invoked
  chdir $cur_dir ;
}

#############################################################################}}}
# build a model{{{
################################################################################

# building using NCVerilog

sub ncv_build 
{
    my $cur_dir = $ENV{PWD};

    # go to the model area
    chdir $model_path or die ("DIE. Can't cd to $model_path") ;

	my $u=`uname -s`;chomp $u;
    system("/bin/rm -rf *.so *.a *.o");
    print "$prg: Building shared object for Vera (NC-Verilog)\n";
	if ($u eq "SunOS") {
    system("/bin/cp $ENV{DV_ROOT}/verif/env/common/pli/vera/loadpli/Makefile.nc .");
    }
    else {
    system("/bin/cp $ENV{DV_ROOT}/verif/env/common/pli/vera/loadpli/linux/Makefile.nc* .");
    }
    system("make -f Makefile.nc");

    if ( ($opt{sys} eq "fc1") or ($opt{sys} eq "fc8") ) 
    {
#    if ( !(grep {$_ eq '-DFC_NO_NIU_T2'} @{$opt{config_cpp_args}}) ) 
#    {
#    print "$prg: Building shared object for NIU (NC-Verilog)\n";
#    system("ar cr libnet_ncverilog.a ./vera/*.o");
#    if ( !(-e "libnet_ncverilog.a") ) { exit(0); }
#    system("/bin/cp $ENV{DV_ROOT}/verif/env/common/pli/niu_pli/loadpli/Makefile.nc ./Makefile2.nc");
#    system("make -f Makefile2.nc");
#	}
	}
    system("/bin/ls -al *.so");
    
	$ENV{LD_LIBRARY_PATH}=$ENV{PWD}.":".$ENV{LD_LIBRARY_PATH};
    if ( ($opt{sys} eq "fc1") or ($opt{sys} eq "fc8") ) {
	$ENV{LD_LIBRARY_PATH}=$ENV{DV_ROOT}."/verif/model/verilog/niu/sparse_mem_model/loadpli:".$ENV{LD_LIBRARY_PATH};
#	$ENV{LD_LIBRARY_PATH}=$ENV{DV_ROOT}.$ENV{LD_LIBRARY_PATH};
    }
    my $a=`configsrch debussy_ncv /`; chomp $a;
	if ($u eq "SunOS") {
        $ENV{LD_LIBRARY_PATH}=$ENV{NOVAS_HOME}."/share/PLI/nc". $a ."/SOLARIS2/nc_loadpli1:".$ENV{LD_LIBRARY_PATH};
	}
	elsif ($u eq "Linux") {
        $ENV{LD_LIBRARY_PATH}=$ENV{NOVAS_HOME}."/share/PLI/nc". $a ."/LINUX/nc_loadpli1:".$ENV{LD_LIBRARY_PATH};
	}

    if (exists $ENV{LM_LICENSE_FILE})
    {
    print "$prg: LM_LICENSE_FILE : $ENV{LM_LICENSE_FILE}\n";
    }
    
    push (@{$opt{ncv_build_args}}, "+elaborate") ;
    push (@{$opt{ncv_build_args}}, "+name+$opt{sys}") ;
    push (@{$opt{ncv_build_args}}, "+ncaccess+rw");
    push (@{$opt{ncv_build_args}}, "+ncnomempack");
    push (@{$opt{ncv_build_args}}, "+ncvlogargs+-messages") ;
    push (@{$opt{ncv_build_args}}, "+ncelabargs+-messages") ;
    push (@{$opt{ncv_build_args}}, "+ncsimargs+-messages") ;
    push (@{$opt{ncv_build_args}}, "+ncvlogargs+-status") ;
    push (@{$opt{ncv_build_args}}, "+ncelabargs+-status") ;
    push (@{$opt{ncv_build_args}}, "+ncsimargs+-status") ;
    push (@{$opt{ncv_build_args}}, "+ncvlogargs+\"-nowarn MACRDF\"") ;
    push (@{$opt{ncv_build_args}}, "+ncelabargs+-append_log") ;
    push (@{$opt{ncv_build_args}}, "+ncelabargs+-pliverbose") ;
    push (@{$opt{ncv_build_args}}, "+ncelabargs+-notimingchecks") ;
    push (@{$opt{ncv_build_args}}, "+ncelabargs+-nospecify") ;
    push (@{$opt{ncv_build_args}}, "+ncsimargs+-append_log") ;
    push (@{$opt{ncv_build_args}}, "+loadpli1=debpli:novas_pli_boot") ;
    push (@{$opt{ncv_build_args}}, "+loadpli1=libverapli:vera_pli_boot") ;
    push (@{$opt{ncv_build_args}}, "+loadpli1=libmonitorpli:monitor_pli_boot") ;
    push (@{$opt{ncv_build_args}}, "+loadpli1=libglobal_chkrpli:global_chkr_pli_boot") ;
    push (@{$opt{ncv_build_args}}, "+loadpli1=libsocketpli:socket_pli_boot") ;



    if ( ($opt{sys} =~ m/fpga/)) {
       push (@{$opt{ncv_build_args}}, "+ncelabargs+-initmem0") ;
    }

    if ( ($opt{sys} eq "cmp1") or ($opt{sys} eq "cmp8") ) {
        push (@{$opt{ncv_build_args}}, "+delay_mode_zero") ;
    }
    if ( ($opt{sys} eq "fc1") or ($opt{sys} eq "fc8") ) {
##    if ( !(grep {$_ eq '-DFC_NO_NIU_T2'} @{$opt{config_cpp_args}}) ) {
##        push (@{$opt{ncv_build_args}}, "+loadpli1=libniupli:niu_pli_boot") ;
##        push (@{$opt{ncv_build_args}}, "+loadpli1=libniu_sparse_mem_model_pli:sparse_mem_model_pli_boot") ;
##	my $vc_libs="+vera_directc=";
##	$vc_libs.="$ENV{DV_ROOT}/verif/env/common/vera/niu_ippktgen/C/libnet/src/libnet_niu_ippktgen_pli.so";
##	$vc_libs.=":$ENV{DV_ROOT}/verif/model/verilog/niu/sparse_mem_model/loadpli/libniu_sparse_mem_model_pli.so";
##	$vc_libs.=":$ENV{DV_ROOT}/verif/env/common/vera/niu_ippktgen/C/wrapper/libniu_ippktgen_pli.so";
##	$vc_libs.=":$ENV{DV_ROOT}/verif/env/common/pli/niu_pli/loadpli/libpgRandom.so";
##	push (@{$opt{ncv_build_args}}, "+ncsimargs+\"$vc_libs\"") ;
##    }
        push (@{$opt{ncv_build_args}}, "+loadpli1=libcachepli:cache_pli_boot") ;
        push (@{$opt{ncv_build_args}}, "+loadpli1=libutilitypli:utility_pli_boot") ;
        push (@{$opt{ncv_build_args}}, "+loadpli1=libmemorypli:memory_pli_boot") ;
    }
    push (@{$opt{ncv_build_args}}, "-l ncprep.log") ;
    push (@{$opt{ncv_build_args}}, "\`cat $model_path/flist\`") ;
    push (@{$opt{ncv_build_args}}, "+define+NO_VERA") if (!$opt{vera_build}) ;
    push (@{$opt{ncv_build_args}}, "+define+TCL_TAP_TEST") if ($opt{tcl_tap}) ;


    my $ncv_build_cmd  = "ncprep " ;
    # Transfer some build args to the flist
    open (IFLIST, "> flist.new") or die ("DIE. can't open flist.new") ;
    foreach my $x (@{$opt{ncv_build_args}})
    {
      $x =~ s/^"(.*?)"$/$1/ ;
      if ($x =~ /\+define+|^-v |^-y |^-f (?!(flist|.*0in.*?\.arg))/) {
        print IFLIST "$x\n";
      } else {
        $ncv_build_cmd .= "$x " ;
      }
    }
    
    my $cache_dir;
    if ($opt{cache}) 
    {
    my $cache_dir_prefix = $ENV{TEMPDIR} ;
    if ( !( -d $ENV{TEMPDIR} ) ) { system ("mkdir -p $ENV{TEMPDIR}") ; }
    die ( "DIE. Could not access your temporary cache directory. \n") if ( !( -d $ENV{TEMPDIR} ) ) ;
    if (-d $cache_dir_prefix ) 
    {
    opendir D, $cache_dir_prefix or die (" Could not open directory \" ${cache_dir_prefix} \" for reading!\n");
    my @d = map { $cache_dir_prefix . "/" . $_  } grep { !/^\./ && -d "$cache_dir_prefix/$_" } readdir D ; closedir D;
    
    foreach (@d) {
        if ( ( time - ( (stat $_ )->mtime ) ) > ( 60*60*$cache_clean_time ) ) {
            system ( "/bin/rm -rf $_" ) ;
        }
    }
        
    $cache_dir = $cache_dir_prefix . "/OpenSPARC_T2___NC_Verilog___" . $opt{sys} . "___build" ;
    my $count = 0;
    while ( -d "${cache_dir}_${count}" ) { ++$count; }
    $cache_dir .= "_$count" ;
    system ("mkdir -p $cache_dir") ;
    die ("DIE. Could not create temporary cache sub-directory for NC-Verilog compilation ") if ($?) ;
    }
    }
    
    # Append flist to flist.new and rename to flist.
    open (FLIST, "flist") or die ("DIE. can't open flist");
    while (<FLIST>) {
        print IFLIST "$_";
    }
    close FLIST;
    close IFLIST;
    rename "flist", "flist.orig" or die ("DIE. can't rename flist");
    rename "flist.new", "flist" or die ("DIE. can't rename flist.new");

    # build the model
    print "$prg: Building rtl model\n" ;
    print "$prg: <<<<<<< (BUILDTIME command) >>>>>>>   $ncv_build_cmd\n";
    my $date1;


  $date1 = `date` ;
  chomp ($date1) ;
  print "$prg: (DATE) $date1\n";

    if ($opt{cache}) 
    {
    print "$prg: will start compilation inside cache : \( " . $cache_dir .   " \)\n";
    chdir $cache_dir ;
      system ($ncv_build_cmd) ;
      die ("DIE. failed ncprep translation for building model") if ($?) ;
    } else {
    print "$prg: will start compilation inside : \( " . $ENV{PWD} .   " \)\n";
    system ($ncv_build_cmd) ;
    }
  
  $date1 = `date` ;
  chomp ($date1) ;
  print "$prg: (DATE) $date1\n";
    system ("ncvlog -f ncvlog.args") ;

  $date1 = `date` ;
  chomp ($date1) ;
  print "$prg: (DATE) $date1\n";
    system ("echo \"LD_LIBRARY_PATH is: \" $ENV{LD_LIBRARY_PATH} > ncelab.log") ;
      system ( "echo OpenSPARC_T2 compile dir is: $ENV{PWD} >> ncelab.log" );
    system ("ncelab -f ncelab.args") ;
    system ("/bin/rm -rf RUN_NC");
    open F, "<cds.lib" or die "Can't open cds.lib for reading: $!\n" ; my @f=<F>; chomp @f; close F;
    system ("/bin/rm -rf cds.lib") ;
    open F, ">cds.lib" or die "Can't open cds.lib for writing: $!\n" ;
    foreach (@f) { 
	  s/^define\s(\w+)\s.*\/INCA_libs\/(\w+)$/define $1 $model_path\/INCA_libs\/$2/; 
	  print F $_."\n"; 
#	  print "cds\.lib\> ".$_."\n"; 
	}
    close F;

    if ($opt{cache}) 
    {
      print "$prg: will now copy the NC-Verilog simulation snapshot (INCA_libs) from cache to the original build directory. \n"; 
    system ("/bin/cp -rf INCA_libs cds.lib hdl.var *args *log $model_path"); 
    sleep(30);
    }

    # go back to where the script was invoked
    chdir $cur_dir ;
if ($opt{parallel}) {
print "$prg: removing cache dir.\n" ; 
system ( " /bin/rm -rf $cache_dir " ) ;
}
}

# building using VCS

sub vcs_build
{
    my $cur_dir = $ENV{PWD};

    # go to the model area
    chdir $model_path or die ("DIE. Can't cd to $model_path") ;
    print "(vcs_build) cd into $model_path\n";

    # copy the sdf file
    my $sdf_file = "$opt{env_base}/cmp_top.sdf" ;
    `cp -f $sdf_file .` if (($opt{vcs_use_sdf}) and (-f $sdf_file)) ;

    $ENV{VERA_LIBDIR} = "$model_path/vera";
    print "$prg: setenv VERA_LIBDIR $ENV{VERA_LIBDIR}\n";

 
    if($proj_vars{has_denali}) {
      # figure out the location of denali from tre
      my $denali_home = (defined $ENV{DENALI_HOME})? $ENV{DENALI_HOME} :
                        "/import/datools/vendor/denali/v" ;
      $denali_home .= `configsrch denali_pcie /` ; 
      chomp ($denali_home) ;
      die ("DIE. Append _64bit to your denali version in your tver file to work with 64 bit vcs") if (($denali_home !~ /_64bit/) && ($opt{vcs_full64}));
      die ("DIE. Conflict between 64 bit denali version in your tver file and 32 bit vcs") if (($denali_home =~ /_64bit/) && (!$opt{vcs_full64}));
      $ENV{DENALI} = $denali_home ;
      print "$prg: setenv DENALI $ENV{DENALI}\n";
    }

    # figure out the location of 0in from tre
    # my $zeroIn_home = "/import/cadist-sme/pkgs/zeroin/zeroin,v" ;
    # $zeroIn_home .= `configsrch zeroin /` ;
    # chomp ($zeroIn_home) ;
    # $zeroIn_home .= "/5.x/sol8_sparc" ;
    # if ($opt{vcs_full64}) {
      # $zeroIn_home .= "/5.x/sol8_sparc_64" ;
    # }
    # $ENV{HOME_0IN} = $zeroIn_home ;
    # print "$prg: setenv HOME_0IN $ENV{HOME_0IN}\n";

    if (exists $ENV{LM_LICENSE_FILE})
    {
    print "$prg: LM_LICENSE_FILE : $ENV{LM_LICENSE_FILE}\n";
    }

    push (@{$opt{vcs_build_args}}, "+compsdf") if ($opt{vcs_use_sdf}) ;
    push (@{$opt{vcs_build_args}}, "+rad") if ($opt{vcs_use_rad}) ;
    push (@{$opt{vcs_build_args}}, "-Xmodname=0x1");
    push (@{$opt{vcs_build_args}}, "+vcsd") if ($opt{vcs_use_fsdb} and $opt{vcs_use_vcsd}) ;
    push (@{$opt{vcs_build_args}}, "-vera") if ($opt{vcs_use_vera}) ;

    push (@{$opt{vcs_build_args}}, "-file $model_path/vera/ntb_flist") if ($opt{vcs_use_ntb}) ;
    push (@{$opt{vcs_build_args}}, "+initreg") if ($opt{vcs_use_initreg}) ;
    push (@{$opt{vcs_build_args}}, "-cm $opt{vcs_cm_args}") if ($opt{vcs_use_cm}) ;
    push (@{$opt{vcs_build_args}}, "-cm_cond $opt{vcs_cm_cond}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_cond} ne "")) ;
    push (@{$opt{vcs_build_args}}, "-cm_fsmcfg $opt{vcs_cm_fsmcfg}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_fsmcfg} ne "")) ;
    push (@{$opt{vcs_build_args}}, "-cm_hier $opt{vcs_cm_config}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_config} ne "")) ;
    push (@{$opt{vcs_build_args}}, "-cm_name $opt{vcs_cm_name}") if ($opt{vcs_use_cm}) ;
    push (@{$opt{vcs_build_args}}, "-cm_dir $model_path") if ($opt{vcs_use_cm}) ;
    push (@{$opt{vcs_build_args}}, "+cli -line") if (!$opt{axis_build} && $opt{vcs_use_cli}) ;
    push (@{$opt{vcs_build_args}}, "-debug_all") if (!$opt{axis_build} && $opt{vcs_use_ucli}) ;
	my $u=`uname -s`;chomp $u;my $lib_dir;
	if ($u eq "SunOS") {
    		$lib_dir = "SOLARIS2";
    		if ($opt{vcs_full64}) { $lib_dir = "SOL7_64bit"; }
	}
	elsif ($u eq "Linux") {
		$lib_dir = "LINUX";
		if ($opt{vcs_full64}) { $lib_dir = "LINUX64"; }
	}
    if ($opt{vcs_use_fsdb}) {
        if ($opt{vcs_use_vcsd}) {
            my $a=`configsrch debussy_vcsd /`; chomp $a;
            push (@{$opt{vcs_build_args}}, "-P $ENV{NOVAS_HOME}/share/PLI/vcsd" . $a . "/$lib_dir/vcsd.tab") ;
            push (@{$opt{vcs_build_args}}, "$ENV{NOVAS_HOME}/share/PLI/vcsd" . $a . "/$lib_dir/pli.a") ;
        }
        else {
            my $a=`configsrch debussy_vcs /`; chomp $a;
            push (@{$opt{vcs_build_args}}, "-P $ENV{NOVAS_HOME}/share/PLI/vcs" . $a . "/$lib_dir/debussy.tab") ;
            push (@{$opt{vcs_build_args}}, "$ENV{NOVAS_HOME}/share/PLI/vcs" . $a . "/$lib_dir/pli.a") ;
        }
    }
    else { push (@{$opt{vcs_build_args}}, "+define+FSDB_OFF") ; }

    push (@{$opt{vcs_build_args}}, "+define+NO_VERA") if (!$opt{vera_build}) ;
    push (@{$opt{vcs_build_args}}, "+define+TCL_TAP_TEST") if ($opt{tcl_tap}) ;
    push (@{$opt{vcs_build_args}}, "-full64") if ($opt{vcs_full64}) ;
    push (@{$opt{vcs_build_args}}, "-l compile.log") ;
    push (@{$opt{vcs_build_args}}, "-f flist") ;

    if ($opt{zeroIn_build})
    {
      push (@{$opt{vcs_build_args}}, "$ENV{HOME_0IN}/0InPLI/vcs/lib0InvcsPLI.so") ;
      push (@{$opt{vcs_build_args}}, "-f $model_path/zeroInDir/0in_sim.arg") ;
    }

    if ($opt{zeroInSearch_build})
    {
      push (@{$opt{vcs_build_args}}, "$ENV{HOME_0IN}/0InPLI/vcs/lib0InvcsPLI.so") ;
      push (@{$opt{vcs_build_args}}, "-f $model_path/zeroInDir/0in_seed.arg") ;
    }
    my $vcs_build_cmd  = "vcs " ;
    $vcs_build_cmd = "tharas_compile -project $opt{sys} -comp_options \' " 
        if ($opt{hcs_build}) ;
    $vcs_build_cmd = "axis_compile  -project $opt{sys} -comp_options \' " 
        if ($opt{axis_build}) ;

    # Transfer some build args to the flist
    open (IFLIST, "> flist.new") or die ("DIE. can't open flist.new") ;
    foreach my $x (@{$opt{vcs_build_args}}) {
      $x =~ s/^"(.*?)"$/$1/ ;
      if ($opt{hcs_build} && ($x !~ /^\+def|^-P |^-l |^-v |^-f |^-P |\.a\s*$/)) {
        $x = "+hcs+vcsFlags \"$x\"" ;
      }
      elsif ($opt{axis_build} && ($x =~ /\.a\s*$|\.[s]*o\s*$/)) {
        $x =~ s/\+vc\b//;
        $x = "-pl $x" ;
      }
      elsif ($x =~ /\+define+|^-v |^-y |^-f (?!(flist|.*0in.*?\.arg))/) {
        print IFLIST "$x\n";
      } else {
          if ($x=~m/^-f flist$/) { $x=~s/flist/$model_path\/flist/; }
          if ($x=~m/^ \+vc (vera\/\w+\.(o|a))$/) { my $y = " +vc " . $model_path . "/" . $1; $x = $y; }
        print "(debug) (vcs_build_arg) $x\n";
        $vcs_build_cmd .= "$x " ;
      }
    }

    # Tharas Build args
    if ($opt{hcs_build}) {
     $vcs_build_cmd .= " \' " ;
      foreach my $x (@{$opt{hcs_build_args}})
      {
        $x =~ s/^"(.*?)"$/$1/ ;
        $vcs_build_cmd .= "$x " ;
      }
     if($opt{vcs_clean}) {
        $vcs_build_cmd .= " -clean " ;
     }
    }
    
    # Palladium Build args
    # No -vcs_build_args passed to palladium_compile
    if ($opt{palladium_build}) {
        $vcs_build_cmd = "palladium_compile  -project $opt{sys} " ;
      foreach my $x (@{$opt{palladium_build_args}})
      {
        $x =~ s/^"(.*?)"$/$1/ ;
        $vcs_build_cmd .= "$x " ;
      }
     if($opt{vcs_clean}) {
        $vcs_build_cmd .= " -clean " ;
     }
    }

    # Axis Build args
    if ($opt{axis_build}) {
     $vcs_build_cmd .= " \' " ;
      foreach my $x (@{$opt{axis_build_args}})
      {
        $x =~ s/^"(.*?)"$/$1/ ;
        $vcs_build_cmd .= "$x " ;
      }
     if($opt{vcs_clean}) {
        $vcs_build_cmd .= " -clean " ;
     }
    }

    
    my $cache_dir;
    if ($opt{cache}) 
    {
    my $cache_dir_prefix = $ENV{TEMPDIR} ;
    if ( !( -d $ENV{TEMPDIR} ) ) { system ("mkdir -p $ENV{TEMPDIR}") ; }
    die ( "DIE. Could not access your temporary cache directory. \n") if ( !( -d $ENV{TEMPDIR} ) ) ;
    if (-d $cache_dir_prefix ) 
    {
    opendir D, $cache_dir_prefix or die (" Could not open directory \" ${cache_dir_prefix} \" for reading!\n");
    my @d = map { $cache_dir_prefix . "/" . $_  } grep { !/^\./ && -d "$cache_dir_prefix/$_" } readdir D ; closedir D;
    
    foreach (@d) {
        if ( ( time - ( (stat $_ )->mtime ) ) > ( 60*60*$cache_clean_time ) ) {
            system ( "/bin/rm -rf $_" ) ;
        }
    }
        
    $cache_dir = $cache_dir_prefix . "/OpenSPARC_T2___VCS___" . $opt{sys} . "___build" ;
    my $count = 0;
    while ( -d "${cache_dir}_${count}" ) { ++$count; }
    $cache_dir .= "_$count" ;
    system ("mkdir -p $cache_dir") ;
    die ("DIE. Could not create temporary cache sub-directory for VCS compilation ") if ($?) ;
    }
    }
    
    # Append flist to flist.new and rename to flist.
    open (FLIST, "flist") or die ("DIE. can't open flist");
    while (<FLIST>) {
        print IFLIST "$_";
    }
    close FLIST;
    close IFLIST;
    rename "flist", "flist.orig" or die ("DIE. can't rename flist");
    rename "flist.new", "flist" or die ("DIE. can't rename flist.new");

    # build the model
    print "$prg: Building rtl model\n" ;
    # Donguk : added this for vpd capture
    $vcs_build_cmd .= " -debug_pp " ;
    print "$prg: <<<<<<< (BUILDTIME command) >>>>>>>   $vcs_build_cmd\n";

  my $date1 = `date` ;
  chomp ($date1) ;
  print "$prg: (DATE) $date1\n";
    if ($opt{cache}) 
    {
    print "$prg: will start compilation inside cache : \( " . $cache_dir .   " \)\n";
      chdir $cache_dir ;
	print "Current dir: ".  &Cwd::cwd() << "\n";
#ifdef SYSTEMC_SUPPORT
      if ($opt{sysc_build}) {
        my $build_args = "";

        foreach my $x (@{$opt{syscan_build_args}})
        {
           $build_args .= "$x ";
        }
         print "Build args being passed to syscan $build_args\n";

         my $syscan_cmd = "$ENV{DV_ROOT}/tools/bin/syscan_cmd_src";
         system("exec perl $syscan_cmd $build_args");
         die ("DIE.  Failed systemc build") if ($?);
       }
#endif
      system ($vcs_build_cmd);
      system ( "echo OpenSPARC_T2 compile dir is: $ENV{PWD} >> compile.log" );
      print "$prg: will now copy the simulation binary (simv) and the direct access interface directory (simv.daidir) from cache to the original build directory. \n"; 
      system ( " /bin/rm -rf csrc" ) ;
      system ( "/bin/cp -rf simv simv.daidir compile.log $model_path" ) ; 
      if (-d "simv.cm") { system ( "/bin/cp -rf simv.cm $model_path" ) ; }
      if (-d "simv.vdb") { system ( "/bin/cp -rf simv.vdb $model_path" ) ; }
      sleep(30);
    }
      else {
    print "$prg: will start compilation inside : \( " . $ENV{PWD} .   " \)\n";
#ifdef SYSTEMC_SUPPORT
      if ($opt{sysc_build}) {
        my $build_args = "";

        foreach my $x (@{$opt{syscan_build_args}})
        {
           $build_args .= "$x ";
        }
         print "Build args being passed to syscan $build_args\n";

         my $syscan_cmd = "$ENV{DV_ROOT}/tools/bin/syscan_cmd_src";
         system("exec perl $syscan_cmd $build_args");
         die ("DIE.  Failed systemc build") if ($?);
       }
#endif
    system ($vcs_build_cmd);
    }

    # go back to where the script was invoked
    chdir $cur_dir ;
    print " goback to $cur_dir \n";
if ($opt{parallel}) {
print "$prg: removing cache dir.\n" ;
system ( " /bin/rm -rf $cache_dir " ) ;
}
}

#############################################################################}}}
# parsing the user supplied non primitive list to obtain the sunv primitive list{{{
################################################################################

sub parse_primitive
{
  my $cur_dir = $ENV{PWD};

  my %nonlist = ();

  chdir $model_path;

  die "DIE. Could not find non primitive list\n" if (! (-f $opt{sunv_nonprim_list})) ;
  system ("cp -f $opt{sunv_nonprim_list} $model_path") ;
  die ("DIE. failed to copy non primitive list to model build area\n") if ($?) ;

  die "DIE. Could not find primitive list\n" if (! (-f "$dv_root/$proj_vars{sims_config}/primitive.list")) ;
  system ("cp -f $dv_root/$proj_vars{sims_config}/primitive.list $model_path") ;
  die ("DIE. failed to copy primitive list to model build area\n") if ($?) ;

  $opt{sunv_nonprim_list} =~ /(\S+)\/(\S+)$/;
  open (NONLIST, "$2");
  while (<NONLIST>)
  {
    $nonlist{$_} = 1;
  }
  close (NONLIST) ;

  open (LIST, ">newprimitive.list");

  open (FULLLIST, "primitive.list");  
  while (<FULLLIST>)
  {
    if (! defined $nonlist{$_})
    {
      print LIST $_;
    }
  }
  close (FULLLIST) ;

  close (LIST) ;

  push (@{$opt{sunv_args}}, "-primitives=$model_path/newprimitive.list");

  # go back to where the script was invoked
  chdir $cur_dir ;
}

#############################################################################}}}
# run sunv {{{
################################################################################

sub sunv_run
{
    my $cur_dir = $ENV{PWD};

    print "$prg: sunv_start ",`date` ;

    # go to the model area
    chdir $model_path or die ("DIE. Can't cd to $model_path\n") ;

    # create sunv output directory
    system ("mkdir -p sunvDir");

    # generate the primitive list if a non primitive list is supplied
    if ($opt{sunv_use_nonprim})
    {
      &parse_primitive;
    }

    # run sunv
    print "$prg: Running sunv\n" ;
    my $sunv_cmd = "sunv.fe ";
    push (@{$opt {sunv_args}}, "-outdir=sunvDir") ;
    $sunv_cmd .= join (" ", @{$opt {sunv_args}}) ;

    print "$prg: $sunv_cmd\n";
      system ("rm -fr sunvDir/*") ;
      die ("DIE. failed cleaning up sunvDir\n") if ($?) ;
      system ($sunv_cmd) ;
      die ("DIE. failed running sunv\n") if ($?) ;

    print "$prg: creating sunv flist file\n" ;

    open (SUNVFILE, "> $model_path/flist_sunv") or die ("DIE. could not create sunv flist file\n") ;

    opendir (LIBDIR, "sunvDir") or die ("DIE. can't open sunvDir directory\n") ;
    my @filenames = readdir LIBDIR ;
    closedir (LIBDIR) ;

    foreach my $filename (@filenames)
    {
      if ($filename =~ /\.v$/)
      {
         print SUNVFILE ("$model_path/sunvDir/$filename\n") ;
      }
    }

    close (SUNVFILE) ;

    print "$prg: sunv_stop ",`date` ;

    # go back to where the script was invoked
    chdir $cur_dir ;
}

#############################################################################}}}
# compile zeroIn {{{
################################################################################

sub zeroIn_build
{
    my $cur_dir = $ENV{PWD};

    print "$prg: 0in_start ",`date` ;

    # go to the model area
    chdir $model_path or die ("DIE. Can't cd to $model_path\n") ;

    my $zeroIn_dir = "zeroInDir";
    # go to the zeroIn dir
    system ("mkdir -p $zeroIn_dir");

    chdir $zeroIn_dir or die ("DIE. Can't cd to $zeroIn_dir\n") ;

    # Debug args if any ..
    my $zin_dbg .= join (" ", @{$opt {zeroIn_dbg_args}}) ;

    # compile zeroIn
    print "$prg: compiling zeroIn\n" ;

    # zeroIn can't handle NTB_LIB shell file so take it out.
    system("cat $model_path/flist | grep -v top_shell.v > $model_path/flist.0in");
    die "$prg: failed to make zeroIn flist file. \n" if($?);

    # zeroIn compile command
    my $zeroIn_build_cmd ;
    $zeroIn_build_cmd = "0in $zin_dbg -cmd ccl -f $model_path/flist.0in " if ($opt{zeroIn_build}) ;
    $zeroIn_build_cmd = "0in $zin_dbg -cmd csl -f $model_path/flist.0in " if ($opt{zeroInSearch_build}) ;
    $zeroIn_build_cmd = "0in $zin_dbg -cmd ckl -f $model_path/flist.0in " if ($opt{zeroIn_checklist}) ;
    $zeroIn_build_cmd .= join (" ", @{$opt {zeroIn_build_args}}) ;

    print "$prg: $zeroIn_build_cmd\n";
      # produce 0in_sim.arg file
      system ($zeroIn_build_cmd) ;
      die ("DIE. failed compiling zeroIn\n") if ($?) ;

    print "$prg: 0in_stop ",`date` ;

    # go back to where the script was invoked
    chdir $cur_dir ;
}

#############################################################################}}}
# run vlint {{{
################################################################################

sub vlint_run
{
  my $cur_dir = $ENV{PWD};

  # Keeping vlint output in current directory

  system ("mkdir -p vlintDir") ;

  # run vlint
  print "$prg: Running vlint\n" ;
  my $vlint_cmd = "x2e ";

  push (@{$opt {vlint_args}}, "-f $model_path/flist") ;
  push (@{$opt {vlint_args}}, "-od vlintDir ") ;

  # always last
  die "DIE. no top level module specified for vlint" if ($opt{vlint_top} eq "") ;
  push (@{$opt {vlint_args}}, $opt{vlint_top}) ;

  $vlint_cmd .= join (" ", @{$opt {vlint_args}}) ;

  print "$prg: $vlint_cmd\n";

    system ($vlint_cmd) ; my $status = $? ;
    if ($opt{illust_run}) {
        my $illust_cmd = "illust ";
        $illust_cmd .= join(" ", @{$opt {illust_args}}) ;
        chdir ("vlintDir");
        if (-e "$opt{vlint_top}.vlint.db") {
            `cp -f $opt{vlint_top}.vlint.db vlint.db` ;
        }
        print "$prg: $illust_cmd\n";
        system ($illust_cmd) ; my $status = $? ;
        chdir ($cur_dir);
        die ("DIE. status=$status: failed running illust \n\t(see vlintDir/{di.log,errors.vlint})\n ") 
            if ($status == 1) ;
    }
    die ("DIE. failed running vlint") if ($status == 1) ;
}

#############################################################################}}}
# run verix {{{
################################################################################

sub verix_run
{
  my $cur_dir = $ENV{PWD};

  # Keeping Verix output in current directory

  system ("mkdir -p verixDir") ;
  chdir("verixDir");

  # Run verix
  print "$prg: Running verix flow\n" ;

  die "DIE. no top level module specified for verix" if ($opt{verix_top} eq "") ;

  # Copy the template
  system ("cp $dv_root/verif/env/config/$opt{verix_top}.verix.tmplt verix.tmplt");
  system("chmod +w verix.tmplt");
  die "DIE. could not copy verix template $dv_root/verif/env/config/$opt{verix_top}.verix.tmplt, $!" if ($?);

  # Create the vlist using the flist_sunv and the libs specified
  open (VLIST, ">$opt{verix_top}.vlist");
  die "DIE. could not create $opt{verix_top}.vlist, $!" if ($?);

  print VLIST "-f $model_path/flist_sunv\n";
  print VLIST "$model_path/config.v\n";

  # Pick up libs and defines from vcs_build args too ..

  foreach (@{$opt{verix_libs}},@{$opt{vcs_build_args}}) {
    s/"//go; #"
    next if (!/(^\+define)|(^-f)|(^-v)|(^-y)/);
    print VLIST "$_\n";
  }
  close VLIST;

  # Run the setup
  my $verix_cmd = "verix_flow -setup $opt{verix_top} ";

  print "$prg: $verix_cmd \n";

    system ("$verix_cmd") ;
    die ("DIE. failed running verix") if ($?) ;

  # Run the run script 
  $verix_cmd = "verix_flow -run $opt{verix_top} ";

  print "$prg: $verix_cmd \n";

    system ("$verix_cmd") ;
    die ("DIE. failed running verix") if ($?) ;
  chdir($cur_dir);
}

#############################################################################}}}
# run tests
################################################################################


sub list {
  my %tmp1; my %tmp2;
  for (0..1) { for my $k (@{$_[$_]}) { $tmp1{$k}.=$_; } }
  while (my($k,$v)=each %tmp1) {push @{$tmp2{$v}},$k;}
  return @tmp2{"0","1","01"}, [keys %tmp1];
}


# run a test using simulation snapshot created from NCV

sub ncv_run 
{
    my $run_dir = $ENV{PWD} ;
    my $cache_dir;
        if ($opt{cache})
        {
    my $cache_dir_prefix = $ENV{TEMPDIR} ;
    if ( !( -d $ENV{TEMPDIR} ) ) { system ("mkdir -p $ENV{TEMPDIR}") ; }
    die ( "DIE. Could not access your temporary cache directory. \n") if ( !( -d $ENV{TEMPDIR} ) ) ;
    if (-d $cache_dir_prefix ) 
    {
    opendir D, $cache_dir_prefix or die (" Could not open directory \" ${cache_dir_prefix} \" for reading!\n");
    my @d = map { $cache_dir_prefix . "/" . $_  } grep { !/^\./ && -d "$cache_dir_prefix/$_" } readdir D ; closedir D;
    
    foreach (@d) {
        if ( ( time - ( (stat $_ )->mtime ) ) > ( 60*60*$cache_clean_time ) ) {
            system ( "/bin/rm -rf $_" ) ;
        }
    }
        
    $cache_dir = $cache_dir_prefix . "/OpenSPARC_T2___NC_Verilog___" . $opt{sys} . "___run" ;
    my $count = 0;
    while ( -d "${cache_dir}_${count}" ) { ++$count; }
    $cache_dir .= "_$count" ;
    system ("mkdir -p $cache_dir") ;
    die ("DIE. Could not create temporary cache sub-directory for NC-Verilog run ") if ($?) ;
    }
    }

    # copy the diff release over
    system ("cp -f $model_path/diff_rel.log .") if (-f "$model_path/diff_rel.log") ;

    # copy the flist over
    system ("cp -f $model_path/flist .") ;
    die ("DIE. could not copy flist to $ENV{PWD}") if ($?) ;

    # pass the good trap and bad trap addresses to the testbench
    my $good_trap = "";
    my $bad_trap = "";

    if (($opt{asm_diag_name} ne "") or ($opt{image_diag_name} ne ""))
    {
      die ("DIE. could not find symbol.tbl file") if (!-f "symbol.tbl") ;

      my @good_trap_list = `grep -w good_trap symbol.tbl`;
      my @bad_trap_list = `grep -w bad_trap symbol.tbl`;
      my %good_trap_list ;
      my %bad_trap_list ;
      my @good_trap ;
      my @bad_trap ;

      if ($#good_trap_list >= 0)
      {
	foreach my $trap (@good_trap_list)
        {
          my ($tmp1, $va, $ra, $pa) = ($trap =~ /([\w_\.]+)\s+(\w+)\s+(\w+)\s+(\w+)/) ;
          $good_trap_list{$pa} = 1 ;
  	}

        foreach my $x (sort (keys (%good_trap_list)))
        {
          push (@good_trap, $x) ;
        }

        if ($#good_trap == 0) { $good_trap = "+good_trap=" . $good_trap[0] ; }
        else { $good_trap = "+good_trap=" . join (':', @good_trap) ; }
      }

      if ($#bad_trap_list >= 0)
      {
	foreach my $trap (@bad_trap_list)
        {
          my ($tmp1, $va, $ra, $pa) = ($trap =~ /([\w_\.]+)\s+(\w+)\s+(\w+)\s+(\w+)/) ;
	  $bad_trap_list{$pa} = $pa;
	}

        foreach my $x (sort (keys (%bad_trap_list)))
        {
          push (@bad_trap, $x) ;
        }

        if ($#bad_trap == 0) { $bad_trap = "+bad_trap=" . $bad_trap[0] ; }
        else { $bad_trap = "+bad_trap=" . join (':', @bad_trap) ; }
      }
    }

    # copy the 'traditional vera' project file over to the run area

    if ( $opt{vera_run}) 
    {
      `cp $model_path/vera/$opt{sys}_top.proj .` ;
      die ("DIE. could not copy .proj file to $ENV{PWD}") if ($?) ;
      `chmod +w $opt{sys}_top.proj`;
      die ("DIE. could not change permission of .proj file") if ($?) ;

      # append diag.vro after the fact
      if ($opt{vera_diag_name} ne "" or $opt{vera_dummy_diag} ne "")
      {
        push (@{$opt{ncv_run_args}}, "+vera_diag_path=$opt{vera_diag_path}") ;
        `ls *.vro >> $opt{sys}_top.proj` ;
        die ("DIE. could not append *.vro to vera project file") if ($?) ;
      }
    }
 
    # add in switches for signal dumping

    if ($opt{vcd})
    {
      my $vcdfile = "";
      if ($opt{vcdfile} eq "")
      {
        $vcdfile = "verilog.vcd" ;
      } else
      {
        $vcdfile = $opt{vcdfile} ;
      }

      push (@{$opt{ncv_run_args}}, "+vcd") ;
    }

    if ($opt{debussy})
    {
      my $fsdbfile = "";
      if ($opt{fsdbfile} eq "")
      {
        $fsdbfile = "verilog.fsdb" ;
      } else
      {
	$fsdbfile = $opt{fsdbfile} ;
      }

      push (@{$opt{ncv_run_args}}, "+debussy") ;
      push (@{$opt{ncv_run_args}}, "+fsdbfile=$fsdbfile") ;
      push (@{$opt{ncv_run_args}}, "+fsdb+dumpon+".bigtime2plus($opt{start_dump})) if ($opt{start_dump} != 0) ;
      push (@{$opt{ncv_run_args}}, "+fsdb+dumpoff+".bigtime2plus($opt{stop_dump})) if ($opt{stop_dump} != 0) ;
      push (@{$opt{ncv_run_args}}, "+fsdbDumplimit=$opt{fsdbDumplimit}") if ($opt{fsdbDumplimit} ne "") ;
    }

    # convert -args to +args
    push (@{$opt{ncv_run_args}}, "+use_sas_tasks") if ($opt{sas}) ;
    push (@{$opt{ncv_run_args}}, "+finish_mask=$opt{finish_mask}") if ($opt{finish_mask} ne "") ;
    push (@{$opt{ncv_run_args}}, "+stub_mask=$opt{stub_mask}") if ($opt{stub_mask} ne "") ;
    push (@{$opt{ncv_run_args}}, "+TIMEOUT=$opt{rtl_timeout}") if ($opt{rtl_timeout}) ;
    push (@{$opt{ncv_run_args}}, "+wait_cycle_to_kill=$opt{wait_cycle_to_kill}") if ($opt{wait_cycle_to_kill} > 0) ;
    push (@{$opt{ncv_run_args}}, "+max_cycle=$opt{max_cycle}") if ($opt{max_cycle}) ;
    push (@{$opt{ncv_run_args}}, "+tg_seed=$opt{tg_seed}") ;
    push (@{$opt{ncv_run_args}}, "+vera_random_seed=$opt{tg_seed}") ;
    push (@{$opt{ncv_run_args}}, "+vera_pload=$opt{sys}_top.proj") if ((!$opt{dftvert}) and $opt{vera_run});
    push (@{$opt{ncv_run_args}}, "+vera_mload=veralist.vrl") if ($opt{dftvert});
    push (@{$opt{ncv_run_args}}, "+efuse_data_file=efuse.img") if ($opt{efuse_image_name} ne "") ;
    push (@{$opt{ncv_run_args}}, "+vera_diag_name=$opt{vera_diag_name}") if ($opt{vera_diag_name} ne "");
    push (@{$opt{ncv_run_args}}, "+vera_dummy_diag=$opt{vera_dummy_diag}") if ($opt{vera_dummy_diag} ne "");
    push (@{$opt{ncv_run_args}}, "+asm_diag_name=$opt{asm_diag_name}") if ($opt{asm_diag_name} ne "") ;
    push (@{$opt{ncv_run_args}}, "+sjm_diag_name=$opt{sjm_diag_name}") if ($opt{sjm_diag_name} ne "") ;
    push (@{$opt{ncv_run_args}}, "+tap_diag_name=$opt{tap_diag_name}") if ($opt{tap_diag_name} ne "") ;
    push (@{$opt{ncv_run_args}}, "+tpt_diag_name=$opt{tpt_diag_name}") if ($opt{tpt_diag_name} ne "") ;
    push (@{$opt{ncv_run_args}}, "+pci_diag_name=$opt{pci_diag_name}") if ($opt{pci_diag_name} ne "") ;
    push (@{$opt{ncv_run_args}}, "+image_diag_name=$opt{image_diag_name}") if ($opt{image_diag_name} ne "") ;
    push (@{$opt{ncv_run_args}}, "+efuse_image_name=$opt{efuse_image_name}") if ($opt{efuse_image_name} ne "") ;
    push (@{$opt{ncv_run_args}}, "+vera_config_name=$opt{vera_config_name}") if ($opt{vera_config_name} ne "") ;
    push (@{$opt{ncv_run_args}}, "+fast_boot") if ($opt{fast_boot}) ;
    push (@{$opt{ncv_run_args}}, "+ctu_mon_off") if ($opt{tcl_tap}) ;
    push (@{$opt{ncv_run_args}}, "+dv_root=$dv_root") ;

    foreach my $obj (@{$opt{vera_cov_obj}})
    {
      $obj =~ tr/A-Z/a-z/ ;
      push (@{$opt{ncv_run_args}}, "+$obj") ;
    }

if ($opt{cache}) 
{
    if ( ($opt{sys} eq "fc1") or ($opt{sys} eq "fc8") ) {
    system ( "/bin/cp diag* ef* fbdimm* fc*_top.proj mem.image symbol.tbl $cache_dir" ) ;
    } elsif ( ($opt{sys} eq "cmp1") or ($opt{sys} eq "cmp8") ) {
    system ( "/bin/cp diag* cmp*_top.proj mem.image symbol.tbl $cache_dir" ) ;
    }
    my $ncv_dir = $model_path . "/INCA_libs/worklib" ;
    opendir D, $ncv_dir or die (" Could not open directory \" $ncv_dir \" for reading!\n");
    my @d = grep {/^inca.*pak$/} readdir D ; closedir D;
    print "$prg: will run simulation using $ncv_dir/$d[-1] inside cache : \( " . $cache_dir .   " \)\n";
}

if ($opt{parallel}) {
    if ($opt{cache}) {
print "$prg: copying simulation snapshot to cache dir!\n";
    system ("/bin/cp -rf $model_path/INCA_libs $cache_dir") ; 
}
}
        if ($opt{cache}) {
    system ("/bin/cp $model_path/ncsim.args $cache_dir") ;
    system ("/bin/cp $model_path/cds.lib $cache_dir") ;
    system ("/bin/cp $model_path/hdl.var $cache_dir") ;
    chdir $cache_dir; 
    }
    else {
    system ("/bin/cp $model_path/ncsim.args .") ;
    system ("/bin/cp $model_path/cds.lib .") ;
    system ("/bin/cp $model_path/hdl.var .") ;
    }

if ($opt{parallel}) {
    if ($opt{cache}) {
    open F, "<cds.lib" or die "Can't open cds.lib for reading: $!\n" ; my @f=<F>; chomp @f; close F;
    system ("/bin/rm -rf cds.lib") ;
    open F, ">cds.lib" or die "Can't open cds.lib for writing: $!\n" ;
    foreach (@f) { s/^define\s(\w+)\s.*\/INCA_libs\/(\w+)$/define $1 INCA_libs\/$2/; 
    print F $_."\n"; }
    close F;
    }
}
else {
	print "$prg: No parallel run command specified, so will run all tests sequentially... !\n";
    open F, "<cds.lib" or die "Can't open cds.lib for reading: $!\n" ; my @f=<F>; chomp @f; close F;
    system ("/bin/rm -rf cds.lib") ;
    open F, ">cds.lib" or die "Can't open cds.lib for writing: $!\n" ;
    foreach (@f) { s/^define\s(\w+)\s.*\/INCA_libs\/(\w+)$/define $1 $opt{exe_dir}\/INCA_libs\/$2/; 
    print F $_."\n"; }
    close F;
}
   
	$ENV{LD_LIBRARY_PATH}=$model_dir."/".$opt{sys}."/".$opt{model_rel_name}.":".$ENV{LD_LIBRARY_PATH};
    if ( ($opt{sys} eq "fc1") or ($opt{sys} eq "fc8") ) {
	$ENV{LD_LIBRARY_PATH}=$ENV{DV_ROOT}."/verif/model/verilog/niu/sparse_mem_model/loadpli:".$ENV{LD_LIBRARY_PATH};
#	$ENV{LD_LIBRARY_PATH}=$ENV{DV_ROOT}.$ENV{LD_LIBRARY_PATH};
	}
    print "$prg: LD_LIBRARY_PATH: $ENV{LD_LIBRARY_PATH}\n";
    system ("echo \"LD_LIBRARY_PATH: \" $ENV{LD_LIBRARY_PATH} > ncsim.log" );

    my $cmd = "ncsim -f ncsim.args " ;
    unshift (@{$opt{ncv_run_args}},  $good_trap) if ($good_trap ne "") ;
    unshift (@{$opt{ncv_run_args}},  $bad_trap) if ($bad_trap ne "") ;

    my @vcs = grep{!/^\+vcs/} grep{/^\+/} @{$opt{vcs_run_args}};
    my @ncv = grep{/^\+/} @{$opt{ncv_run_args}};
    my ($vcs_only, $ncv_only, $intersect, $union) = list (\@vcs, \@ncv);
    push @{$opt{ncv_run_args}}, @$vcs_only;
    
    push (@{$opt{ncv_run_args}}, "-licqueue") ;
    my $runargs = join (" ", reverse(@{$opt{ncv_run_args}}));
    $runargs =~ s/"//go; #"
    $cmd .= $runargs;

    $ENV{FSDB_ENV_DUMP_SEQ_NUM} = 1 if ($opt{fsdb_glitch}) ; # turn on sequence dump
    $ENV{FSDB_ENV_MAX_GLITCH_NUM} = 0 if ($opt{fsdb_glitch}) ; # turn on glitch dump
    $ENV{VERA_LIBDIR} = "$model_path/vera";
    
    print "$prg: setenv VERA_LIBDIR $ENV{VERA_LIBDIR}\n";
    if (exists $ENV{LM_LICENSE_FILE})
    {
    print "$prg: setenv LM_LICENSE_FILE $ENV{LM_LICENSE_FILE}\n";
    }
    print "$prg: <<<<<<< (RUN directory) >>>>>>>   $ENV{PWD}\n";
    print "$prg: <<<<<<< (RUNTIME command) >>>>>>> $cmd\n";
    
      $main::vcs_start  = `date` ;
      print "$prg: ncsim_start $main::vcs_start" ;
	system ($cmd) ;
      $main::vcs_stop = `date` ; 
      print "$prg: ncsim_stop $main::vcs_stop" ;


    # kill sas no matter what

    if ($sas_pid != 0)
    {
      kill -9, $sas_pid ;
    }

    # kill tcl no matter what
    if ($tcl_pid != 0)
    {
      kill -9, $tcl_pid ;
    }

    # copy over debussy dump
if ($opt{debussy})
{
    if (<$opt{fsdbfile}*>) 
    {

      # Handling fsdbautoswitchdumpfile file names
      foreach (<$opt{fsdbfile}*>) {
        my $was = $_;
        s/\.fsdb_/_/;
        rename ($was, $_);
        if ($opt{fsdb2vcd}) {
          `fsdb2vcd $_ -o $_.vcd` ;
           die ("DIE. unable to convert $_ file to vcd\n") if ($?) ;
        } 
      }
    }

    if (<verilog.fsdb*>) 
    {

      # Handling fsdbautoswitchdumpfile file names
      foreach (<verilog.fsdb*>) {
        my $was = $_;
        s/\.fsdb_/_/;
        rename ($was, $_);
        if ($opt{fsdb2vcd}) {
          `fsdb2vcd $_ -o $_.vcd` ;
           die ("DIE. unable to convert $_ file to vcd\n") if ($?) ;
        } 
      }
    }
}

    for (@{$opt{post_process_cmd}}) {if(m/regreport -1/) {s/regreport/regreport -sim ncv/;}}

if ($opt{parallel}) {
    if ($opt{cache}) {
print "$prg: removing simulation snapshot from cache dir!\n" ;
system ( "/bin/rm -rf INCA_libs" ) ;
}
}

    if ($opt{cache}) {
      print "$prg: will now move all of the runtime generated files from cache to the original run directory. \n";
    system ( "/bin/cp -rf * $run_dir " ) ;
    chdir $run_dir ;
    system ( " /bin/rm -rf $cache_dir " ) ;
    }
	&post_process();
}


# run a test using the simv binary created from VCS

sub vcs_run
{
    # Check for vera diag existence if ntb_lib in use
    die ("DIE. No vera diag specified for NTB LIB bench (-ntb_lib option).\nUse NTB ALL method if not using openVera diags, or specify a -vera_dummy_diag as a default.")   
      if ($opt{vcs_use_ntb} && $opt{ntb_lib} && ($opt{vera_diag_name} eq "") && ($opt{vera_dummy_diag} eq ""));
 

    my $run_dir = $ENV{PWD} ;
    my $cache_dir;
        if ($opt{cache})
        {
    my $cache_dir_prefix = $ENV{TEMPDIR} ;
    if ( !( -d $ENV{TEMPDIR} ) ) { system ("mkdir -p $ENV{TEMPDIR}") ; }
    die ( "DIE. Could not access your temporary cache directory. \n") if ( !( -d $ENV{TEMPDIR} ) ) ;
    if (-d $cache_dir_prefix ) 
    {
    opendir D, $cache_dir_prefix or die (" Could not open directory \" ${cache_dir_prefix} \" for reading!\n");
    my @d = map { $cache_dir_prefix . "/" . $_  } grep { !/^\./ && -d "$cache_dir_prefix/$_" } readdir D ; closedir D;
    
    foreach (@d) {
        if ( ( time - ( (stat $_ )->mtime ) ) > ( 60*60*$cache_clean_time ) ) {
            system ( "/bin/rm -rf $_" ) ;
        }
    }
        
    $cache_dir = $cache_dir_prefix . "/OpenSPARC_T2___VCS___" . $opt{sys} . "___run" ;
    my $count = 0;
    while ( -d "${cache_dir}_${count}" ) { ++$count; }
    $cache_dir .= "_$count" ;
    system ("mkdir -p $cache_dir") ;
    die ("DIE. Could not create temporary cache sub-directory for VCS run ") if ($?) ;
    }
    }

    # copy the diff release over
    system ("cp -f $model_path/diff_rel.log .") if (-f "$model_path/diff_rel.log") ;

    # copy the flist over
    system ("cp -f $model_path/flist .") ;
    print "(debug) cp -f $model_path/flist $ENV{PWD}\n";
    die ("DIE. could not copy flist to $ENV{PWD}") if ($?) ;

    # pass the good trap and bad trap addresses to the testbench
    my $good_trap = "";
    my $bad_trap = "";

    if (($opt{asm_diag_name} ne "") or ($opt{image_diag_name} ne ""))
    {
      die ("DIE. could not find symbol.tbl file") if (!-f "symbol.tbl") ;

      my @good_trap_list = `grep -w good_trap symbol.tbl`;
      my @bad_trap_list = `grep -w bad_trap symbol.tbl`;
      my %good_trap_list ;
      my %bad_trap_list ;
      my @good_trap ;
      my @bad_trap ;

      if ($#good_trap_list >= 0)
      {
	foreach my $trap (@good_trap_list)
        {
          my ($tmp1, $va, $ra, $pa) = ($trap =~ /([\w_\.]+)\s+(\w+)\s+(\w+)\s+(\w+)/) ;
          $good_trap_list{$pa} = 1 ;
  	}

        foreach my $x (sort (keys (%good_trap_list)))
        {
          push (@good_trap, $x) ;
        }

        if ($#good_trap == 0) { $good_trap = "+good_trap=" . $good_trap[0] ; }
        else { $good_trap = "+good_trap=" . join (':', @good_trap) ; }
      }

      print "(debug) good_trap =$good_trap\n";

      if ($#bad_trap_list >= 0)
      {
	foreach my $trap (@bad_trap_list)
        {
          my ($tmp1, $va, $ra, $pa) = ($trap =~ /([\w_\.]+)\s+(\w+)\s+(\w+)\s+(\w+)/) ;
	  $bad_trap_list{$pa} = $pa;
	}

        foreach my $x (sort (keys (%bad_trap_list)))
        {
          push (@bad_trap, $x) ;
        }

        if ($#bad_trap == 0) { $bad_trap = "+bad_trap=" . $bad_trap[0] ; }
        else { $bad_trap = "+bad_trap=" . join (':', @bad_trap) ; }
      }
      print "(debug) bad_trap =$bad_trap\n";
    }

    # copy the 'traditional vera' project file over to the run area

    if ((! $opt{dftvert}) and $opt{vera_run} and !$opt{vcs_use_ntb})
    {
      `cp $model_path/vera/$opt{sys}_top.proj .` ;
      die ("DIE. could not copy .proj file to $ENV{PWD}") if ($?) ;
      `chmod +w $opt{sys}_top.proj`;
      die ("DIE. could not change permission of .proj file") if ($?) ;
      print "(debug) cp $model_path/vera/$opt{sys}_top.proj $ENV{PWD} \n";

      # append diag.vro after the fact
      if ($opt{vera_diag_name} ne "" or $opt{vera_dummy_diag} ne "")
      {
        push (@{$opt{vcs_run_args}}, "+vera_diag_path=$opt{vera_diag_path}") ;
        `ls *.vro >> $opt{sys}_top.proj` ;
        print "(debug) append *.vro to vera project file\n";
        die ("DIE. could not append *.vro to vera project file") if ($?) ;
      }
    }
 
    # add in switches for signal dumping

    if ($opt{vcd})
    {
      my $vcdfile = "";
      if ($opt{vcdfile} eq "")
      {
        $vcdfile = "verilog.vcd" ;
      } else
      {
        $vcdfile = $opt{vcdfile} ;
      }

      push (@{$opt{vcs_run_args}}, "+vcd") ;
      push (@{$opt{vcs_run_args}}, "-vcd $vcdfile") ;
      push (@{$opt{vcs_run_args}}, "+vcs+dumpon+".bigtime2plus($opt{start_dump})) if ($opt{start_dump} != 0) ;
      push (@{$opt{vcs_run_args}}, "+vcs+dumpoff+".bigtime2plus($opt{stop_dump})) if ($opt{stop_dump} != 0) ;
      print "(debug) vcd file=$vcdfile \n";
      print "(debug) vcd related vcs_run_args= @{$opt{vcs_run_args}}\n";
    }
    else
    {
      #push (@{$opt{vcs_run_args}}, "+vcs+dumpvarsoff") ;
      push (@{$opt{vcs_run_args}}, "+notimingcheck") ;
    }

    if ($opt{debussy})
    {
      my $fsdbfile = "";
      if ($opt{fsdbfile} eq "")
      {
        $fsdbfile = "verilog.fsdb" ;
      } else
      {
	$fsdbfile = $opt{fsdbfile} ;
      }

      push (@{$opt{vcs_run_args}}, "+debussy") ;
      push (@{$opt{vcs_run_args}}, "+fsdbfile=$fsdbfile") ;
      push (@{$opt{vcs_run_args}}, "+fsdb+dumpon+".bigtime2plus($opt{start_dump})) if ($opt{start_dump} != 0) ;
      push (@{$opt{vcs_run_args}}, "+fsdb+dumpoff+".bigtime2plus($opt{stop_dump})) if ($opt{stop_dump} != 0) ;
      push (@{$opt{vcs_run_args}}, "+fsdbDumplimit=$opt{fsdbDumplimit}") if ($opt{fsdbDumplimit} ne "") ;
    }

    # convert -args to +args
    push (@{$opt{vcs_run_args}}, "+use_sas_tasks") if ($opt{sas}) ;
    push (@{$opt{vcs_run_args}}, "+finish_mask=$opt{finish_mask}") if ($opt{finish_mask} ne "") ;
    push (@{$opt{vcs_run_args}}, "+stub_mask=$opt{stub_mask}") if ($opt{stub_mask} ne "") ;
    push (@{$opt{vcs_run_args}}, "+TIMEOUT=$opt{rtl_timeout}") if ($opt{rtl_timeout}) ;
    push (@{$opt{vcs_run_args}}, "+wait_cycle_to_kill=$opt{wait_cycle_to_kill}") if ($opt{wait_cycle_to_kill} > 0) ;
    push (@{$opt{vcs_run_args}}, "+max_cycle=$opt{max_cycle}") if ($opt{max_cycle}) ;

    push (@{$opt{vcs_run_args}}, "+initreg+$opt{tg_seed}") if ($opt{vcs_use_initreg}) ;
    push (@{$opt{vcs_run_args}}, "+tg_seed=$opt{tg_seed}") ;
    push (@{$opt{vcs_run_args}}, "+vera_random_seed=$opt{tg_seed}") if ($opt{vcs_use_vera} and !$opt{vcs_use_ntb}) ;
    push (@{$opt{vcs_run_args}}, "+ntb_random_seed=$opt{tg_seed}") if ($opt{vcs_use_ntb}) ;

    push (@{$opt{vcs_run_args}}, "+vcs+finish+".bigtime2plus($opt{vcs_finish})) if ($opt{vcs_finish}) ;
    push (@{$opt{vcs_run_args}}, "+vera_pload=$opt{sys}_top.proj") if ((!$opt{dftvert}) and $opt{vera_run} and !$opt{vcs_use_ntb}) ;
    push (@{$opt{vcs_run_args}}, "+vera_mload=veralist.vrl") if ($opt{dftvert} and !$opt{vcs_use_ntb}) ;
    push (@{$opt{vcs_run_args}}, "-l vcs.log") ;
    #push (@{$opt{vcs_run_args}}, "+vcs+nostdout") ;
    push (@{$opt{vcs_run_args}}, "-cm $opt{vcs_cm_args}") if ($opt{vcs_use_cm});
    push (@{$opt{vcs_run_args}}, "-cm_cond $opt{vcs_cm_cond}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_cond} ne ""));
    push (@{$opt{vcs_run_args}}, "-cm_hier $opt{vcs_cm_config}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_config} ne ""));
    push (@{$opt{vcs_run_args}}, "-cm_name $opt{vcs_cm_name}") if ($opt{vcs_use_cm});
    push (@{$opt{vcs_run_args}}, "-cm_dir $ENV{PWD}") if ($opt{vcs_use_cm});
    push (@{$opt{vcs_run_args}}, "+efuse_data_file=efuse.img") if ($opt{efuse_image_name} ne "") ;
    push (@{$opt{vcs_run_args}}, "+vera_diag_name=$opt{vera_diag_name}") if ($opt{vera_diag_name} ne "");
    push (@{$opt{vcs_run_args}}, "+vera_dummy_diag=$opt{vera_dummy_diag}") if ($opt{vera_dummy_diag} ne "");
    push (@{$opt{vcs_run_args}}, "+asm_diag_name=$opt{asm_diag_name}") if ($opt{asm_diag_name} ne "") ;
    push (@{$opt{vcs_run_args}}, "+sjm_diag_name=$opt{sjm_diag_name}") if ($opt{sjm_diag_name} ne "") ;
    push (@{$opt{vcs_run_args}}, "+tap_diag_name=$opt{tap_diag_name}") if ($opt{tap_diag_name} ne "") ;
    push (@{$opt{vcs_run_args}}, "+tpt_diag_name=$opt{tpt_diag_name}") if ($opt{tpt_diag_name} ne "") ;
    push (@{$opt{vcs_run_args}}, "+pci_diag_name=$opt{pci_diag_name}") if ($opt{pci_diag_name} ne "") ;
    push (@{$opt{vcs_run_args}}, "+image_diag_name=$opt{image_diag_name}") if ($opt{image_diag_name} ne "") ;
    push (@{$opt{vcs_run_args}}, "+efuse_image_name=$opt{efuse_image_name}") if ($opt{efuse_image_name} ne "") ;
    push (@{$opt{vcs_run_args}}, "+vera_config_name=$opt{vera_config_name}") if ($opt{vera_config_name} ne "") ;
    push (@{$opt{vcs_run_args}}, "+fast_boot") if ($opt{fast_boot}) ;
    push (@{$opt{vcs_run_args}}, "+ctu_mon_off") if ($opt{tcl_tap}) ;
    push (@{$opt{vcs_run_args}}, "+dv_root=$dv_root") ;

    foreach my $obj (@{$opt{vera_cov_obj}})
    {
      $obj =~ tr/A-Z/a-z/ ;
      push (@{$opt{vcs_run_args}}, "+$obj") ;
    }

    if ($opt{cache}) 
    {
    if ( ($opt{sys} eq "fc1") or ($opt{sys} eq "fc8") ) {
    system ( "/bin/cp diag* ef* fbdimm* fc*_top.proj mem.image symbol.tbl $cache_dir" ) ;
    } elsif ( ($opt{sys} eq "cmp1") or ($opt{sys} eq "cmp8") ) {
    system ( "/bin/cp diag* cmp*_top.proj mem.image symbol.tbl $cache_dir" ) ;
    }
    print "$prg: will run simulation using $model_path/simv inside cache : \( " . $cache_dir .   " \)\n";
    }

if ($opt{parallel}) 
{
    if ($opt{cache}) 
    {
print "$prg: copying simulation snapshot to cache dir!\n";
    system ("/bin/cp $model_path/simv $cache_dir") ;
    system ("/bin/cp -rf $model_path/simv.daidir $cache_dir") ; 
    if (-d "$model_path/simv.cm") { system ("/bin/cp -rf $model_path/simv.cm $cache_dir") ; }
    if (-d "$model_path/simv.vdb") { system ("/bin/cp -rf $model_path/simv.vdb $cache_dir") ; }
    }
}

    # run the command

    my $cmd = "" ;
    $cmd .= "collect " if ($opt{vcs_prof}) ;
    if ($opt{hcs_run}) { 
      $cmd = "tharas_sim -project $opt{sys} -simh_dir $model_path "; 
      $cmd .= join (" ", map{s/^"(.*?)"$/$1/;$1} @{$opt{hcs_run_args}}) ;
      $cmd .= " -other_simh_options \" ";
    } elsif ($opt{axis_run}) {
      $cmd = "axis_sim -project $opt{sys} -vlg_dir $model_path "; 
      $cmd .= join (" ", @{$opt{axis_run_args}}) ;
      $cmd =~ s/"//go;
      $cmd .= " -other_vlg_options \" ";
    } elsif ($opt{palladium_run}) {
      $cmd = "palladium_sim -project $opt{sys} -model_dir $model_path "; 
      $cmd .= join (" ", @{$opt{palladium_run_args}}) ;
      $cmd =~ s/"//go;
    } else {
        if ($opt{parallel}) {
             if ($opt{cache}) { $cmd .=  " simv " ; }
             else { $cmd .=  $opt{exe_dir} . "/simv " ; }
        } else {
	print "$prg: No parallel run command specified, so will run all tests sequentially... !\n";
    $cmd .= $opt{exe_dir} . "/simv " ;
        } }
    
    unshift (@{$opt{vcs_run_args}},  $good_trap) if ($good_trap ne "") ;
    unshift (@{$opt{vcs_run_args}},  $bad_trap) if ($bad_trap ne "") ;
    
    push (@{$opt{vcs_run_args}}, "+vcs+lic+wait") ;
    my $runargs = join (" ", reverse(@{$opt{vcs_run_args}}));
    $runargs =~ s/"//go; #"
    $cmd .= $runargs unless ($opt{palladium_run});
    $cmd .= " \" " if ($opt{axis_run}||$opt{hcs_run});

    $ENV{FSDB_ENV_DUMP_SEQ_NUM} = 1 if ($opt{fsdb_glitch}) ; # turn on sequence dump
    $ENV{FSDB_ENV_MAX_GLITCH_NUM} = 0 if ($opt{fsdb_glitch}) ; # turn on glitch dump

    $ENV{VERA_LIBDIR} = "$model_path/vera";
    print "$prg: setenv VERA_LIBDIR $ENV{VERA_LIBDIR}\n";

    if($proj_vars{has_denali}) {
      # figure out the location of denali from tre
      my $denali_home = (defined $ENV{DENALI_HOME})? $ENV{DENALI_HOME} :
                        "/import/datools/vendor/denali/v" ;
      $denali_home .= `configsrch denali_pcie /` ; 
      chomp ($denali_home) ;
      die ("DIE. Append _64bit to your denali version in your tver file to work with 64 bit vcs") if (($denali_home !~ /_64bit/) && ($opt{vcs_full64}));
      die ("DIE. Conflict between 64 bit denali version in your tver file and 32 bit vcs") if (($denali_home =~ /_64bit/) && (!$opt{vcs_full64}));
      $ENV{DENALI} = $denali_home ;
      print "$prg: setenv DENALI $ENV{DENALI}\n";
    }

    if (exists $ENV{HOME_0IN})
    {
    print "$prg: setenv HOME_0IN $ENV{HOME_0IN}\n";
    }
    if (exists $ENV{LM_LICENSE_FILE})
    {
    print "$prg: setenv LM_LICENSE_FILE $ENV{LM_LICENSE_FILE}\n";
    }
    if ($opt{cache}) { chdir $cache_dir; }
    print "$prg: <<<<<<< (RUN directory) >>>>>>>   $ENV{PWD}\n";
    #Donguk : added for vpd capture with size limit
    $cmd .=" +vpdfileswitchsize+10 ";
    print "$prg: <<<<<<< (RUNTIME command) >>>>>>>   $cmd\n";

      $main::vcs_start  = `date` ;
      print "$prg: vcs_start $main::vcs_start" ;
	system ($cmd) ;
      $main::vcs_stop = `date` ; 
      print "$prg: vcs_stop $main::vcs_stop" ;


    # kill sas no matter what

    if ($sas_pid != 0)
    {
      kill -9, $sas_pid ;
    }

    # kill tcl no matter what
    if ($tcl_pid != 0)
    {
      kill -9, $tcl_pid ;
    }

    # copy over debussy dump
if ($opt{debussy})
{
    if (<$opt{fsdbfile}*>) 
    {

      # Handling fsdbautoswitchdumpfile file names
      foreach (<$opt{fsdbfile}*>) {
        my $was = $_;
        s/\.fsdb_/_/;
        rename ($was, $_);
        if ($opt{fsdb2vcd}) {
          `fsdb2vcd $_ -o $_.vcd` ;
           die ("DIE. unable to convert $_ file to vcd\n") if ($?) ;
        } 
      }

    }

    if (<verilog.fsdb*>) 
    {

      # Handling fsdbautoswitchdumpfile file names
      foreach (<verilog.fsdb*>) {
        my $was = $_;
        s/\.fsdb_/_/;
        rename ($was, $_);
        if ($opt{fsdb2vcd}) {
          `fsdb2vcd $_ -o $_.vcd` ;
           die ("DIE. unable to convert $_ file to vcd\n") if ($?) ;
        } 
      }
    }
}
if ($opt{parallel}) 
{
    if ($opt{cache}) 
    {
print "$prg: removing simulation snapshot from cache dir!\n" ;
system ( "/bin/rm -rf simv simv.daidir" ) ;
if (-d "simv.cm") { system ( "/bin/rm -rf simv.cm" ) ; }
if (-d "simv.vdb") { system ( "/bin/rm -rf simv.vdb" ) ; }
}
}
    if ($opt{cache}) {
      print "$prg: will now move all of the runtime generated files from cache to the original run directory. \n";
      system ( "/bin/cp -rf * $run_dir " ) ;
      chdir $run_dir ;
    system ( " /bin/rm -rf $cache_dir " ) ;
    }
	&post_process();
}

#############################################################################}}}
# run pre processing scripts {{{
################################################################################

sub pre_process
{
  return if ($pre_process_done);

  $ENV{SIMS_LAUNCH_DIR} = $launch_dir;

  foreach my $cmd (@{$opt{pre_process_cmd}})
  {
    print "$prg: $cmd\n";

      $cmd =~ s/"(.*?)"/$1/ ;
      system ($cmd) ;
      print ("$prg: warning failed execution of $cmd\n") if ($?) ;
  }
  $pre_process_done = 1;
}

#############################################################################}}}
# run post processing scripts {{{
################################################################################

sub post_process
{
    my $pass = 0 ;

    $ENV{SIMS_LAUNCH_DIR} = $launch_dir;

    foreach my $cmd (@{$opt{post_process_cmd}})
    {
      print "$prg: $cmd\n";

        $cmd =~ s/"(.*?)"/$1/ ;
        system ($cmd) ;
        print ("$prg. warning failed execution of $cmd\n") if ($?) ;
    }
    if (-f "diag_pl.log")
    {
      open (DIAGPLLOG, "diag_pl.log") or die ("DIE. could not open diag_pl.log") ;
      my @diagpllog = <DIAGPLLOG> ;
      close (DIAGPLLOG) ;

      my @pass = grep (/PASS/, @diagpllog) ;
      $pass = 1 if ($#pass >= 0) ;
      my @fail = grep (/FAIL/, @diagpllog) ;
      $pass = 0 if ($#fail >= 0) ;
    }

    if (-f "tsotool.log")
    {
      open (TSOTOOLLOG, "tsotool.log") or die ("DIE. could not open tsotool.log") ;
      my @tsotoollog = <TSOTOOLLOG> ;
      close (TSOTOOLLOG) ;

      my @fail = grep (/fatal\serror/i, @tsotoollog) ;
      $pass = 0 if ($#fail >= 0) ;
    }

    # if this is a regression copy the results back to the result area

#    if ($opt{regress})
#    {
#
#      `gzip 0in_checksim.db` if (-f "0in_checksim.db") ; # Always compress this
#
#      # find out if diag passed
#
#      if ($pass)
#      {
#        # compress the files
#
#        `gzip hdlRun.log` if ($opt{gzip} and (-f "hdlRun.log")) ;
#        `gzip axis.log` if ($opt{gzip} and (-f "axis.log")) ;
#        `gzip vcs.log` if ($opt{gzip} and (-f "vcs.log") and ($opt{vcs_run}));
#        `gzip ncsim.log` if ($opt{gzip} and (-f "ncsim.log") and ($opt{ncv_run}));
#        `gzip sas.log` if ($opt{gzip} and (-f "sas.log")) ;
#        `gzip diag.exe` if ($opt{gzip} and (-f "diag.exe")) ;
#
#if ($opt{debussy} or $opt{vcd} ) 
#{
#        `gzip *.fsdb` if ($opt{gzip}); `gzip *.vcd` if ($opt{gzip});
#}
#        # copy back all relevant data
#
#        `cp 0in_checksim.db.gz $launch_dir` if (-f "0in_checksim.db.gz") ;
#        print ("$prg: warning could not copy 0in_checksim.db files back to $launch_dir\n") if ($?) ;
#        `cp 0in_covered.rpt $launch_dir` if (-f "0in_covered.rpt") ;
#        print ("$prg: warning could not copy 0in_covered.rpt files back to $launch_dir\n") if ($?) ;
#        `cp *.log.gz $launch_dir` ;
#        print ("$prg: warning could not copy *.log.gz files back to $launch_dir\n") if ($?) ;
#        `cp *.log $launch_dir` ;
#        print ("$prg: warning could not copy *.log files back to $launch_dir\n") if ($?) ;
#        `cp -r raw_coverage $launch_dir` ;
#        print ("$prg: warning could not copy vera coverage data back to $launch_dir\n") if ($?) ;
#        `cp -r ${opt{vcs_cm_name}}* $launch_dir` if ($opt{vcs_use_cm}) ;
#        print ("$prg: warning could not copy vcs coverage data back to $launch_dir\n") if ($?) ;
#        `cp -r ${opt{vcs_cm_name}}* ${model_path}/coverage/verilog` if ($opt{vcs_use_cm}) and ($opt{vcs_cm_merge}) ;
#        print ("$prg: warning could not copy vcs coverage data back to ${model_path}/coverage/verilog\n") if ($?) ;
#        if ($opt{tap_diag_name} ne "")
#        {
#          `cp diag.tap tap.cmd $launch_dir` ;
#          print ("$prg: warning could not copy tap diag file back to $launch_dir\n") if ($?) ;
#        }
#
#        if ($opt{asm_diag_name} ne "")
#        {
#          `cp *.s *.tbl *.ev *.exe.gz $launch_dir` ;
#          print ("$prg: warning could not copy assembly files back to $launch_dir\n") if ($?) ;
#        }
#        
#        if ($opt{sjm} or ($opt{sjm_diag_name} ne "") or $opt{pci} or ($opt{pci_diag_name} ne ""))
#        {
#          `cp *.cmd $launch_dir` ;
#          print ("$prg: warning could not copy sjm/pci command files back to $launch_dir\n") if ($?) ;
#        }
#
#        if ($opt{efc} or ($opt{efuse_image_name} ne ""))
#        {
#          `cp efuse.img $launch_dir` ;
#          print ("$prg: warning could not copy efuse image file back to $launch_dir\n") if ($?) ;
#        }
#
#        if ($opt{vera_diag_name} ne "")
#        {
#          `cp *.vr *.vrpal $launch_dir` ;
#          print ("$prg: warning could not copy vera diag back to $launch_dir\n") if ($?) ;
#        }
#
#        if ($opt{tpt_diag_name} ne "")
#        {
#          `cp *.tpt $launch_dir` ;
#          print ("$prg: warning could not copy tpt diag back to $launch_dir\n") if ($?) ;
#        }
#      }
#      else
#      {
#          `cp -r * $launch_dir` ;
#        print ("$prg: warning could not copy files back to $launch_dir\n") if ($?) ;
#      }
#    }

    my $c=0;
    if ($opt{vcs_run}) {
        my $l= `grep '^Time:' vcs.log`;
        my @m=split /\n/s, $l;
        ($c=$m[-1]) =~ s/^Time:\s(\d+)\s[fp]s/$1/ ;
    }
    elsif ($opt{ncv_run}) {
	my $l = `grep 'baseUtilsClass' ncsim.log`;
        my @m=split /\n/s, $l;
        ($c=$m[-1]) =~ s/\s*(\d+):.*/$1/ ;
    }
    if ( ($opt{vcs_run}) or ($opt{ncv_run}) ) 
    {
	my $count=0;
        if ( ( -f "vcs.log" ) && ($opt{vcs_run}) ) {
	    chomp( ($count)= `grep -c PASS vcs.log`) ; }
        elsif  ( ( -f "ncsim.log" ) && ($opt{ncv_run}) ) {
        chomp( ($count)= `grep -c PASS ncsim.log`); }
	    $pass = 1 if ($count > 0);
    }
    if ($opt{vcs_run} or $opt{ncv_run})
    {
      my $status = "f" ;
      $status = "p" if ($pass) ;
      &update_db ($c, $main::vcs_start, $main::vcs_stop, $status) ;
    }
}

#############################################################################}}}
# launch sas{{{
################################################################################

sub sas_run
{
    # first clean up the diag area
    `rm -rf sas.log` ;
    die ("DIE. could not clean up diag run area") if ($?) ;

    my $csocket = 0 ;
    
    my $def_sas_str = join(" ", grep (/^-D/, @{$opt{sas_run_args}})) ;
    my $opt_sas_str = join(" ", grep (!/^-D/, @{$opt{sas_run_args}})) ;

    $def_sas_str .= " -DFAST_BOOT " if ($opt{fast_boot}) ;

    # remove socket pli flag
    `rm -rf pli-socket-opened` ;

    # create socket numbers for rtl-sas run
    print "$prg: creating sas sockets\n" ;

    if ($opt{vcs_run} or $opt{ncv_run})
    {
      $def_sas_str .= " -DRTL ";
      $def_sas_str .= " -DVSOCKET=0 ";
      my $tmp = $$ & 0x1fff;
      $csocket = $tmp + 10000 ; # initial socket port to try out
      $tmp = $tmp + 11000 ; # this is an upper bound on trying to find a port

      my $proto = getprotobyname('tcp');
      socket(Server, PF_INET, SOCK_STREAM, $proto) || die "DIE. Could not open socket file handle" ;
      while ((!bind(Server, sockaddr_in($csocket, INADDR_ANY))) and ($csocket < $tmp)) {$csocket++;}
      close (Server) ;

      die "DIE. Could not find a free port for socket" if ($csocket == $tmp) ;

      $def_sas_str .= " -DCSOCKET=$csocket ";
      push (@{$opt{vcs_run_args}}, "+csocket=$csocket") if ($opt{vcs_run} );
      push (@{$opt{ncv_run_args}}, "+csocket=$csocket") if ($opt{ncv_run} );
    }
    else
    {
      $def_sas_str .= " -DMEM_DISABLE ";
      $def_sas_str .= " -DMAX_CYCLE=$opt{max_cycle} " if ($opt{max_cycle}) ;
      
      my $finish_mask = sprintf ("%b", hex ($opt{finish_mask})) ;
      my $finish_count = 0 ;
      foreach my $x (split (//, $finish_mask)) { $finish_count++ if ($x eq '1') } ;
      $def_sas_str .= " -DFINISH_COUNT=$finish_count " ;
    }

    my $cmd = "$proj_vars{sasconfig} $def_sas_str" ;
    print "$prg: $cmd\n" ;
    system ($cmd) ;
    die ("DIE. could not invoke $proj_vars{sasconfig}") if ($?) ;

    print "$prg: starting $proj_vars{sas}\n" ;
    $cmd = "$proj_vars{sas} $opt_sas_str " ;
    print "$prg: $cmd\n";

    if ($opt{vcs_run} or $opt{ncv_run} or $opt{hcs_run} or $opt{axis_run} or $opt{palladium_run})
    {
      $sas_pid = fork () ;

      if ((defined $sas_pid) and ($sas_pid == 0)) 
      {
        setpgrp (0, $$) ;
        if ($opt{saslog}) {
          system ("$cmd > sas.log 2>&1") ;
        } else {
          system ("$cmd > /dev/null 2>&1") ;
        }
        exit (0) ;
      }
      elsif (!defined $sas_pid)
      {
        die ("DIE. could not fork off the sas process") ;
      }

      # wait until sas has started running before proceeding

      my $timeout_counter = 0 ;

      while (! -e "pli-socket-opened")
      {
        print "$prg: waiting for pli socket to be opened (pid=$sas_pid)\n" ;

        $timeout_counter++ ;

        if ($timeout_counter > $sas_timer)
        {
          die ("DIE. sas socket open timeout") ;
        }
    
        sleep 4;
      }
    }
    else
    {
      if ($opt{regress})
      {
        system ("$cmd > sas.log 2>&1") ;
        die ("DIE. simics exited with an error") if ($?) ;
      }
      else
      {
        if ($opt{saslog})
        {
          system ("$cmd > sas.log 2>&1") ;
          die ("DIE. simics exited with an error") if ($?) ;
        }
        else
        {
          system ($cmd) ;
        }
      }
    }
}

#############################################################################}}}
# launch tcl_tap {{{
################################################################################

sub tcl_tap_run
{
    # first clean up the diag area
    `rm -f tcl.log expect_log_file tcl2sim.log sim2tcl.log done` ;
    die ("DIE. could not clean up diag run area") if ($?) ;

    # build JTAG low level commands in sub-directory
    my $jtag_log	= "jtag.log";
    my $tcl_log		= "tcl.log";
    my $pwd		= File::Spec->rel2abs( "." );
    my $cmd_dir		= File::Spec->catdir( $pwd, "jtag_cmds" );
    my $tap_dir		= File::Spec->canonpath( "$dv_root/verif/env/tap" );
    my $tap_src_dir	= File::Spec->catdir( $tap_dir, "src" );
    my $makefile	= File::Spec->catfile( $tap_src_dir, "Makefile" );
    if (! -d $cmd_dir ) {
	`mkdir $cmd_dir`;
	die ( "DIE. Could not create $cmd_dir to run tcl tap code" ) if ($?);
    }
    chdir $cmd_dir;
    print "$prg: making JTAG low level commands in $cmd_dir\n" ;
    my $cmd = "gmake -f $makefile VPATH=$tap_src_dir ";
    call_program( $cmd, $jtag_log );
    chdir $pwd;

    print "$prg: starting expect/tcl\n" ;
    my $tcl_tap_diag;
    if ( $opt{tcl_tap_diag} ) {
	my $diagdir		= $tap_src_dir;
	my @diags;
	@diags	 	= `find $diagdir -name $opt{tcl_tap_diag} -print`;
	if ( (scalar @diags) > 0 ) {
	    $tcl_tap_diag 	= $diags[0];
	} else {
	    die "DIE. could not find $opt{tcl_tap_diag} under $diagdir\n";
	}
	$tcl_tap_diag 	= File::Spec->canonpath( $tcl_tap_diag );
    } # if $opt{tcl_tap_diag}
    else {
	$tcl_tap_diag = File::Spec->catfile( $tap_src_dir, "main_niagara.exp" );
    }
    $cmd = "" ;
    $cmd .= "xterm -sb -sl 1000 -e " ;
    my $expect_cmd = "";
    $expect_cmd .= "expect " ;
    $expect_cmd .= " $tcl_tap_diag ";
    $cmd .= $expect_cmd;
    print "$prg: $cmd\n";

    if ( ( $opt{vcs_run}) or ($opt{ncv_run}) )
    {
      $tcl_pid = fork () ;
      if ((defined $tcl_pid) and ($tcl_pid == 0)) 
      { # child
        setpgrp (0, $$) ;
	# add path to JTAG commands just built
	$ENV{PATH}	= "${cmd_dir}:$ENV{PATH}";
	call_program( $cmd, $tcl_log );
        exit (0) ;
      }
      elsif (!defined $tcl_pid)
      {
        die ("DIE. could not fork off the tcl process") ;
      }
    }
    else
    {
      if ($opt{regress})
      {
	# add path to JTAG commands just built
	$ENV{PATH}	= "${cmd_dir}:$ENV{PATH}";
	call_program( $cmd, $tcl_log );
        die ("DIE. expect/tcl exited with an error") if ($?) ;
      }
      else
      {
	  # add path to JTAG commands just built
	  $ENV{PATH}	= "${cmd_dir}:$ENV{PATH}";
	  call_program( $cmd, $tcl_log );
          die ("DIE. expect/tcl exited with an error") if ($?) ;
      }
    }
} # tcl_tap_run

#############################################################################}}}
# open up the config file and get the arguments for this sys {{{
################################################################################

sub get_config
{
  my $sys_name = shift ;
  my $argvref = shift ;

  my $confcppargs = join(' ', @{$opt{config_cpp_args}});
  print "$prg: using config file $sims_config ($confcppargs)\n" ;
  open (SIMS_CONFIG, "bw_cpp -P -B $confcppargs -undef -I$dv_root/$proj_vars{sims_config} $sims_config | ") or die "DIE. Could not open $sims_config" ;
  my @sims_config_file = <SIMS_CONFIG> ;
  close (SIMS_CONFIG) ;

  my $sims_config_file = join ('', @sims_config_file) ;
  #Debug
  #print "(In get_config) sims_config_file = $sims_config_file\n";

  ## extract the part staring with <cmp1> ending with </cmp1>
  my ($body) = ($sims_config_file =~ /<\s*$sys_name\s*>\s+(.*?)<\s*\/$sys_name\s*>/ogis) ;
  #Debug
  #print "(In get_config) body = $body\n";

  die "DIE. could not find $sys_name in $sims_config" if (!defined $body) ;

  my @argv = split (/\n/, $body) ;
  
  foreach my $x (@argv)
  {
    next if ($x =~ /^\s*$/o);  # Discard empty lines
    $x =~ s/^\s*|\s*$// ;      # Discard leading/trailing spaces
    $x =~ s/(.*?)\s*$/$1/ ;
    print "$prg: processing backtick(s) in arg \"$x\"\n" if($x=~/`/);
    while ($x =~ /`(.*?)`/o) {
        chomp(my $ex = `$1`);
        print "$prg: expanding backtick \`$1\` => $ex\n" ;
        $x =~ s/(`.*?`)/$ex/;
        print "$prg: resolved backtick(s) in arg to \"$x\"\n" if ($x !~ /`/);
    }
    #print "(In get_config)  add $x into ARGV\n";
    unshift (@{$argvref}, $x) ;
  }
}

#############################################################################}}}
# Freeze tool versions: {{{
#       Given a run_dir, make copy of all tver files.
#       Construct an iver file pointing to these tvers
#       Return string which is new value of env variable: TRE_SEARCH
################################################################################

sub freeze_tre
{
  my $run_dir = shift ;
  my $tre_search = "";

  my $TRE_SEP = '/';

  if ( -d "$run_dir/tre" and -f "$run_dir/tre/sims.iver" ) {
    # recursive call.  tre_search already filled in
    # $tre_search = "$run_dir/tre/sims.iver"    if $opt{use_iver} eq "";
    return $tre_search;
  }

    my $entry = $TRE_SEP;

    ## $! = -1;
    die "$prg: \$TRE_SEARCH not set!\n" unless exists $ENV{TRE_SEARCH};
    die "$prg: \$TRE_SEARCH set to blank!\n" unless $ENV{TRE_SEARCH} =~ /\S/;

    my @ivers = split ' ', $ENV{TRE_SEARCH};
    my @tvers;
    my %seen_tver;
    foreach my $iver (@ivers) {
      print "CHECK IVER: $iver\n" if $opt_debug;
      my @tvers_from_iver = get_tvers_from_iver($iver);
      foreach my $tver (@tvers_from_iver) {

       print "(in freeze_tre) $tver\n" ;
        if(not exists $seen_tver{$tver}) {
          push @tvers, $tver;
          $seen_tver{$tver} = 1;
          ## $! = 2;
          die "$prg: Cannot find tver '$tver'!\n" unless -e $tver;
        }
      }
    }

    ## at this point, all the tvers are now collected and in order
    ## we need to copy them to files in the run_dir directory
    ## and construct an iver that points to them.
    `mkdir -p $run_dir/tre`;
    die "$prg: cannot create $run_dir/tre: $!\n" if ($?);
    my $tnum = 0;
    my $iver = $run_dir . "/tre" . "/sims.iver";
    $tre_search = File::Spec->rel2abs( $iver ); # clean up path
    my $dest = "";
    local (*IVER);
    open IVER, "> $iver" or die "$prg: could not write to $iver: $!\n";
    foreach my $tver ( @tvers ) {
        $dest = sprintf "%s_%0d", "$run_dir/tre/sims.tver", $tnum;
        $dest = File::Spec->rel2abs( $dest );   # clean up path, if relative
        `cp $tver $dest`;
        die "$prg: could not copy tver: $tver: to $dest\n" if ($?);
        printf IVER "%s\n", $dest;
        $tnum++;
    }
    close IVER;

    return $tre_search;

} # freeze_tre

############################################################################}}}
# Misc routines {{{
#
sub expand_filename {
  my $filename = shift;

  $filename =~ s/^\s+//;
  # twiddle expansion
  $filename =~
    s{ ^ ~ ([^/]*) }
      { $1 ? (getpwnam($1))[7] :
          ( $ENV{HOME} || $ENV{LOGDIR} || (getpwuid($>))[7]) }ex;
  # environment variable expansion
  $filename =~ s/\${*(\w+)}*/expand_env($1)/ge;

  return $filename;
}

###############################################################################

sub expand_env {
  my $envvar = shift;

  return $ENV{$envvar} if exists $ENV{$envvar};
  die "$prg: Environment variable '$envvar' not defined!\n";
}

###############################################################################

sub get_tvers_from_iver {
  my $iver = shift;
  local (*IVER);

  $iver = expand_filename($iver);
  return unless -e $iver;
  open IVER, "<$iver" or die "$prg:  Can't open '$iver': $!\n";
  my @tvers;
  while(<IVER>) {
    chomp;
    s/\#.*$//;
    $_ = expand_filename($_);
    next unless /\S/;
    print "  -- tver file: $_\n" if $opt_debug;
    push @tvers, $_;
  }
  return @tvers;
}

#############################################################################}}}
# assemble diag {{{
################################################################################

sub assemble_diag
{
    # first clean up the diag area
    `rm -rf diag.pal diag.s diag.pl diag.exe mem.image diag.ev symbol.tbl` ;
    die "DIE. could not clean up assembly diag run area"  if ($?) ;

    print "$prg: asm_diag_name=" . $opt{asm_diag_name} . "  asm_diag_path=" . $opt{asm_diag_path} . " asm_diag_root=" . @{$opt{asm_diag_root}} . "\n" if $opt_debug  ;
    print "(debug) asm_diag_name=" . $opt{asm_diag_name} . "  asm_diag_path=" . $opt{asm_diag_path} . " asm_diag_root=" . @{$opt{asm_diag_root}} . "\n";

    # find diagnostic
    my $diag_full_path = &find_diag_path ($opt{asm_diag_name}, $opt{asm_diag_path}, $opt{asm_diag_root}) ;
  
    my $diag_name ;
    if ($opt{asm_diag_name} =~ /\.pal/) { $diag_name = "diag.pal" ; }
    elsif ($opt{asm_diag_name} =~ /\.s\.gz/) { $diag_name = "diag.s.gz" ; }
    else { $diag_name = "diag.s" ; }

    # copy diagnostic to run area
    `cp $diag_full_path $diag_name` ;
    die ("DIE. unable to copy assembly diag to $ENV{PWD}") if ($?) ;
    `chmod +w $diag_name` ;
    die ("DIE. unable to permission of assembly diag") if ($?) ;

    # gunzip if needed
    if ($opt{asm_diag_name} =~ /\.s\.gz/)
    {
      `gzip -d diag.s.gz` ;
      die ("DIE. unable to gunzip assembly diag") if ($?) ;
      $diag_name = "diag.s" ;
    }
 
    $ENV{ASM_DIAG_NAME} = $opt{asm_diag_name};

    # pre process if needed
    &pre_process ;

    # extract sims options from diag.s
    if ($diag_name =~ /\.s/)
    {
      open (DIAGIN, "< diag.s") or die "DIE. Could not open diag.s" ;

      while (<DIAGIN>)
      {
        my $line = $_ ;
  
        if ($line =~ /^\!SIMS\+ARGS\:/)
        {
          my (@plusargs) = split (/\s+/, $line) ;
          shift (@plusargs) ;
          push (@ARGV, @plusargs) ;
          print "$prg: Found sims arguments in diag.s: @plusargs\n" ; 
          parse_args ("dummy", 0) ;
        }
      }

      close (DIAGIN) ;
    }

    # assemble
    push (@{$opt{midas_args}}, "-DFAST_BOOT") if ($opt{fast_boot}) ;
    push (@{$opt{midas_args}}, "-diag_root=$dv_root") ;
    push (@{$opt{midas_args}}, "-DTG_SEED=$opt{tg_seed}") if ($opt{midas_use_tgseed}) ;
    push (@{$opt{midas_args}}, "-pal_diag_args=-seed=$opt{tg_seed}") if ($opt{pal_use_tgseed}) ;
    push (@{$opt{midas_args}}, "$diag_name") ;

    print "$prg: assembling diag\n" ;
    my $cmd = "midas " ;
    $cmd .= join (" ", @{$opt{midas_args}}) ;
    print "$prg: $cmd\n";

    my $waitstatus = call_program($cmd, "midas.log");
    die ("DIE. midas compilation error") if ($waitstatus) ; 
    exit (0) if ($opt{midas_only}) ;
}

#############################################################################}}}
# call_program - runs a program, tee's the output to a log, and returns exit {{{
# status
################################################################################

sub call_program {
  my $cmd  = shift;
  my $file = shift;

  local (*PROGFH, *TEE);
  open( PROGFH,  "$cmd 2>&1 |" ) or die "Can't run '$cmd': $!\n";
  
  open( TEE, ">$file" ) or die "Can't open '$file': $!\n";
  
  my $old_fh = select(TEE);
  $| = 1;
  select($old_fh);

  while(<PROGFH>) {
    print;
    print TEE;
  }

  close( TEE );

  close( PROGFH );
  return $?;
}

#############################################################################}}}
# copy diag image{{{
################################################################################

sub copy_image
{
    # first clean up the diag area
    `rm -rf diag.pal diag.s diag.pl diag.exe mem.image diag.ev symbol.tbl` ;
    die ("DIE. could not clean up image run area")  if ($?) ;
    
    my $image_full_path = &find_diag_path ($opt{image_diag_name}, $opt{image_diag_path}, $opt{image_diag_root}) ;

    `cp $image_full_path mem.image` ;
    die ("DIE. unable to copy memory image into $ENV{PWD}") if ($?) ;
    `chmod +w mem.image` ;
    die ("DIE. unable to change permission of memory image") if ($?) ;

    $image_full_path =~ s/\.image/\.ev/ ;
    `cp $image_full_path diag.ev` ;
    die ("DIE. unable to copy diag event file into $ENV{PWD}") if ($?) ;
    `chmod +w diag.ev` ;
    die ("DIE. unable to change permission of diag event file") if ($?) ;

    $image_full_path =~ s/\.ev/\.tbl/ ;
    `cp $image_full_path symbol.tbl` ;
    die ("DIE. unable to copy symbol table file into $ENV{PWD}") if ($?) ;
    `chmod +w symbol.tbl` ;
    die ("DIE. unable to change permission of symbol table") if ($?) ;

    # pre process if needed
    &pre_process ;
}

#############################################################################}}}
# copy efuse image {{{
################################################################################

sub copy_efuse_image
{
    # first clean up the diag area
    `rm -rf efuse.img` ;
    die ("DIE. could not clean up efuse image from run area")  if ($?) ;
    
    my $efuse_image_full_path = &find_diag_path ($opt{efuse_image_name}, $opt{efuse_image_path}, $opt{efuse_image_root}) ;

    `cp $efuse_image_full_path efuse.img` ;
    die ("DIE. could not copy efuse image to $ENV{PWD}") if ($?) ;
    `chmod +w efuse.img` ;
    die ("DIE. could not change permission of efuse image") if ($?) ;
}

#############################################################################}}}
# generate efuse image {{{
################################################################################

sub generate_efuse_image
{
    # first clean up the diag area
    `rm -rf efuse.img` ;
    die ("DIE. could not clean up efuse image from run area")  if ($?) ;

    my $cmd = "efcgen.pl " ;
    $cmd .= join (" ", @{$opt{efc_args}}) ;
    $cmd .= " -seed=$opt{tg_seed} " ;   
    print "$prg: $cmd\n" ; 

    system ($cmd) ;
    die ("DIE. failed efuse image generation") if ($?) ;
   
    `chmod +w efuse.img` ;
    die ("DIE. could not change permission of efuse image") if ($?) ;
}

#############################################################################}}}
# compile dftvert vera diag {{{
################################################################################

sub compile_dftvert_diag
{
    # first clean up the diag area
    `rm -rf diag.vr diag.vrpal diag.vro` ;
    die ("DIE. could not clean up dftvert vera diag run area") if ($?) ;

    my $vera_full_path = &find_diag_path ($opt{vera_diag_name}, $opt{vera_diag_path}, $opt{vera_diag_root}) ;

    ## ($opt{vera_diag_path}) = $vera_full_path =~ m/(.*)\//o;

    if ( $vera_full_path =~ /\.vrpal$/ ) {	# pal diag to be expanded
	`cp -f $vera_full_path diag.vrpal` ;
	die ("DIE. failed dftvert vera pal diag copy to $ENV{PWD}") if ($?) ;
        my $pal_opts = join (" ", @{$opt{vera_pal_diag_args}}) ;
        $pal_opts .= " -seed=$opt{tg_seed} " if ($opt{pal_use_tgseed}) ;
	`pal $pal_opts -o diag.vr diag.vrpal`;
	die ("DIE. failed dftvert vera pal diag expansion to diag.vr") if ($?) ;
    } else {
	`cp -f $vera_full_path diag.vr` ;
	die ("DIE. failed dftvert vera diag copy to $ENV{PWD}") if ($?) ;
    }
    `chmod +w diag.vr` ;
    die ("DIE. failed to change permission of dftvert vera diag") if ($?) ;

    # pre process if needed
    &pre_process ;

    print "$prg: Compiling dftvert vera diag\n" ;
    my $cmd = "/import/bw/tools/release/tools/dftvert,1.0 ";
    $cmd .= "-srcdir $opt{env_base}/vera " ;
    $cmd .= "-diagfile diag.vr " ;
    $cmd .= "-resultdir . " ;
    $cmd .= "-cmpdiag" ;
    print "$prg: $cmd\n" ;
    system ($cmd) ;
    die ("DIE. failed dftvert vera diag compilation") if ($?) ;
}

#############################################################################}}}
# compile vera/NTB diag {{{
# for NTB, the diag and bench are compiled together into one libtb.so file.
# If vera_dummy_diag is specified and vera_diag_name is not, the dummy will
# be compiled and used. Normally a diag would be specified.
################################################################################

sub compile_vera_diag
{
    my $cmd;
    my $vera_full_path; 
    my $old_signature = 0;

    # NTB all-in-one complie has no diag so always bail even if user specifies one.
    if ($opt{vcs_use_ntb} && !$opt{ntb_lib}) {
      print("$prg: Ignoring your Vera diag! Do not use NTB ALL method if you have diags!\n");
      return;
    }

    # get signature of previous diag.vr file if it exists.
    # need this for NTB diags. If diag has not changed, the makefile won't
    # remake the testbench pointlessly.
    $old_signature = md5(`cat diag.vr`) if ($opt{vcs_use_ntb} && -e "diag.vr");

    # first clean up the run dir
    print "(debug) rm -rf diag.vr diag.vrpal diag.vro\n";
    `rm -rf diag.vr diag.vrpal diag.vro` ;
    die ("DIE. could not clean up vera diag run area") if ($?) ;

    # Override the vera diag name if not specified and dummy is specified
    if (($opt{vera_dummy_diag} ne "" ) and ($opt{vera_diag_name} eq "")){
      print "$prg: using the vera dummy diag $opt{vera_dummy_diag}\n";
      # Dummy diag is expected to have FULL PATH
      $vera_full_path = $opt{vera_dummy_diag};
    } else {
      # Find diag if dummy diag not specified and diag is ..
      $vera_full_path = &find_diag_path ($opt{vera_diag_name},
            $opt{vera_diag_path}, $opt{vera_diag_root});
    }


    if ( $vera_full_path =~ /\.vrpal$/ ) {	# pal diag to be expanded
      `cp -f $vera_full_path diag.vrpal` ;
      print "(debug) cp -f $vera_full_path diag.vrpal\n";
      die ("DIE. failed vera pal diag copy to $ENV{PWD}") if ($?) ;
      my $pal_opts = join (" ", @{$opt{vera_pal_diag_args}}) ;
      $pal_opts .= " -seed=$opt{tg_seed} " if ($opt{pal_use_tgseed}) ;
      `pal $pal_opts -o diag.vr diag.vrpal`;
      print "(debug) pal $pal_opts -o diag.vr diag.vrpal\n";
      die ("DIE. failed vera pal diag expansion to diag.vr") if ($?) ;
    } else {
      `cp -pf $vera_full_path diag.vr` ; # preserve mod time (-p)
      print "(debug) cp -pf $vera_full_path diag.vr\n";
      die ("DIE. failed vera diag copy to $ENV{PWD}") if ($?) ;
    }
    `chmod +w diag.vr` ;
    die ("DIE. failed to change permission of vera diag") if ($?) ;

    # pre process if needed
    &pre_process ;

    # Add defines for cov objects as diag args..
    foreach my $obj (@{$opt{vera_cov_obj}})
    {
      $obj =~ tr/a-z/A-Z/ ;
      print "(debug) -D$obj has been added to vera_diag_args\n";
      push (@{$opt{vera_diag_args}}, "-D$obj") ;
    }

    # ntb_lib, does NTB build of the diag AND bench together
    if ($opt{vcs_use_ntb} && $opt{ntb_lib}) {
      # stop dummy_diag from wastefully building during the regression build!
      if (!$opt{vcs_run}) {
        print "$prg: Not building NTB diag due to -novcs_run\n";
        return;
      }

      mkdir "ntb" if (! -d "ntb");
      chdir "ntb" or die ("DIE. Can't cd to $ENV{PWD}/ntb") ;

      # construct gmake command
      $cmd = "gmake -f $opt{env_base}/vera/Makefile ";
      if ($opt{vcs_use_ntb} && $opt{ntb_lib}) {
        if ($opt{vcs_use_cli}) {
          $cmd .= " VCS_USE_CLI=\"+cli -line\" ";
        } elsif ($opt{vcs_use_ucli}) {
          $cmd .= " VCS_USE_CLI=\"-debug_all\" ";
        }

        if ($opt{vcs_use_fsdb} or $opt{vcs_use_vcsd}) {
          $cmd .= " VCS_USE_VCSD=+vcsd ";
        }
      }
	push (@{$opt{vera_build_args}}, "+ver+lic+wait") ;
      $cmd .= join (" ", @{$opt{vera_build_args}}) ;
      $cmd .= " NTB_DIAG_ARGS=" . join (" ", @{$opt{vera_diag_args}}) . "" ;

      $ENV{VERA_LIBDIR} = "$ENV{PWD}";
      print "$prg: setenv VERA_LIBDIR $ENV{VERA_LIBDIR}\n";
      $cmd .= " VERA_LIBDIR=. NTB_DIAG=diag.vr USE_NTB_LIB=1 ";

      # do a clean of the diag/lib build dir if -vera_clean
      if ($opt{vera_clean})
      {
        print "$prg: $cmd clean\n" ;
        system ("$cmd clean") ;
        die ("DIE. failed cleaning NTB lib build in $ENV{PWD}") if ($?) ;
      }

      `rm -f diag.vr` if (-e "diag.vr");
      `ln -s ../diag.vr diag.vr`;

      # touch diagChanged if prev and current diag signatures do not match
      # or if no diagChanged file exists at all. Makefile looks at diagChanged.
      # If user re-runs same diag, we don't want to rebuild bench pointlessly.
      if (-e "diagChanged") {       
        `touch diagChanged` if (-e "diag.vr" && $old_signature ne md5(`cat diag.vr`));
      } else {
        `touch diagChanged`;
      }

      $cmd .= " ntb_diag";
      push (@{$opt{vcs_run_args}}, "+ntb_load=ntb/libtb.so");
      print "$prg: Compiling NTB openVera diag plus bench in $ENV{PWD}\n" ;

    } else {
      # the Makefile should be doing this!!!
      $cmd = "vera -cmp -max_error 5 -q -I $model_path/vera ";
      $cmd .= join (" ", @{$opt{vera_diag_args}}) ;
      $cmd .= " diag.vr";
      print "$prg: Compiling vera diag in $ENV{PWD}\n" ;
    }

    print "$prg: $cmd\n" ;

      system ($cmd) ;
      if ($?) {
        chdir ".." if ( $opt{vcs_use_ntb} && $opt{ntb_lib} );
        die ("DIE. failed vera diag compilation");
      }
      # vcs does not touch libtb.so if nothing functional changed.
      # if a user changes a comment in a source file then make always sees
      # that file as being newer than libtb.so and so we build when there
      # is not reason to. Always touching at this point solves that issue.
      #`touch libtb.so`; 

    # return from the NTB build area for this gmake if ntb_lib
    chdir ".." if ($opt{vcs_use_ntb} && $opt{ntb_lib});

}

#############################################################################}}}
# complile vera config {{{
################################################################################

sub compile_vera_config
{
    # first clean up the diag area
    `rm -rf config.vr config.vro`;
    die ("DIE. could not clean up vera config run area") if ($?) ;

    my $vera_full_path  = &find_diag_path ($opt{vera_config_name}, $opt{vera_config_path}, $opt{vera_config_root}) ;

    `cp -f $vera_full_path config.vr; chmod +w config.vr` ;
    die ("DIE. failed vera config copy to $ENV{PWD}") if ($?) ;

    # pre process if needed
    &pre_process ;

    print "$prg: Compiling vera config\n" ;
    my $cmd = "vera -cmp -max_error 5 -q -I $model_path/vera ";
    $cmd .= join (" ", @{$opt{vera_diag_args}}) ;
    $cmd .= " config.vr " ;
    print "$prg: $cmd\n" ;
      system ($cmd) ;
      die ("DIE. failed vera config compilation") if ($?) ;
}

#############################################################################}}}
# copy tap diag {{{
################################################################################

sub assemble_tap_diag
{
  # first clean up the diag area
  `rm -rf tap.cmd`;
  die ("DIE. could not clean up tap run area") if ($?) ;

  my $tap_full_path = &find_diag_path ($opt{tap_diag_name}, $opt{tap_diag_path}, $opt{tap_diag_root}) ;

  `cp $tap_full_path diag.tap` ;
  die ("DIE. could not copy tap diag to $ENV{PWD}") if ($?) ;
  `chmod +w diag.tap` ;
  die ("DIE. could not change permission of tap diag") if ($?) ;

  # pre process if needed
  &pre_process ;

  # compile the tap diag

  my $cmd = "tapasm" ;
  system ($cmd) ;
  die ("DIE. could not assemble tap diag") if ($?) ;
}

#############################################################################}}}
# copy tpt diag {{{
################################################################################

sub copy_tpt
{
  # first clean up the diag area
  `rm -rf diag.tpt`;
  die ("DIE. could not clean up tpt run area") if ($?) ;

  my $tpt_full_path = &find_diag_path ($opt{tpt_diag_name}, $opt{tpt_diag_path}, $opt{tpt_diag_root}) ;

  `cp $tpt_full_path diag.tpt` ;
  die ("DIE. could not copy tpt diag to $ENV{PWD}") if ($?) ;
  `chmod +w diag.tpt` ;
  die ("DIE. could not change permission of tpt diag") if ($?) ;

  # pre process if needed
  &pre_process ;
}

#############################################################################}}}
# generate an sjm diag {{{
################################################################################

sub generate_sjm_diag
{
  # first clean up the diag area
  `rm -rf sjm_4.cmd sjm_5.cmd`;
  die ("DIE. could not clean up sjm run area") if ($?) ;

  my $cmd = "sjm_tstgen.pl " ;
  $cmd .= join (" ", @{$opt{sjm_args}}) ;
  $cmd .= " -seed=$opt{tg_seed} " ;

  if (($opt{sjm_diag_name} ne "") or ($opt{sjm_diag_path} ne ""))
  {
    my $sjm_full_path = &find_diag_path ($opt{sjm_diag_name}, $opt{sjm_diag_path}, $opt{sjm_diag_root}) ;
    `cp ${sjm_full_path}/sjm_4.cmd sjm_4.cmd` ;
    die ("DIE. could not copy sjm_4 diag to $ENV{PWD}") if ($?) ;
    `chmod +w sjm_4.cmd` ;
    die ("DIE. could not change permission of sjm_4 diag") if ($?) ;

    `cp ${sjm_full_path}/sjm_5.cmd sjm_5.cmd` ;
    die ("DIE. could not copy sjm_5 diag to $ENV{PWD}") if ($?) ;
    `chmod +w sjm_5.cmd` ;
    die ("DIE. could not change permission of sjm_5 diag") if ($?) ;
  }
  elsif ($opt{tomatillo})
  {
    $cmd .= " -t " ;
    system ($cmd) ;
    die ("DIE. could not generate tomatillo sjm diag") if ($?) ;
  }
  else
  {
    system ($cmd) ;
    die ("DIE. could not generate sjm diag") if ($?) ;
  }

  # pre process if needed
  &pre_process ;
}

#############################################################################}}}
# generate an pci diag {{{
################################################################################

sub generate_pci_diag
{
  # first clean up the diag area
  # `rm -rf pci_4.cmd pci_5.cmd`;
  # die ("DIE. could not clean up pci run area") if ($?) ;

  my $cmd = "pci_cmdgen.pl " ;
  $cmd .= join (" ", @{$opt{pci_args}}) ;
  $cmd .= " -seed=$opt{tg_seed} " ;

  if (($opt{pci_diag_name} ne "") or ($opt{pci_diag_path} ne ""))
  {
    my $pci_full_path = &find_diag_path ($opt{pci_diag_name}, $opt{pci_diag_path}, $opt{pci_diag_root}) ;
    `cp ${pci_full_path}/* .` ;
    die ("DIE. could not copy pci diag to $ENV{PWD}") if ($?) ;
    `chmod +w *` ;
    die ("DIE. could not change permission of pci diag") if ($?) ;
  }
  elsif ($opt{tomatillo})
  {
    $cmd .= " -t " ;
    system ($cmd) ;
    die ("DIE. could not generate tomatillo pci diag") if ($?) ;
  }
  else
  {
    system ($cmd) ;
    die ("DIE. could not generate pci diag") if ($?) ;
  }

  # pre process if needed
  &pre_process ;
}

#############################################################################}}}
# locate a diag based on diag_root, diag_path and diag_name {{{
################################################################################

sub find_diag_path
{
  my $diag_name = shift ;
  my $diag_path = shift ;
  my $diag_root = shift ;

  my @full_path = () ;

  print "$prg: locating diag $diag_name\n" ;

  if (($diag_path ne "") and (-e "${diag_path}/$diag_name"))
  {
    push (@full_path, "${diag_path}/$diag_name\n") ;
  }
  else
  {
    foreach my $root (@{$diag_root})
    {
      print "$prg: Looking for diag under $root\n" ;
      @full_path = `find $root -follow -name '$diag_name'`;
      last if ($#full_path > -1) ;
    }
  }

  if ($#full_path == -1) { die ("DIE. no diag with name $diag_name found") ; }
  if ($#full_path > 0) { die ("DIE. multiple diags with name $diag_name found") ; }

  chomp $full_path[0];
  print "$prg: Found diag under $full_path[0]\n" ;
  return $full_path[0] ; 
}

#############################################################################}}}
# parse all arguments from command line and config file {{{
################################################################################

sub parse_args
{
  my $sys = shift ;
  my $doconfig = shift ; 

  #Debug
  print "(debug)(parse_args) (sys = $sys) (doconfig=$doconfig)\n";
  print "(debug)(parse_args) current ARGV =  @ARGV\n";

if ( $opt{vcs_full64} ) {
  push (@{$opt{config_cpp_args}}, "-DSIMS_64BIT");
  print "$prg: added -DSIMS_64BIT to config_cpp_args\n" ;
}

  ## Read in config flags from $sys.config, store them in @ARGV
  
  print "(debug)(parse_args) before get_config() @ARGV\n";
  &get_config ($sys, \@ARGV) if ($opt{use_config} and $doconfig) ;
  print "(debug)(parse_args) after get_config() @ARGV\n";

  #print "\@ARGV: @{ARGV}\n" if $opt_debug;

  ## Do nothing speciall...
  foreach my $q (0 .. $#ARGV)
  {
    ($ARGV[$q] =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($ARGV[$q] =~ /\s/) and ($ARGV[$q] !~ /-.*?="/)) ; 
  }

  GetOptions (\%opt,
            'alias=s',
            'asm_diag_name=s',
            'asm_diag_path=s',
            'asm_diag_root=s@',
            'auditr_args=s@',
            'build!',
            'cc_dv_root=s',
	        'clearcase!',
            'cdms_rel_name=s',
            'config_cpp_args=s@',
            'config_rtl=s@',
            'debug!',
            'debussy!',
            'dftvert!',
            'diag_pl_args=s@',
            'diaglist=s',
            'diaglist_cpp_args=s@',
            'diff_cdms_rel!',
            'diff_cdms_curr!',
            'drmlog!',
            'drmlog_name=s',
            'drmcommand_name=s',
            'drmconstraints_name=s',
            'drm_constraints_file=s',
            'drm_cpufreq=s',
            'drm_disk=s',
            'drm_freeprocessor=s',
            'drm_freeram=s',
            'drm_freeswap=s',
            'drm_license=s',
            'drm_on!',
            'drm_osver=s',
            'drm_priority=s',
            'drm_project=s',
            'drm_type=s',
            'drm_totprocessor=s',
            'drm_window=s',
            'dv_root=s',
            'efc!',
            'efc_args=s@',
            'efuse_image_name=s',
            'efuse_image_path=s',
            'efuse_image_root=s@',
            'env_base=s',
            'fast_boot!',
            'finish_mask=s',
            'flist=s@',
            'fsdb2vcd!',
            'fsdbfile=s',
            'fsdbDumplimit=s',
            'fsdb_glitch!',
            'graft_flist=s',
            'group=s@',
            'group_name=s',
            'gzip!',
            'hcs_build!',
            'hcs_build_args=s@',
            'hcs_run!',
            'hcs_run_args=s@',
            'hcs_drm_tokens=i',
            'axis_build!',
            'axis_build_args=s@',
            'axis_run!',
            'axis_run_args=s@',
            'image_diag_name=s',
            'image_diag_path=s',
            'image_diag_root=s@',
            'indrm!',
            'interactive!',
            'max_cycle=i',
            'midas_args=s@',
            'midas_only!',
            'midas_use_tgseed!',
            'model_dir=s',
            'ntb_lib!',
            'overwrite!',
            'palladium_build!',
            'palladium_build_args=s@',
            'palladium_run!',
            'palladium_run_args=s@',
            'pal_use_tgseed!',
            'pci!',
            'pci_args=s@',
            'pci_diag_name=s',
            'pci_diag_path=s',
            'pci_diag_root=s@',
            'post_process_cmd=s@',
            'pre_process_cmd=s@',
            'reg_count=i',
            'regress!',
            'regress_date=s',
            'regress_id=s',
            'regress_time=s',
            'report!',
            'rerun!',
            'result_dir=s',
            'rtl_timeout=i',
	        'run_diag_pl!',
            'sas!',
            'saslog!',
            'sas_run_args=s@',
            'sims_config=s',
            'sims_env=s@',
            'simslog!',
            'simslog_name=s',
            'sjm!',
            'sjm_args=s@',
            'sjm_diag_name=s',
            'sjm_diag_path=s',
            'sjm_diag_root=s@',
            'spis_diag_name=s',
            'spis_diag_path=s',
            'spis_diag_root=s@',
            'start_dump=i',
            'stop_dump=i',
            'stub_mask=s',
            'sunv_args=s@',
            'sunv_nonprim_list=s',
            'sunv_run!',
            'sunv_use_nonprim!',
            'sys=s',
#ifdef SYSTEMC_SUPPORT
            'sysc_build!',
            'syscan_build_args=s@',
#endif
            'sim_q_command=s',
            'tap_diag_name=s',
            'tap_diag_path=s',
            'tap_diag_root=s@',
	        'tcl_tap!',
	        'tcl_tap_diag=s',
            'tg_seed=i',
            'tomatillo!',
            'tpt_diag_name=s',
            'tpt_diag_path=s',
            'tpt_diag_root=s@',
            'use_auditr!',
            'use_config!',
            'use_denalirc=s',
            'use_sims_iver!',
            'vcd!',
            'vcdfile=s',
            'sim=s',
            'ncv_build!',
            'ncv_build_args=s@',
            'ncv_clean!',
            'ncv_run!',
            'ncv_run_args=s@',
            'vcs_build!',
            'vcs_build_args=s@',
            'vcs_clean!',
            'vcs_cm_args=s',
            'vcs_cm_cond=s',
            'vcs_cm_config=s',
            'vcs_cm_fsmcfg=s',
            'vcs_cm_merge!',
            'vcs_cm_name=s',
            'vcs_finish=i',
            'vcs_prof!',
            'vcs_full64!',
            'model_rel_name=s',
            'vcs_run!',
            'vcs_run_args=s@',
            'vcs_use_cli!',
            'vcs_use_ucli!',
            'vcs_use_cm!',
            'vcs_use_fsdb!',
            'vcs_use_initreg!',
            'vcs_use_ntb!',
            'vcs_use_rad!',
            'vcs_use_radincr!',
            'vcs_use_sdf!',
            'vcs_use_vcsd!',
            'vcs_use_vera!',
            'vera_build!',
            'vera_build_args=s@',
            'vera_clean!',
            'vera_config_name=s',
            'vera_config_path=s',
            'vera_config_root=s@',
            'vera_cov_obj=s@',
            'vera_diag_args=s@',
            'vera_dummy_diag=s',
            'vera_pal_diag_args=s@',
            'vera_diag_root=s@',
            'vera_diag_name=s',
            'vera_diag_path=s',
            'vera_gmake!',
            'vera_proj_args=s@',
            'vera_run!',
            'vera_vcon_file=s',
            'verbose!',
            'vfile=s@',
            'vlint_args=s@',
            'vlint_run!',
            'vlint_top=s',
            'illust_run!',
            'illust_args=s@',
            'verix_args=s@',
            'verix_libs=s@',
            'verix_run!',
            'verix_top=s',
            'wait_cycle_to_kill=i',
            'zeroIn_build!',
            'zeroIn_dbg_args=s@',
            'zeroInSearch_build!',
            'zeroIn_checklist!',
            'zeroIn_build_args=s@',
		'parallel!',
        'exe_dir=s',
        'cache!',
           );

    print "(debug)(parse_arg) all sims flags have been loaded into opt hash \n";
    foreach my $x (@{$opt{vcs_build_args}}) {
    print "(debug)(parse_arg) -vcs_build_args: ".$x."\n";
    }

  foreach my $x (@ARGV)
  {
    print "(debug)(parse_arg) rest_args: $x\n";
    if ($x =~ /\.s/) { $opt{asm_diag_name} = $x  ; }
    elsif ($x =~ /\.pal/) { $opt{asm_diag_name} = $x ; }
    elsif ($x =~ /\.s\.gz/) { $opt{asm_diag_name} = $x ; }
    elsif ($x =~ /\.tpt/) { $opt{tpt_diag_name} = $x ; }
    elsif ($x =~ /\.tap/) { $opt{tap_diag_name} = $x ; }
    elsif ($x =~ /\.image/) { $opt{image_diag_name} = $x ; }
    elsif ($x =~ /\.vrpal/) { $opt{vera_diag_name} = $x ; }
    elsif ($x =~ /\.vr/) { $opt{vera_diag_name} = $x ; }
    elsif ($x =~ /\.dat/) { $opt{efuse_image_name} = $x ; }
  }

  # Override the vera diag name if not specified and dummy is specified
  if (($opt{vera_dummy_diag} ne "" ) and ($opt{vera_diag_name} eq "")){
    print "$prg: vera dummy diag specified as $opt{vera_dummy_diag}\n";
    #$opt{vera_diag_name} = $opt{vera_dummy_diag};
  }

  # set environment variables
  if (scalar(@{$opt{sims_env}})) {
    foreach my $ex (@{$opt{sims_env}}) {
        $ex =~ /(\w+)=(.*)/;
        if (defined $ENV{$1}) {
            print "$prg: overriding ENV{$1}=$2\n";
        } else {
            print "$prg: setting ENV{$1}=$2\n";
        }
        $ENV{$1}=$2;
    }
  }
  # expand environment variables
  $opt{env_base} =~ s/\$(\w+)/$ENV{$1}/g ;
  $opt{sunv_nonprim_list} =~ s/\$(\w+)/$ENV{$1}/g ;

  # if -nobuild specified disable all build options
  if ($opt{build} == 0)
  {
    $opt{sunv_run} = 0 ;
    $opt{vcs_build} = 0 ;
    $opt{ncv_build} = 0 ;
    $opt{vera_build} = 0 ;
    $opt{zeroIn_build} = 0 ;
    $opt{zeroInSearch_build} = 0 ;
    $opt{axis_build} = 0 ;
    $opt{palladium_build} = 0 ;
    $opt{hcs_build} = 0 ;
  }

  # generate a random number generator seed if not specified

  if ($opt{tg_seed} == -1)
  {
    my $seed ;
    open (RANDOM, "< /dev/random") or die "DIE. Could not open /dev/random" ;
    sysread (RANDOM, $seed, 4) ;
    close (RANDOM) ;
    $opt{tg_seed} = unpack ("L*", $seed) & 0x7fffffff;
  }

  print "$prg: using random seed $opt{tg_seed}\n" ;

  # let ntb over ride vera so users can try NTB from the command line w/o having
  # to edit the bench config file.
  if ($opt{vcs_use_ntb} and $opt{vcs_use_vera}) 
  {
    undef $opt{vcs_use_vera};
    undef $opt{vera_run};
    $opt{drm_license} =~ s/,*vera=1//o;   # No Vera license required ..
  }

}

#############################################################################}}}
# get options from the diaglist if necessary {{{
################################################################################

sub get_opt_from_diaglist
{
    # put the pre-processed diaglist in here

    die ("DIE. Diag list $diaglist not found") if (! -f $diaglist) ;

    print "$prg: processing diaglist ($diaglist)..\n" ;
    my $diagcppargs = join(' ', @{$opt{diaglist_cpp_args}});
    print "(debug)bw_cpp is processing diaglist option.. output = $ENV{PWD} /master_diaglist..\n" ;
    system ("bw_cpp -B -undef $diagcppargs -I$dv_root/verif/diag $diaglist > master_diaglist") ;
    die  ("DIE. Could not pre-process the master_diaglist") if ($?) ;

    # open the diaglist and look for the group in it

    my $diagList = DiagList->new ("master_diaglist", $opt{null}, ${$opt{group}} [0]) ;
    my $group = $diagList->find_group (${$opt{group}} [0]) ;

    die ("DIE. Group name $opt{group} not found in diag list $diaglist") if (! defined $group) ;

    my @tags =  $group->build_tags () ;
    print "(debug)diaglist build_tags = @tags\n" ;

    die ("DIE. Group name $opt{group} corrresponds to multiple build tags") if ($#tags > 0) ;

    my $tag = $tags [0] ;
    my $buildargs = $diagList->build_args ($tag) ;
    print "(debug)diaglist buildargs $buildargs\n" ;
    my ($sys) = ($buildargs =~ /sys\s*=\s*([a-z0-9_]+)\s*/i) ;

    foreach my $diagname ($group->list_diags($tag))
    {
      my $diag    = $group->find_diag($tag, $diagname) ;
      my $alias = $diag->get_name () ;

      if ($alias eq $opt{alias})
      {
        my @runargs = $diag->get_cmd_argv() ;
        print "$prg: found alias $alias with arguments -sys=$sys @runargs\n" ;

        unshift (@ARGV, "-sys=$sys") ;
        unshift (@ARGV, @runargs) ;
        return ;
      }
    }

    die ("DIE. The alias $opt{alias} could not be found in the diaglist") ;
}

#############################################################################}}}
# format 64bit dump_start/stop time into t+ht {{{
################################################################################

sub bigtime2plus
{
    use Math::BigInt;
    my $time = shift;
    my $btime = Math::BigInt->new($time); 
    return (($btime&4294967295)."+".($btime>>32));

}
#############################################################################}}}
# deep copy any data structure {{{
################################################################################
sub deep_copy {
    my $this = shift;
    if (not ref $this) {
      $this;
    } elsif (ref $this eq "SCALAR") {
      $this;
    } elsif (ref $this eq "ARRAY") {
      [map deep_copy($_), @$this];
    } elsif (ref $this eq "HASH") {
      +{map { $_ => deep_copy($this->{$_}) } keys %$this};
    } else { die "DIE deep_copy: what type is $_?\n" }
}#}}}



################################################################################
################################################################################

#     #  #####     #     #####  #######
#     # #     #   # #   #     # #
#     # #        #   #  #       #
#     #  #####  #     # #  #### #####
#     #       # ####### #     # #
#     # #     # #     # #     # #
 #####   #####  #     #  #####  #######

################################################################################
################################################################################

sub usage
{

print <<EOF;

NAME

sims - Verilog rtl simulation environment and regression script 

SYNOPSIS

 sims [args ...]
  where args are:

NOTE: Use "=" instead of "space" to separate args and their options.

SIMULATION ENV

    -sys=NAME
            sys is a pointer to a specific testbench configuration
            to be built and run. a config file is used to associate
            the sys with a set of default options to build the
            testbench and run diagnostics on it. the arguments
            in the config file are the same as the arguments passed
            on the command line.
            
    -group=NAME
            group name identifies a set of diags to run in a
            regression. The presence of this argument indicates
            that this is a regession run. the group must be found
            in the diaglist. multiple groups may be specified to be
            run within the same regression.

            NOTE: If -sys=NAME option is specified then NAME.diaglist
                  is used as root diaglist instead of the master diaglist.

    -group=NAME -alias=ALIAS
            this combination of options gets the diag run time options
            from the diaglist based on the given group and alias.
            the group must be found in the diaglist. the alias is
            made up of diag_alias:name_tag. only one group should be
            specified when using this command format.


VERILOG COMPILATION RELATED

    -sim_q_command="command"
          defines which job queue manager command to use to launch jobs. 
          Defaults to /bin/sh and runs simulation jobs on the local machine.

    -flist=FLIST
           full path to flist to be appended together to generate the
           final verilog flist. multiple such arguments may be used and
           each flist will be concatenated into the final verilog flist
           used to build the model.

    -graft_flist=GRAFTFILE
           GRAFTFILE is the full path to a file that lists each verilog
           file that will be grafted into the design. the full path to
           the verilog files must also be given in the GRAFTFILE.

    -vfile=FILE
           verilog file to be included into the flist

    -config_rtl=DEFINE
           each such parameter is place as a `define in config.v to
           configure the model being built properly. this allows
           each testbench to select only the rtl code that it needs
           from the top level rtl file (ciop.v in blackwidow).

    -model=NAME
           the name of a model to be built. the full path to a model
           is MODEL_DIR/model/vcs_rel_name.

    -vcs_rel_name=NAME
            specify the release of the model to be built. the full path
            to a model is MODEL_DIR/model/vcs_rel_name.

SYNOPSYS' VCS COMPILATION RELATED

    -vcs_build/-novcs_build
           builds a vcs model and the vera testbench. defaults to off.

    -vcs_build_args=OPTION
           vcs compile options. multiple options can be specified using
           multiple such arguments.
           
    -vcs_clean/-novcs_clean
           wipes out the model directory and rebuilds it from scratch.
           defaults to off.

    -vcs_full64
           sets the vcs -full64 compile flag so that the compiler is a
           64 bit executable, and produces a 64 bit executable simv.
           will use the 64 bit version of vera, and link in the 64 bit
           versions of 0in, debussy, and denali tools.

    -vcs_use_2state/-novcs_use_2state
           builds a 2state model instead of the default 4state model.
           this defaults to off.

    -vcs_use_initreg/-novcs_use_initreg
           initialize all registers to a valid state (1/0).
           this feature works with -tg_seed to set the seed of the random
           initialization. this defaults to off.

    -vcs_use_fsdb/-novcs_use_fsdb
           use the debussy fsdb pli and include the dump calls in the
           testbench. this defaults to on.

    -vcs_use_vcsd/-novcs_use_vcsd
           use the vcs direct kernel interface to dump out debussy files.
           this defaults to on.

    -vcs_use_vera/-novcs_use_vera
           compile in the vera libraries. if -vcs_use_ntb and -vcs_use_vera are
           used, -vcs_use_ntb wins.
           this defaults to off.

    -vcs_use_ntb/-novcs_use_ntb
           enable the use of NTB when building model (simv) and running simv.
           if -vcs_use_ntb and -vcs_use_vera are used, -vcs_use_ntb wins.
           this defaults to off.

    -vcs_use_rad/-novcs_use_rad
           use the +rad option when building a vcs model (simv).
           defaults to off.

    -vcs_use_sdf/-novcs_use_sdf
           build vcs model (simv) with an sdf file.
           defaults to off.

    -vcs_use_radincr/-novcs_use_radincr
           use incremental +rad when building a vcs model (simv).
           defaults to off.
           this is now permanently disabled as synopsys advises against
           using it.

    -vcs_use_cli/-novcs_use_cli
           use the +cli -line options when building a vcs model (simv).
           defaults to off.

           use this switch, in conjunction with -nosimslog during runtime
           if you need to pass ctrl-c to the vcs/axis model and continue
           with CLI activity.

           Use this with VCS versions before 2006.

    -vcs_use_ucli/-novcs_use_ucli (Unified cli)
           use the -debug_all option when building a vcs model (simv).
           defaults to off.

           use this switch, in conjunction with -nosimslog during runtime
           if you need to pass ctrl-c to the vcs/axis model and continue
           with UCLI activity.

           At runtime, use -vcs_run_arg=-ucli to get the UCLI at time zero,
           or          use -vcs_run_arg=-gui  to get the UCLI GUI at time zero.
           At runtime, use -vcs_run_arg=-tbug to get NTB debug in the GUI.

           Use this with VCS versions 2006 and up.

CADENCE's NC-VERILOG COMPILATION RELATED

    -ncv_build/-noncv_build
           builds a ncverilog model and the vera testbench. defaults to off.

    -ncv_build_args=OPTION
           ncverilog compile options. multiple options can be specified using
           multiple such arguments.
           
    -ncv_clean/-noncv_clean
           wipes out the model directory and rebuilds it from scratch.
           defaults to off.

SYSTEMC COMPILATION RELATED
	
	-sysc_build
		   builds the systemc model.

VERA/NTB COMPILATION RELATED

    VERA and NTB share all of the vera options except a few.
    See NTB RELATED section below.

    -vera_build/-novera_build
           builds the vera/ntb testbench. default on.

    -vera_clean/-novera_clean
           performs a gmake clean on the vera/ntb testbench before building
           the model. defaults to off.

    -vera_build_args=OPTION
           vera/NTB testbench compile time options.
           Multiple options can be specified using multiple such
           options. these are passed as arguments to the gmake call
           when building the vera/NTB testbench.
           (Eg: -vera_build_args=VERA_SYS_DEFS=\"-DSPC_BENCH -DGATESIM\")

           For NTB, -vera_build_args=NTB_BUILD_ARGS=\"+error+10 -ntb_define ABCD\"
           can be used to add something directly to the \"vcs -ntb_cmp\" command.
           For the -ntb_lib option, NTB_BUILD_ARGS will affect both the vshell and
           bench+diag builds. See -vera_diag_args to not affect the vshell build.


    -vera_diag_args=OPTION
           vera/ntb diag compile time options.
	       Multiple options can be specified using multiple such
           options.  For Vera, these args are appended to the
          \"vera -cmp ...\" command for the diag only.
          (Eg: -vera_diag_args=\"-max_error 10\" or -vera_diag_args=-DNCU_ACK_DLY1=100)

           For NTB, these args are passed as arguments to the gmake
           call as NTB_DIAG_ARGS=\" ...\" to be part of the NTB
           bench+diag compile. These NTB_DIAG_ARGS are appended to
           the \"vcs -ntb_cmp\" command when making the libtb.so so
           they better be legal in that context. For NTB, these args
           really affect the entire bench build, not just the diag,
           BUT they they do not affect the vshell build.
           (Eg. -vera_diag_args=+error+10 or -vera_diag_args=\"-ntb_define NCU_ACK_DLY1=100\")

    -vera_dummy_diag=PATH

           This option is used to give vera/NTB a path to a default
           diag or diag class (or a default program top if using RVM)
           that can be used for building purposes before an actual
           diag is chosen (NTB build of vshell file before regression
           for example).

           Also, some benches may run both asm and vera diags but the
           vera diags are only run sometimes. In this case, you need a
           dummy vera testcase class/program top to fill in when an
           actual vera diag is not being used for that run (aka the
           sometimes diag problem). If your openVera code refers to a
           testcase class, you better have one even if it does nothing
           else you will not be able to build. The dummy lets you
           build.  If your diag is implemented as the program top
           (RVM) then the dummy must have #includes for ALL of your
           vera interfaces or your vshell will be broken.

           Whenever the actual vera/NTB diag is specified, the dummy
           is automatically *not* used (at regression time for
           example).  The vera_dummy_diag should be specified in the
           bench config file.  This option applies to Vera and NTB
           (but NTB only when using the -ntb_lib option).

    -vera_pal_diag_args=OPTION
           vera/ntb pal diag expansion options
	   (i.e. "pal OPTIONS -o diag.vr diag.vrpal")
	   multiple options can be specified using multiple such arguments.

    -vera_proj_args=OPTION
           vera proj file generation options. multiple options can be
           specified using multiple such arguments.

    -vera_vcon_file=ARG
           name of the vera vcon file that is used when running the simulation.

    -vera_cov_obj=OBJ
           this argument is passed to the vera Makefile as a OBJ=1 and to
           vera as -DOBJ to enable a given vera coverage object. multiple
           such arguments can be specified for multiple coverage objects.

    -vera_gmake/-novera_gmake
          this argument optionally lets the flow skip running gmake for the
          vera/NTB build, while maintaining other operations within the
          -vera_build flow. default ON (execute gmake)

NTB RELATED

    NTB and VERA share all of the vera options except these:

      -vcs_use_ntb/-novcs_use_ntb
             enable the use of NTB (compiled vera) rather than the
             conventional Vera.  if -vcs_use_ntb and -vcs_use_vera are
             used at once, then -vcs_use_ntb wins.  defaults to off.

      -ntb_lib/-nontb_lib
             enables the NTB 2 part compile where the openVera files
             get compiled separately into a libtb.so file which is
             dynamically loaded by vcs at runtime. The libtb.so file
             is built by the Vera/NTB Makefile, not sims. Use the
             Makefile to affect the build. If not using -ntb_lib, sims
             will build VCS and the openVera files together in one
             pass (uses Makefile to affect that build as well). default
             is off.

             The ntb_lib method is know as the NTB LIB method. When not
             using this ntb_lib method, the ALL IN ONE method is used.

             The NTB LIB method allows the bench to run unique openVera diags
             that are separate from the bench (via a diaglist if desired).

             The NTB ALL IN ONE method does not allow the bench to run
             unique openVera diags that are separate from the bench.
             Use this for benches that do not run openVera diags
             (perhaps the bench only runs asm diags

SYNOPSYS VERA RUNTIME RELATED

    -vera_run/-novera_run
            runs the ncverilog/vcs simulation and loads in the vera proj file
            or the ntb libtb.so file. defaults to on.

SIMV (SYNOPSYS' VCS) RELATED

    -vcd/-novcd 
           signals the bench to dump in VCD format

    -vcdfile=filename
           the name of the vcd dump file.  if the file name starts with
           a "/", that is the file dumped to, otherwise, the actual file is
           created under tmp_dir/vcdfile and copied back to the current
           directory when the simulation ends.  use "-vcdfile=`pwd`/filename"
           to force the file to be written in the current directory directly
           (not efficient since dumping is done over network instead of to
           a local disk).

    -vcs_run/-novcs_run
           runs the vcs simulation (simv). defaults to off.

    -vcs_run_args=OPTION
           vcs (simv) runtime options. multiple options can be specified
           using multiple such arguments.

           The order of vcs_run_args (plusargs) given to simv is:
                  args embedded in diag (using !SIMS+ARGS: ..), if any
                  args given in the command line, if any
                  args from diaglist : alias definition, if any
                  args from diaglist : <runargs>..</runargs>, if any
                  args from the config file, if any

    -vcs_finish=TIMESTAMP
           forces vcs to finish and exit at the specified timestamp.

    -fast_boot/-nofast_boot
           speeds up booting when using the ciop model. this passes the
           +fast_boot switch to the simv run and the -sas_run_args=-DFAST_BOOT
           and -midas_args=-DFAST_BOOT to sas and midas. Also sends
           -DFAST_BOOT to the diaglist and config file preprocessors.

    -debussy/-nodebussy
           enable debussy dump. this must be implemented in the testbench
           to work properly. defaults to off.

    -start_dump=START
           start dumping out a waveform after START number of units

    -stop_dump=STOP
           stop dumping out a waveform after STOP number of units

    -fsdb2vcd
           runs fsdb2vcd after the simulation has completed to generate a vcd file.

    -fsdbfile=filename
           the name of the debussy dump file.
	   If the file name starts with a "/", that is the file dumped to,
	   otherwise, the actual file is created under tmp_dir/fsdbfile
	   and copied back to the current directory when the simulation ends.
	   Use "-fsdbfile=`pwd`/filename" to force the file to be
	   written in the current directory directly (not efficient since
	   dumping is done over network instead of to a local disk).

    -fsdbDumplimit=SIZE_IN_MB
	   max size of Debussy dump file.  minimum value is 32MB.
	   Latest values of signal values making up that size is saved.

    -fsdb_glitch
           turn on glitch and sequence dumping in fsdb file. this will collect
           glitches and sequence of events within time in the fsdb waveform.
           beware that this will cause the fsdb file size to grow significantly.
           this is turned off by default. this option effectively does this:
           setenv FSDB_ENV_DUMP_SEQ_NUM 1
           setenv FSDB_ENV_MAX_GLITCH_NUM 0

    -rerun
           rerun the simulation from an existing regression run directory.

    -overwrite
           overwrite current run dir when doing a -rerun. default is to 
           create a rerun_<n> subdir for reruns.

    -post_process_cmd=COMMAND
           post processing command to be run after vcs (simv) run completes

    -pre_process_cmd=COMMAND
           pre processing command to be run before vcs (simv) run starts

    -use_denalirc=FILE
          use FILE as the .denalirc in the run area. Default copies
          env_base/.denalirc

NCSIM (CADENCE's NC-VERILOG) RELATED

    -ncv_run/-noncv_run
           runs the NC-Verilog simulation (ncsim). defaults to off.

    -ncv_run_args=OPTION
           ncsim runtime options. multiple options can be specified
           using multiple such arguments.
                  
    -rerun
           rerun the simulation from an existing regression run directory.
	   you can just say "% sims -rerun", and sims will automatically
	   extract the required arguments.

    -overwrite
           overwrite current run dir when doing a -rerun. default is to 
           create a rerun_<n> subdir for reruns.

    -debussy/-nodebussy
           enable debussy dump. this must be implemented in the testbench
           to work properly. defaults to off.


VLINT OPTIONS

         -vlint_run/-novlint_run
                runs the vlint program. defaults to off.

         -vlint_args
                vlint options. The <sysName>.config file can contain
                the desired vlint arguments, or they can also be given on
                the command line.  Typically the -vlint_compile is given
                on the command line.

                vlint also requires identification of a rules deck.

         -illust_run
                run illust after x2e

         -illust_args
                illust options

	-vlint_top
                top level module on which to run vlint

VERIX OPTIONS

    -verix_run/-noverix_run
           runs the verix program. defaults to off.

    -verix_libs
           specify the library files to add to the vlist

    -verix_args
           verix template options. The <sysName>.config file can contain
           these desired verix arguments

           verix also requires <top>.verix.tmplt in the config dir.

    -verix_top
           top level module on which to run verix


THARAS HAMMER RELATED

    -hcs_build
           build a model to be run on the Hammer Hardware Accelerator.

    -hcs_build_args
           build arguments for Hammer Hardware Accelerator

    -hcs_run
           run a model on the Hammer Hardware Accelerator.

    -hcs_run_args
           run arguments for the Hammer Hardware Accelerator.

    -hcs_drm_tokens
           tokens for drmsubmit licenses 

AXIS RELATED

    -axis_build
           build a model to be run on the Axis Hardware Accelerator.

    -axis_build_args
           build arguments for Axis Hardware Accelerator

    -axis_run
           run a model on the Axis Hardware Accelerator.

    -axis_run_args
           run arguments for the Axis Hardware Accelerator.

PALLADIUM RELATED

    -palladium_build
           build a model to be run on the palladium Hardware Accelerator.

    -palladium_build_args
           build arguments for palladium Hardware Accelerator

    -palladium_run
           run a model on the palladium Hardware Accelerator.

    -palladium_run_args
           run arguments for the palladium Hardware Accelerator.


ZEROIN RELATED

    -zeroIn_checklist
           run 0in checklist

    -zeroIn_build
           build 0In pli for simulation into vcs model

    -zeroInSearch_build
           build 0in search pli for simulation into vcs model

    -zeroIn_build_args
           additional arguments to be passed to the 0in command

    -zeroIn_dbg_args
           additional debug arguments to be passed to the 0in shell

SAS/SIMICS RELATED 

    -sas/-nosas
           run architecture-simulator. If vcs_run option is OFF,
           simulation is sas-only. If vcs_run option is ON, sas
           runs in lock-step with rtl. default to off.

    -sas_run_args=DARGS
           Define arguments for sas.

TCL/TAP RELATED 

    -tcl_tap/-notcl_tap
           run tcl/expect TAP program. If vcs_run option is OFF,
           simulation is tcl-only. If vcs_run option is ON, tcl
           runs in lock-step with rtl. default to off.
	   NOTE: You _must_ compile with -tcl_tap as well, to enable
		 to enable functions that are needed for running with tcl

    -tcl_tap_diag=diagname
           Define top level tcl/expect diag name.

MIDAS

midas is the diag assembler
 
    -midas_args=DARGS
           arguments for midas. midas creates memory image and user-event
           files from the assembly diag.

    -midas_only
           Compile the diag using midas and exit without running it.

    -midas_use_tgseed
           Add -DTG_SEED=tg_seed to midas command line. Use -tg_seed to
           set the value passed to midas or use a random value from /dev/random.

PCI

pci is the tomatillo pci bus functional model

    -pci_args
           arguments to be passed in to pci_cmdgen.pl for generation of a pci
           random diagnostic.

    -pci/-nopci
           generates a random pci diagnostic using the -tg_seed if provided.
           default is off.

    -tomatillo
           generates a random tomatillo diagnostic using the -tg_seed if provided

    -tg_seed
           random generator seed for pci/tomatillo random test generators
           also the value passed to +initreg+ to randomly initialize registers
           when -vcs_use_initreg is used.

SJM

sjm is the jalapeno jbus bus functional model

    -sjm_args
           arguments to be passed in to sjm_tstgen.pl for generation of an sjm
           random diagnostic.

    -sjm/-nosjm
           generates a random sjm diagnostic using the -tg_seed if provided.
           default is off.

    -tomatillo
           generates a random tomatillo diagnostic using the -tg_seed if provided

    -tg_seed
           random generator seed for sjm/tomatillo random test generators
           also the value passed to +initreg+ to randomly initialize registers
           when -vcs_use_initreg is used.

EFCGEN

efcgen.pl is a script to generate efuse.img files (default random),
which is used by the efuse controller after reset.
It is invoked by -efc.

    -efc/-noefc
           generates an efuse image file using the -tg_seed if provided.
           default is off.  Random if no -efc_args specified.

    -efc_args
           arguments to be passed in to efcgen.pl for generation of
	   an efuse image file.
	   Default is random efuse replacement for each block.

    -tg_seed
           random generator seed for efcgen.pl script
           also the value passed to +initreg+ to randomly initialize
	   registers when -vcs_use_initreg is used.

VCS COVERMETER

    -vcs_use_cm/-novcs_use_cmd
           passes in the -cm switch to vcs at build time and simv at runtime
           default to off.

    -vcs_cm_args=ARGS
           argument to be given to the -cm switch

    -vcs_cm_cond=ARGS
           argument to be given to the -cm_cond switch.

    -vcs_cm_config=ARGS
           argument to be given to the -cm_hier switch

    -vcs_cm_fsmcfg=ARGS
           argument to be given to the -cm_fsmcfg switch
	   specifies an FSM coverage configuration file

    -vcs_cm_name=ARGS
           argument to be given to the -cm_name switch. defaults to cm_data.

DFT 

    -dftvert
          modifies the sims flow to accomodate dftvert. this skips compiling
          the vera testbench and modifies the simv command line at runtime.


MISC 

    -regress
          pretend this is a regression and run the job in DRMJOBSCRATCHSPACE
          instead of the launch directory. useful with -indrm and 
          -interactive options and single jobs. automatically added for
          regressions.

    -nobuild
          this is a master switch to disable all building options.
          there is no such thing as -build to enable all build options.

    -copyall/-nocopyall
          copy back all files to launch directory after passing
	  regression run.  Normally, only failing runs cause a
	  copy back of files.
	  Default is off.

    -copydump/-nocopydump
          copy back dump file to launch directory after passing
	  regression run.  Normally, only failing runs cause a copy
	  back of non-log files.  The file copied back is vcs.fsdb,
	  or vcs.vcd if -fsdb2vcd option is set.
	  Default is off.

    -tarcopy/-notarcopy
          copy back files using 'tar'. This only works in copyall or
          in the case the simulations 'fails' (per sims' determination).
          Default is to use 'cp'.

    -diag_pl_args=ARGS
          If the assembly diag has a Perl portion at the end, it
	  is put into diag.pl and is run as a Perl script.
	  This allows you to give arguments to that Perl script.
	  The arguments accumulate, if the option is used multiple
	  times.

    -pal_use_tgseed
           Send '-seed=<tg_seed_value> to pal diags.  Adds
           -pal_diag_args=-seed=tg_seed to midas command line, and
           -seed=tg_seed to pal options (vrpal diags). Use -tg_seed to set
           the value passed to midas or use a random value from /dev/random.

    -parallel
            when specifying multiple groups for regressions this switch will
            submit each group to DReAM to be executed as a separate regression.
            this has the effect of speeding up regression submissions.
            NOTE: This switch must not be used with -indrm

    -reg_count=COUNT
            runs the specified group multiple times in regression mode. this
            is useful when we want to run the same diag multiple times using
            a different random generator seed each time or some such.

    -regress_id=ID
            specify the name of the regression

    -report
            This flag is used to produce a report of a an old or running
            regression. With -group options, sims produces the report
            after the regression run. Report for the previous
            regression run can be produced using -regress_id=ID
            option along with this option,

    -finish_mask=MASK
           masks for vcs simulation termination. Simulation terminates
           when it hits 'good_trap' or 'bad_trap'. For multithread
           simulation, simulation terminates when any of the thread
           hits bad_trap, or all the threads specified by the finish_mask
           hits the good_trap.
           example: -finish_mask=0xe
           Simulation will be terminated by good_trap, if thread 1, 2 and
           3 hits the good_trap.

    -stub_mask=MASK
           mask for vcs simulation termination. Simulation ends when the
           stub driving the relevant bit in the mask is asserted. This
           is a hexadecimal value similar to -finish_mask

    -wait_cycle_to_kill=VAL
           passes a +wait_cycle_to_kill to the simv run. a testbench
           may chose to implement this plusarg to delay killing a
           simulation by a number of clock cycles to allow collection
           of some more data before exiting (e.g. waveform).

    -rtl_timeout
           passes a +TIMEOUT to the simv run.
           sets the number of clock cycles after all threads have become
           inactive for the diag to exit with an error. if all threads hit
           good trap on their own the diag exits right away. if any of the
           threads is inactive without hitting good trap/bad trap the
           rtl_timeout will be reached and the diag fails. default is 1000.
           this is only implemented in the cmp based testbenches.

    -max_cycle
           passes a +max_cycle to the simv run.
           sets the maximum number of clock cycle that the diag will take
           to complete. the default is 30000. if max_cycle is hit the diag
           exits with a failure. not all testbenches implement this
           feature.

    -norun_diag_pl
           Does not run diag.pl (if it exists) after simv (vcs) run.
           Use this option if, for some reason, you want to run an
	   existing assembly diag without the Perl part that is in
	   the original diag.

    -nosaslog
           turns off redirection of sas stdout to the sas.log file.
           use this option when doing interactive runs with sas.

    -nosimslog
           turns off redirection of stdout and stderr to the sims.log
           file.  use this option in conjunction with -vcs_use_cli or
           -vcs_use_ucli to get to the cli prompt when using vcs or to
           see a truncated vcs.log file that exited with an
           error. this must be used if you want control-c to work
           while vcs is running.

    -nogzip
           turns off compression of log files before they are copied over
           during regressions.

    -version
            print version number.

    -help
            prints this

IT SYSTEM RELATED

    -use_iver=FILE
            full path to iver file for frozen tools

    -use_sims_iver/-nouse_sims_iver
            For reruns of regression tests only, use sims.iver to choose
            TRE tool versions saved during original regression run.
            Defaults to true.

    -use_cdms_iver/-nouse_cdms_iver
            Uses the frozen iver file located under DV_ROOT if present.
            This defaults to true. This has no effect if an iver file
            is not found under the cdms tree.

    -dv_root=PATH
            absolute path to design root directory. this overrides DV_ROOT.

    -model_dir=PATH
            absolute path to model root directory. this overrides MODEL_DIR.

    -tmp_dir=PATH
            path where temporary files such as debussy dumps will be created

    -sims_config=FILE
            full path to sims config file

    -sims_env=ENVAR=value
            force sims to set ENVAR variable to specified value.

    -env_base=PATH
            this specifies the root directory for the bench environment.
            it is typically defined in the bench config file. It has no
            default.

    -config_cpp_args=OPTION
            this allows the user to provide CPP arguments (defines/undefines)
            that will be used when the testbench configuration file is
            processed through cpp. Multiple options are concatenated
            together.

    -result_dir=PATH
            this allows the regression run to be launched from a different
            directory than the one sims was launced from. defaults to
            PWD.

    -diaglist=FILE
            full path to diaglist file

    -diaglist_cpp_args=OPTION
            this allows the user to provide CPP arguments (defines/undefines)
            that will be used when the diaglist file is processed through
            cpp. Multiple options are concatenated together.

    -asm_diag_name=NAME
    -tpt_diag_name=NAME
    -tap_diag_name=NAME
    -vera_diag_name=NAME
    -vera_config_name=NAME
    -efuse_image_name=NAME
    -image_diag_name=NAME
    -sjm_diag_name=NAME
    -pci_diag_name=NAME
            name of the diagnostic to be run.

    -asm_diag_root=PATH
    -tpt_diag_root=PATH
    -tap_diag_root=PATH
    -vera_diag_root=PATH
    -vera_config_root=PATH
    -efuse_image_root=PATH
    -image_diag_root=PATH
    -sjm_diag_root=PATH
    -pci_diag_root=PATH
            absolute path to diag root directory. sims will perform a find
            from here to find the specified type of diag. if more than one
            instance of the diag name is found under root sims exits with
            an error. this option can be specified multiple times to allow
            multiple roots to be searched for the diag.

    -asm_diag_path=PATH
    -tpt_diag_path=PATH
    -tap_diag_path=PATH
    -vera_diag_path=PATH
    -vera_config_path=PATH
    -efuse_image_path=PATH
    -image_diag_path=PATH
    -sjm_diag_path=PATH
    -pci_diag_path=PATH
            absolute path to diag directory. sims expects the specified
            diag to be in this directory. the last value of this option
            is the one used as the path.

ClearCase

    -clearcase
	  assume we are in ClearCase environment for setting DV_ROOT and
	  launching DReAM commands. default is off (CDMS++ version control)

    -noclearcase
	  force clearcase option off

    -cc_dv_root=PATH
            ClearCase path to design root directory. this overrides CC_DV_ROOT.

DReAM

Please refer to the drmsubmit man pages for more info on the following.

    -indrm
          resubmits any sims command to DReAM.

    -noindrm
          this is used in conjunction with -group to prevent a regression from
          being submitted to DReAM. this will effectively run each job serially
          on the local machine where the job was launched.
          e.g. sims -group=ciop_regr -noindrm

    -interactive
          resubmits any sims command to DReAM and runs it as an interactive session.
          this effectively adds -i -m to the drmsubmit command.

    -drm_type=ARG
          the type constraint for DReAM jobs. This constraint determines
          the queue where a job will be submitted. The project is hardcoded
          to be bw in sims. this deafults to vcs.

    -drm_constraints_file=FILE
          the file specifying constraints for DReAM jobs. If this option
          is specified, other -drm_* options are ignored.

    -drm_cpufreq=ARG
          the cpufreq constraint for DReAM jobs.

    -drm_disk=ARG
          the disk constraint for DReAM jobs.

    -drm_freeram=ARG
          the freeram constraint for DReAM jobs.

    -drm_freeswap=ARG
          the freeswap constraint for DReAM jobs.

    -drm_freeprocessor=ARG
          the free processor constraint for DReAM jobs.

    -drm_totprocessor=ARG
          the totprocessor constraint for DReAM jobs.

    -drm_priority=ARG
          the priority constraint for DReAM jobs.

    -drm_license=ARG
          the license constraint for DReAM jobs. this defaults to [vcs=1,vera=1].

ENV VARIABLES

sims sets the following ENV variables that may be used with pre/post
processing scripts, and other internal tools:

    ASM_DIAG_NAME   : Contains the assembly diag name.
    SIMS_LAUNCH_DIR : Path to launch directory where sims is running the
                      job. Useful when job is run in dream scratch space.
    VERA_LIBDIR     : Dir where Vera/NTB files are compiled or results are stored.
    DV_ROOT         : -dv_root if specifed
    MODEL_DIR       : -model_dir if specified
    TRE_SEARCH      : Based on -use_iver, -use_cdms_iver -use_sims_iver
    DENALI          : Based on configsrch 
    VCS_HOME        : Based on configsrch
    VERA_HOME       : Based on configsrch

PLUSARGS

+args are not implemented in sims. they are passed directly to vcs at
compile time and simv at runtime. the plusargs listed here are for
reference purposes only.

    +STACK_DIMM 32 bits physical address space - default is 31 bits

    +STACK_DIMM +RANK_DIMM 33 bits physical address space - default is 31 bits

    +max_cycle see -max_cycle
 
    +TIMEOUT   see -rtl_timeout
    
    +vcs+finish see -vcs_finish

    +wait_cycle_to_kill see -wait_cycle_to_kill

DESCRIPTION

sims is the frontend for vcs to run single simulations and regressions

HOWTO

Build models

Build a model using DV_ROOT as design root

  sims -sys=cmp -vcs_build

Build the vera testbench only using DV_ROOT as design root

  sims -sys=cmp -vera_build

Build a model from any design root

  sims -sys=cmp -vcs_build -dv_root=/home/regress/2002_06_03

Build a graft model from any design root

  sims -sys=cmp -vcs_build -dv_root=/model/2002_06_03 \
       -graft_flist=/regress/graftfile

Build a model and re-build the vera

  sims -sys=cmp -vcs_build -vera_clean

Build a model and turn off incremental compile

  sims -sys=cmp -vcs_build -vcs_clean

Build a model with a given name

  sims -sys=cmp -vcs_build -vcs_rel_name=mymodel

RUN MODELS

Run a diag with default model

  sims -sys=cmp -vcs_run diag.s

Run a diag with a specified model

  sims -sys=cmp -vcs_rel_name=mymodel -vcs_run diag.s

Run a diag with debussy dump with default model

  sims -sys=cmp -debussy -vcs_run diag.s <dump scope args>

Run a diag using arguments form specified alias in a diaglist

  sims -vcs_run -sys=spc2 -group isa_mt -alias=isa_mmu_21:isa_mt isa_mmu_21.s

Run regressions

Run a regression using DV_ROOT as design root

  sims -group=mini

Run a regression using DV_ROOT as design root and specify the diaglist

  sims -group=mini -diaglist=/home/user/my_dialist

Run a regression using any design root

  sims -group=mini -dv_root=/afara/design/regress/model/2002_06_03

Run a regression using any design root and a graft model

  sims -group=mini -dv_root=/regress/model/2002_06_03 \
       -graft_flist=/home/regress/graftfile

Rerun a diag in a regression (in new rerun_x subdir)

  sims -rerun

Rerun a diag, overwriting same directory

  sims -rerun -overwrite


EOF
}

# POD {{{
__END__

=pod

B<Sims(1.272) modified for release with OpenSparc T2 (SUN Niagara-2 Design)>


=head1 NAME

sims - Verilog rtl simulation environment and regression script 

=head1 SYNOPSIS

 sims [args ...]
  where args are:

B<IMPORTANT: Use "=" instead of "space" to separate args and their options.>

=head2 SIMULATION ENV

    -sys=NAME
            sys is a pointer to a specific testbench configuration
            to be built and run. a config file is used to associate
            the sys with a set of default options to build the
            testbench and run diagnostics on it. the arguments
            in the config file are the same as the arguments passed
            on the command line.
            
    -group=NAME
            group name identifies a set of diags to run in a
            regression. The presence of this argument indicates
            that this is a regession run. the group must be found
            in the diaglist. multiple groups may be specified to be
            run within the same regression.

            B<Note: If -sys=NAME option is specified then NAME.diaglist
                  is used as root diaglist instead of the master diaglist.>

    -group=NAME -alias=ALIAS
            this combination of options gets the diag run time options
            from the diaglist based on the given group and alias.
            the group must be found in the diaglist. the alias is
            made up of diag_alias:name_tag. only one group should be
            specified when using this command format.


=head2 VERILOG COMPILATION RELATED

    -sim_q_command="command ... ... ... "
	  'command' is essentially a script you have devised
	  that allows you to dispatch your job on a free available CPU resource
	  in an effort to parallelize your runs (which can be substantial in number
	  depending on how many diags or tests are declared in the diaglist file.
	  Defaults to /bin/sh and runs simulation jobs on local machine.

    -flist=FLIST
           full path to flist to be appended together to generate the
           final verilog flist. multiple such arguments may be used and
           each flist will be concatenated into the final verilog flist
           used to build the model.

    -graft_flist=GRAFTFILE
           GRAFTFILE is the full path to a file that lists each verilog
           file that will be grafted into the design. the full path to
           the verilog files must also be given in the GRAFTFILE.

    -vfile=FILE
           verilog file to be included into the flist

    -config_rtl=DEFINE
           each such parameter is place as a `define in config.v to
           configure the model being built properly. this allows
           each testbench to select only the rtl code that it needs
           from the top level rtl file (ciop.v in blackwidow).

    -model_rel_name=NAME
            specify the name of the simulation binary to be built. the full path
            to a model is $MODEL_DIR/$sys/$model_rel_name.


=head2 CADENCE's NC-VERILOG COMPILATION RELATED

    -ncv_build/-noncv_build
           builds a ncverilog model and the vera testbench. defaults to off.

    -ncv_build_args=OPTION
           ncverilog compile options. multiple options can be specified using
           multiple such arguments.
           
    -ncv_clean/-noncv_clean
           wipes out the model directory and rebuilds it from scratch.
           defaults to off.


=head2 SYNOPSYS' VCS COMPILATION RELATED

    -vcs_build/-novcs_build
           builds a vcs model and the vera testbench. defaults to off.

    -vcs_build_args=OPTION
           vcs compile options. multiple options can be specified using
           multiple such arguments.
           
    -vcs_clean/-novcs_clean
           wipes out the model directory and rebuilds it from scratch.
           defaults to off.

    -vcs_full64
           sets the vcs -full64 compile flag so that the compiler is a
           64 bit executable, and produces a 64 bit executable simv.
           will use the 64 bit version of vera, and link in the 64 bit
           versions of 0in, debussy, and denali tools.

    -vcs_use_initreg/-novcs_use_initreg
           initialize all registers to a valid state (1/0).
           this feature works with -tg_seed to set the seed of the random
           initialization. this defaults to off.

    -vcs_use_fsdb/-novcs_use_fsdb
           use the debussy fsdb pli and include the dump calls in the
           testbench. this defaults to on.

    -vcs_use_vcsd/-novcs_use_vcsd
           use the vcs direct kernel interface to dump out debussy files.
           this defaults to on.

    -vcs_use_vera/-novcs_use_vera
           compile in the vera libraries. if -vcs_use_ntb and -vcs_use_vera are
           used, -vcs_use_ntb wins.
           this defaults to off.

    -vcs_use_ntb/-novcs_use_ntb
           enable the use of NTB when building model (simv) and running simv.
           if -vcs_use_ntb and -vcs_use_vera are used, -vcs_use_ntb wins.
           this defaults to off.

    -vcs_use_rad/-novcs_use_rad
           use the +rad option when building a vcs model (simv).
           defaults to off.

    -vcs_use_sdf/-novcs_use_sdf
           build vcs model (simv) with an sdf file.
           defaults to off.

    -vcs_use_radincr/-novcs_use_radincr
           use incremental +rad when building a vcs model (simv).
           defaults to off.
           this is now permanently disabled as synopsys advises against
           using it.

    -vcs_use_cli/-novcs_use_cli
           use the +cli -line options when building a vcs model (simv).
           defaults to off.

           use this switch, in conjunction with -nosimslog during runtime
           if you need to pass ctrl-c to the vcs/axis model and continue
           with CLI activity.

           Use this with VCS versions before 2006.

    -vcs_use_ucli/-novcs_use_ucli (Unified cli)
           use the -debug_all option when building a vcs model (simv).
           defaults to off.

           use this switch, in conjunction with -nosimslog during runtime
           if you need to pass ctrl-c to the vcs/axis model and continue
           with UCLI activity.

           At runtime, use -vcs_run_arg=-ucli to get the UCLI at time zero,
           or          use -vcs_run_arg=-gui  to get the UCLI GUI at time zero.
           At runtime, use -vcs_run_arg=-tbug to get NTB debug in the GUI.

           Use this with VCS versions 2006 and up.


=head2 SYNOPSYS VERA/NTB COMPILATION RELATED

    VERA and NTB share all of the vera options except a few.
    See NTB RELATED section below.

    -vera_build/-novera_build
           builds the vera/ntb testbench. default on.

    -vera_clean/-novera_clean
           performs a gmake clean on the vera/ntb testbench before building
           the model. defaults to off.

    -vera_build_args=OPTION
           vera/NTB testbench compile time options.
           Multiple options can be specified using multiple such
           options. these are passed as arguments to the gmake call
           when building the vera/NTB testbench.
           (Eg: -vera_build_args=VERA_SYS_DEFS=\"-DSPC_BENCH -DGATESIM\")

           For NTB, -vera_build_args=NTB_BUILD_ARGS=\"+error+10 -ntb_define ABCD\"
           can be used to add something directly to the \"vcs -ntb_cmp\" command.
           For the -ntb_lib option, NTB_BUILD_ARGS will affect both the vshell and
           bench+diag builds. See -vera_diag_args to not affect the vshell build.


    -vera_diag_args=OPTION
           vera/ntb diag compile time options.
	       Multiple options can be specified using multiple such
           options.  For Vera, these args are appended to the
          \"vera -cmp ...\" command for the diag only.
          (Eg: -vera_diag_args=\"-max_error 10\" or -vera_diag_args=-DNCU_ACK_DLY1=100)

           For NTB, these args are passed as arguments to the gmake
           call as NTB_DIAG_ARGS=\" ...\" to be part of the NTB
           bench+diag compile. These NTB_DIAG_ARGS are appended to
           the \"vcs -ntb_cmp\" command when making the libtb.so so
           they better be legal in that context. For NTB, these args
           really affect the entire bench build, not just the diag,
           BUT they they do not affect the vshell build.
           (Eg. -vera_diag_args=+error+10 or -vera_diag_args=\"-ntb_define NCU_ACK_DLY1=100\")

    -vera_dummy_diag=PATH

           This option is used to give vera/NTB a path to a default
           diag or diag class (or a default program top if using RVM)
           that can be used for building purposes before an actual
           diag is chosen (NTB build of vshell file before regression
           for example).

           Also, some benches may run both asm and vera diags but the
           vera diags are only run sometimes. In this case, you need a
           dummy vera testcase class/program top to fill in when an
           actual vera diag is not being used for that run (aka the
           sometimes diag problem). If your openVera code refers to a
           testcase class, you better have one even if it does nothing
           else you will not be able to build. The dummy lets you
           build.  If your diag is implemented as the program top
           (RVM) then the dummy must have \#includes for ALL of your
           vera interfaces or your vshell will be broken.

           Whenever the actual vera/NTB diag is specified, the dummy
           is automatically *not* used (at regression time for
           example).  The vera_dummy_diag should be specified in the
           bench config file.  This option applies to Vera and NTB
           (but NTB only when using the -ntb_lib option).

    -vera_pal_diag_args=OPTION
           vera/ntb pal diag expansion options
	   (i.e. "pal OPTIONS -o diag.vr diag.vrpal")
	   multiple options can be specified using multiple such arguments.

    -vera_proj_args=OPTION
           vera proj file generation options. multiple options can be
           specified using multiple such arguments.

    -vera_vcon_file=ARG
           name of the vera vcon file that is used when running the simulation.

    -vera_cov_obj=OBJ
           this argument is passed to the vera Makefile as a OBJ=1 and to
           vera as -DOBJ to enable a given vera coverage object. multiple
           such arguments can be specified for multiple coverage objects.

    -vera_gmake/-novera_gmake
          this argument optionally lets the flow skip running gmake for the
          vera/NTB build, while maintaining other operations within the
          -vera_build flow. default ON (execute gmake)

=head2 NTB RELATED

    NTB and VERA share all of the vera options except these:

      -vcs_use_ntb/-novcs_use_ntb
             enable the use of NTB (compiled vera) rather than the
             conventional Vera.  if -vcs_use_ntb and -vcs_use_vera are
             used at once, then -vcs_use_ntb wins.  defaults to off.

      -ntb_lib/-nontb_lib
             enables the NTB 2 part compile where the openVera files
             get compiled separately into a libtb.so file which is
             dynamically loaded by vcs at runtime. The libtb.so file
             is built by the Vera/NTB Makefile, not sims. Use the
             Makefile to affect the build. If not using -ntb_lib, sims
             will build VCS and the openVera files together in one
             pass (uses Makefile to affect that build as well). default
             is off.

             The ntb_lib method is know as the NTB LIB method. When not
             using this ntb_lib method, the ALL IN ONE method is used.

             The NTB LIB method allows the bench to run unique openVera diags
             that are separate from the bench (via a diaglist if desired).

             The NTB ALL IN ONE method does not allow the bench to run
             unique openVera diags that are separate from the bench.
             Use this for benches that do not run openVera diags
             (perhaps the bench only runs asm diags

=head2 SYNOPSYS VERA RUNTIME RELATED

    -vera_run/-novera_run
            runs the ncverilog/vcs simulation and loads in the vera proj file
            or the ntb libtb.so file. defaults to on.


=head2 VERILOG RUNTIME RELATED


=head2 NCSIM (CADENCE's NC-VERILOG) RELATED

    -ncv_run/-noncv_run
           runs the NC-Verilog simulation (ncsim). defaults to off.

    -ncv_run_args=OPTION
           ncsim runtime options. multiple options can be specified
           using multiple such arguments.
                  
    -rerun
           rerun the simulation from an existing regression run directory.
	   you can just say "% sims -rerun", and sims will automatically
	   extract the required arguments.

    -overwrite
           overwrite current run dir when doing a -rerun. default is to 
           create a rerun_<n> subdir for reruns.

    -debussy/-nodebussy
           enable debussy dump. this must be implemented in the testbench
           to work properly. defaults to off.

=head2 SIMV (SYNOPSYS's VCS) RELATED


    -vcs_run/-novcs_run
           runs the VCS simulation (simv). defaults to off.

    -vcs_run_args=OPTION
           simv runtime options. multiple options can be specified
           using multiple such arguments.

    -vcs_finish=TIMESTAMP
           forces vcs to finish and exit at the specified timestamp.

    -fast_boot/-nofast_boot
           speeds up booting when using the ciop model. this passes the
           +fast_boot switch to the simv run and the -sas_run_args=-DFAST_BOOT
           and -midas_args=-DFAST_BOOT to sas and midas. Also sends
           -DFAST_BOOT to the diaglist and config file preprocessors.

    -debussy/-nodebussy
           enable debussy dump. this must be implemented in the testbench
           to work properly. defaults to off.

    -start_dump=START
           start dumping out a waveform after START number of units

    -stop_dump=STOP
           stop dumping out a waveform after STOP number of units

    -fsdb2vcd
           runs fsdb2vcd after the simulation has completed to generate a vcd file.

    -fsdbfile=filename
           the name of the debussy dump file.
	   If the file name starts with a "/", that is the file dumped to,
	   otherwise, the actual file is created within the temporary cache
           directory and copied over to the run directory when the simulation ends.
	   Use "-fsdbfile=`pwd`/filename" to force the file to be
	   written in the current directory directly (not efficient since
	   dumping is done over network instead of to a local disk).

    -fsdbDumplimit=SIZE_IN_MB
	   max size of Debussy dump file.  minimum value is 32MB.
	   Latest values of signal values making up that size is saved.

    -fsdb_glitch
           turn on glitch and sequence dumping in fsdb file. this will collect
           glitches and sequence of events within time in the fsdb waveform.
           beware that this will cause the fsdb file size to grow significantly.
           this is turned off by default. this option effectively does this:
           setenv FSDB_ENV_DUMP_SEQ_NUM 1
           setenv FSDB_ENV_MAX_GLITCH_NUM 0

    -rerun
           rerun the simulation from an existing regression run directory.
	   you can just say "% sims -rerun", and sims will automatically
	   extract the required arguments.

    -overwrite
           overwrite current run dir when doing a -rerun. default is to 
           create a rerun_<n> subdir for reruns.

    -post_process_cmd=COMMAND
           post processing command to be run after simv / ncsim ends

    -pre_process_cmd=COMMAND
           pre processing command to be run before simv / ncsim starts

    -use_denalirc=FILE
          use FILE as the .denalirc in the run area. Default copies
          $env_base/.denalirc

    -vcd/-novcd 
           signals the bench to dump in VCD format

    -vcdfile=filename
           the name of the vcd dump file.  if the file name starts with
           a "/", that is the file dumped to, otherwise, the actual file is
           created within the temporary cache directory and copied over to
           the run directory when the simulation ends.  use "-vcdfile=`pwd`/filename"
           to force the file to be written in the current directory directly
           (not efficient since dumping is done over network instead of to
           a local disk).

=head2 SUNV OPTIONS

         -sunv_run/-nosunv_run
                runs the sunv program to convert structural files,
                e.g. <file>.sv to verilog. defaults to off.

         -sunv_args=ARGS
                sunv options. Multiple options can be specified using
                multiple such arguments.  In addition, a portion of
                these arguments can be provided in a file using the
                sunv option -optfile=<file>.

         -sunv_use_nonprim/-nosunv_use_nonprim
                use a list to hold primitives that we want to remove from the
                default primitive.list. defaults to off.

         -sunv_nonprim_list=FILE
                name of file holding the list of primitives that we want to remove.
                this is only used if -sunv_use_nonprim is specified.

=head2 VLINT OPTIONS

         -vlint_run/-novlint_run
                runs the vlint program. defaults to off.

         -vlint_args
                vlint options. The <sysName>.config file can contain
                the desired vlint arguments, or they can also be given on
                the command line.  Typically the -vlint_compile is given
                on the command line.

                vlint also requires identification of a rules deck.

         -illust_run
                run illust after x2e

         -illust_args
                illust options

	-vlint_top
                top level module on which to run vlint

=head2 VERIX OPTIONS

    -verix_run/-noverix_run
           runs the verix program. defaults to off.

    -verix_libs
           specify the library files to add to the vlist

    -verix_args
           verix template options. The <sysName>.config file can contain
           these desired verix arguments

           verix also requires <top>.verix.tmplt in the config dir.

    -verix_top
           top level module on which to run verix


=head2 THARAS HAMMER RELATED

    -hcs_build
           build a model to be run on the Hammer Hardware Accelerator.

    -hcs_build_args
           build arguments for Hammer Hardware Accelerator

    -hcs_run
           run a model on the Hammer Hardware Accelerator.

    -hcs_run_args
           run arguments for the Hammer Hardware Accelerator.

    -hcs_drm_tokens
           tokens for drmsubmit licenses 

=head2 AXIS RELATED

    -axis_build
           build a model to be run on the Axis Hardware Accelerator.

    -axis_build_args
           build arguments for Axis Hardware Accelerator

    -axis_run
           run a model on the Axis Hardware Accelerator.

    -axis_run_args
           run arguments for the Axis Hardware Accelerator.

=head2 PALLADIUM RELATED

    -palladium_build
           build a model to be run on the palladium Hardware Accelerator.

    -palladium_build_args
           build arguments for palladium Hardware Accelerator

    -palladium_run
           run a model on the palladium Hardware Accelerator.

    -palladium_run_args
           run arguments for the palladium Hardware Accelerator.


=head2 ZEROIN RELATED

    -zeroIn_checklist
           run 0in checklist

    -zeroIn_build
           build 0In pli for simulation into ncverilog/vcs model

    -zeroInSearch_build
           build 0in search pli for simulation into ncverilog/vcs model

    -zeroIn_build_args
           additional arguments to be passed to the 0in command

    -zeroIn_dbg_args
           additional debug arguments to be passed to the 0in shell

=head2 SAS/SIMICS RELATED 

    -sas/-nosas
           run architecture-simulator. If vcs_run/ncv_run option is OFF,
           simulation is sas-only. If vcs_run/ncv_run option is ON, sas
           runs in lock-step with rtl. default to off.

    -sas_run_args=DARGS
           Define arguments for sas.

=head2 TCL/TAP RELATED 

    -tcl_tap/-notcl_tap
           run tcl/expect TAP program. If vcs_run option is OFF,
           simulation is tcl-only. If vcs_run/ncv_run option is ON, tcl
           runs in lock-step with rtl. default to off.
	   NOTE: You _must_ compile with -tcl_tap as well, to enable
		 to enable functions that are needed for running with tcl

    -tcl_tap_diag=diagname
           Define top level tcl/expect diag name.

=head2 MIDAS

midas is the diag assembler
 
    -midas_args=DARGS
           arguments for midas. midas creates memory image and user-event
           files from the assembly diag.

    -midas_only
           Compile the diag using midas and exit without running it.

    -midas_use_tgseed
           Add -DTG_SEED=tg_seed to midas command line. Use -tg_seed to
           set the value passed to midas or use a random value from /dev/random.

=head2 PCI

pci is the tomatillo pci bus functional model

    -pci_args
           arguments to be passed in to pci_cmdgen.pl for generation of a pci
           random diagnostic.

    -pci/-nopci
           generates a random pci diagnostic using the -tg_seed if provided.
           default is off.

    -tomatillo
           generates a random tomatillo diagnostic using the -tg_seed if provided

    -tg_seed
           random generator seed for pci/tomatillo random test generators
           also the value passed to +initreg+ to randomly initialize registers
           when -vcs_use_initreg is used.

=head2 SJM

sjm is the jalapeno jbus bus functional model

    -sjm_args
           arguments to be passed in to sjm_tstgen.pl for generation of an sjm
           random diagnostic.

    -sjm/-nosjm
           generates a random sjm diagnostic using the -tg_seed if provided.
           default is off.

    -tomatillo
           generates a random tomatillo diagnostic using the -tg_seed if provided

    -tg_seed
           random generator seed for sjm/tomatillo random test generators
           also the value passed to +initreg+ to randomly initialize registers
           when -vcs_use_initreg is used.

=head2 EFCGEN

efcgen.pl is a script to generate efuse.img files (default random),
which is used by the efuse controller after reset.
It is invoked by -efc.

    -efc/-noefc
           generates an efuse image file using the -tg_seed if provided.
           default is off.  Random if no -efc_args specified.

    -efc_args
           arguments to be passed in to efcgen.pl for generation of
	       an efuse image file.
	       Default is random efuse replacement for each block.

    -tg_seed
           random generator seed for efcgen.pl script
           also the value passed to +initreg+ to randomly initialize
	       registers when -vcs_use_initreg is used.

=head2 VCS COVERAGE METRICS

    -vcs_use_cm/-novcs_use_cmd
           passes in the -cm switch to vcs at build time and simv at runtime
           default to off.

    -vcs_cm_args=ARGS
           argument to be given to the -cm switch

    -vcs_cm_cond=ARGS
           argument to be given to the -cm_cond switch.

    -vcs_cm_config=ARGS
           argument to be given to the -cm_hier switch

    -vcs_cm_fsmcfg=ARGS
           argument to be given to the -cm_fsmcfg switch
	   specifies an FSM coverage configuration file

    -vcs_cm_name=ARGS
           argument to be given to the -cm_name switch. defaults to cm_data.

=head2 DFT 

    -dftvert
          modifies the sims flow to accomodate dftvert. this skips compiling
          the vera testbench and modifies the simv command line at runtime.

=head2 CDMS 

    -cdms_rel_name=CDMSREL
           specify the cdms++ release that must be collected for this model.

    -diff_cdms_rel
          performs a diff_release of CDMSREL from -cdms_rel_name and
          records it in a file called diff_rel.log lcoated in the model
          area. This file is copied into each run directory from the
          model area at runtime. 

    -diff_cdms_curr
          uses the current (in localdir) release of CDMSREL for the
          diff_release command. Ignored if -cdms_rel_name and -diff_cdms_rel
          are not specified.

=head2 MISC 

    -regress
          pretend this is a regression and run the job in DRMJOBSCRATCHSPACE
          instead of the launch directory. useful with -indrm and 
          -interactive options and single jobs. automatically added for
          regressions.

    -nobuild
          this is a master switch to disable all building options.
          there is no such thing as -build to enable all build options.

    -diag_pl_args=ARGS
          If the assembly diag has a Perl portion at the end, it
	  is put into diag.pl and is run as a Perl script.
	  This allows you to give arguments to that Perl script.
	  The arguments accumulate, if the option is used multiple
	  times.

    -pal_use_tgseed
           Send '-seed=<tg_seed_value> to pal diags.  Adds
           -pal_diag_args=-seed=tg_seed to midas command line, and
           -seed=tg_seed to pal options (vrpal diags). Use -tg_seed to set
           the value passed to midas or use a random value from /dev/random.

    -reg_count=COUNT
            runs the specified group multiple times in regression mode. this
            is useful when we want to run the same diag multiple times using
            a different random generator seed each time or some such.

    -regress_id=ID
            specify the name of the regression

    -report
            This flag is used to produce a report of a an old or running
            regression. With -group options, sims produces the report
            after the regression run. Report for the previous
            regression run can be produced using -regress_id=ID
            option along with this option,

    -finish_mask=MASK
           masks for ncsim/vcs simulation termination. Simulation terminates
           when it hits 'good_trap' or 'bad_trap'. For multithread
           simulation, simulation terminates when any of the thread
           hits bad_trap, or all the threads specified by the finish_mask
           hits the good_trap.
           example: -finish_mask=0xe
           Simulation will be terminated by good_trap, if thread 1, 2 and
           3 hits the good_trap.

    -stub_mask=MASK
           mask for ncsim/vcs simulation termination. Simulation ends when the
           stub driving the relevant bit in the mask is asserted. This
           is a hexadecimal value similar to -finish_mask

    -wait_cycle_to_kill=VAL
           passes a +wait_cycle_to_kill to the simv run. a testbench
           may chose to implement this plusarg to delay killing a
           simulation by a number of clock cycles to allow collection
           of some more data before exiting (e.g. waveform).

    -rtl_timeout
           passes a +TIMEOUT to the simv run.
           sets the number of clock cycles after all threads have become
           inactive for the diag to exit with an error. if all threads hit
           good trap on their own the diag exits right away. if any of the
           threads is inactive without hitting good trap/bad trap the
           rtl_timeout will be reached and the diag fails. default is 1000.
           this is only implemented in the cmp based testbenches.

    -max_cycle
           passes a +max_cycle to the simv run.
           sets the maximum number of clock cycle that the diag will take
           to complete. the default is 30000. if max_cycle is hit the diag
           exits with a failure. not all testbenches implement this
           feature.

    -norun_diag_pl
           Does not run diag.pl (if it exists) after ncsim snapshot or VCS simv run.
           Use this option if, for some reason, you want to run an
	       existing assembly diag without the Perl part that is in
	       the original diag.

    -nosaslog
           turns off redirection of sas stdout to the sas.log file.
           use this option when doing interactive runs with sas.

    -nosimslog
           turns off redirection of stdout and stderr to the sims.log
           file.  use this option in conjunction with -vcs_use_cli or
           -vcs_use_ucli to get to the cli prompt when using vcs or to
           see a truncated vcs.log file that exited with an
           error. this must be used if you want control-c to work
           while vcs is running.

    -nogzip
           turns off compression of log files before they are copied over
           during regressions.

    -version
            print version number.

    -help
            prints this

=head2 IT SYSTEM RELATED

    -use_iver=FILE
            full path to iver file for frozen tools

    -use_sims_iver/-nouse_sims_iver
            For reruns of regression tests only, use sims.iver to choose
            TRE tool versions saved during original regression run.
            Defaults to true.

    -use_cdms_iver/-nouse_cdms_iver
            Uses the frozen iver file located under $DV_ROOT if present.
            This defaults to true. This has no effect if an iver file
            is not found under the cdms tree.

    -dv_root=PATH
            absolute path to design root directory. this overrides $DV_ROOT.

    -model_dir=PATH
            absolute path to model root directory. this overrides $MODEL_DIR.

    -sims_config=FILE
            full path to sims config file

    -sims_env=ENVAR=value
            force sims to set ENVAR variable to specified value.

    -env_base=PATH
            this specifies the root directory for the bench environment.
            it is typically defined in the bench config file. It has no
            default.

    -config_cpp_args=OPTION
            this allows the user to provide CPP arguments (defines/undefines)
            that will be used when the testbench configuration file is
            processed through cpp. Multiple options are concatenated
            together.

    -result_dir=PATH
            this allows the regression run to be launched from a different
            directory than the one sims was launced from. defaults to
            $ENV{PWD}.

    -diaglist=FILE
            full path to diaglist file

    -diaglist_cpp_args=OPTION
            this allows the user to provide CPP arguments (defines/undefines)
            that will be used when the diaglist file is processed through
            cpp. Multiple options are concatenated together.

    -asm_diag_name=NAME
    -tpt_diag_name=NAME
    -tap_diag_name=NAME
    -vera_diag_name=NAME
    -vera_config_name=NAME
    -efuse_image_name=NAME
    -image_diag_name=NAME
    -sjm_diag_name=NAME
    -pci_diag_name=NAME
            name of the diagnostic to be run.

    -asm_diag_root=PATH
    -tpt_diag_root=PATH
    -tap_diag_root=PATH
    -vera_diag_root=PATH
    -vera_config_root=PATH
    -efuse_image_root=PATH
    -image_diag_root=PATH
    -sjm_diag_root=PATH
    -pci_diag_root=PATH
            absolute path to diag root directory. sims will perform a find
            from here to find the specified type of diag. if more than one
            instance of the diag name is found under root sims exits with
            an error. this option can be specified multiple times to allow
            multiple roots to be searched for the diag.

    -asm_diag_path=PATH
    -tpt_diag_path=PATH
    -tap_diag_path=PATH
    -vera_diag_path=PATH
    -vera_config_path=PATH
    -efuse_image_path=PATH
    -image_diag_path=PATH
    -sjm_diag_path=PATH
    -pci_diag_path=PATH
            absolute path to diag directory. sims expects the specified
            diag to be in this directory. the last value of this option
            is the one used as the path.

=head2 ClearCase

    -clearcase
	  assume we are in ClearCase environment for setting DV_ROOT and
	  launching DReAM commands. default is off (CDMS++ version control)

    -noclearcase
	  force clearcase option off

    -cc_dv_root=PATH
            ClearCase path to design root directory. this overrides $CC_DV_ROOT.

=head2 DReAM

Please refer to the drmsubmit man pages for more info on the following.

    -indrm
          resubmits any sims command to DReAM.

    -noindrm
          this is used in conjunction with -group to prevent a regression from
          being submitted to DReAM. this will effectively run each job serially
          on the local machine where the job was launched.
          e.g. sims -group=ciop_regr -noindrm

    -interactive
          resubmits any sims command to DReAM and runs it as an interactive session.
          this effectively adds -i -m to the drmsubmit command.

    -drm_type=ARG
          the type constraint for DReAM jobs. This constraint determines
          the queue where a job will be submitted.

    -drm_constraints_file=FILE
          the file specifying constraints for DReAM jobs. If this option
          is specified, other -drm_* options are ignored.

    -drm_cpufreq=ARG
          the cpufreq constraint for DReAM jobs.

    -drm_disk=ARG
          the disk constraint for DReAM jobs.

    -drm_freeram=ARG
          the freeram constraint for DReAM jobs.

    -drm_freeswap=ARG
          the freeswap constraint for DReAM jobs.

    -drm_freeprocessor=ARG
          the free processor constraint for DReAM jobs.

    -drm_totprocessor=ARG
          the totprocessor constraint for DReAM jobs.

    -drm_priority=ARG
          the priority constraint for DReAM jobs.

    -drm_license=ARG
          the license constraint for DReAM jobs. this defaults to [vcs=1,vera=1].

=head2 ENV VARIABLES

sims sets the following ENV variables that may be used with pre/post
processing scripts, and other internal tools:

    ASM_DIAG_NAME   : Contains the assembly diag name.
    SIMS_LAUNCH_DIR : Path to launch directory where sims is running the
                      job. Useful when job is run in dream scratch space.
    VERA_LIBDIR     : Dir where Vera/NTB files are compiled or results are stored.
    DV_ROOT         : -dv_root if specifed
    MODEL_DIR       : -model_dir if specified
    TRE_SEARCH      : Based on -use_iver, -use_cdms_iver -use_sims_iver
    DENALI          : Based on configsrch 
    NCV_HOME        : Based on configsrch
    CDS_INST_DIR    : Based on configsrch

=head2 PLUSARGS

+args are not implemented in sims. they are passed directly to ncverilog / vcs at
compile time and the simulation snapshot (or executable) called
inca*pak / simv at runtime. the plusargs listed here are for
reference purposes only.

    +STACK_DIMM 32 bits physical address space - default is 31 bits

    +STACK_DIMM +RANK_DIMM 33 bits physical address space - default is 31 bits

    +max_cycle see -max_cycle
 
    +TIMEOUT   see -rtl_timeout
    
    +vcs+finish see -vcs_finish

    +wait_cycle_to_kill see -wait_cycle_to_kill

=head1 DESCRIPTION

sims is the frontend for Synopsys' VCS and Cadence's NC-Verilog to run single simulations and also regressions

=head1 HOWTO

=head2 Build models

Build a model using $DV_ROOT as design root

  % sims -sys=cmp1 -vcs_build -vera_build        // use Synopsys' VCS simulator
  % sims -sys=cmp1 -ncv_build -vera_build        // use Cadence's NC-Verilog simulator (ncvlog+ncelab+ncsim)
  % sims -sys=cmp8 -vcs_build -vera_build
  % sims -sys=fc1 -vcs_build -vera_build
  % sims -sys=fc8 -vcs_build -vera_build


[ Here, cmp1 means compiling 1 sparc core only, crossbar and Level 2 cache RTL.
	cmp8 means compiling 8 sparc cores, crossbar and Level 2 cache RTL.
	fc1 means compiling 1 sparc core only, crossbar, Level 2 cache RTL, memory controller unit RTL, as well as all of the system-on-chip components that goes on the chip
	fc8 means compiling 8 sparc cores, crossbar, Level 2 cache RTL, memory controller unit RTL, as well as all of the system-on-chip components that goes on the chip
	*** fc8 is essentially the entire Niagara-2 chip.
]


Build a model from any design root

  % sims -sys=cmp1 -vcs_build -dv_root=/home/username/cdmspp_localdir1

Build a model and re-build the vera

  % sims -sys=cmp1 -vcs_build -vera_clean -vera_build

Build a model and turn off incremental compile, i.e. re-build the vcs binary

  % sims -sys=cmp1 -vcs_build -vcs_clean

Build a model with a given name

  % sims -sys=cmp1 -vcs_build -model_rel_name=vcs_binary_no_1

=head2 Run models

Run a diag with a specified model

  % sims -sys=cmp1 -model_rel_name=vcs_binary_no_1 -vcs_run diag.s

Run a diag with debussy dump ON with default model (dump certain scopes only, 
the scope definitions are defined inside the file :/verif/env/cmp/dump_scope.vh )

  % sims -sys=cmp1 -debussy -vcs_run diag.s -model_rel_name=vcs_binary_no_1 \
	-vcs_run_args=+DUMP_LIMIT \
        -vcs_run_args=+DUMP_ENV -vcs_run_args=+DUMP_MCU \
        -vcs_run_args=+DUMP_L2_0 -vcs_run_args=+DUMP_L2_1
  

=head2 Run regressions

Run a regression using $DV_ROOT as design root

  % sims -sys=cmp1 -group=cmp1_all_T2 			// using a VCS binary
  % sims -sys=cmp1 -group=cmp1_all_T2 -sim=ncv 		// using a NC-Verilog snapshot

  Some other examples, e.g. at the fullchip level
  % sims -sys=fc1 -group=fc1_all_T2
  % sims -sys=fc8 -group=fc8_all_T2

Run a regression using $DV_ROOT as design root and specify the diaglist

  % sims -sys=cmp1 -group=cmp1_mini_T2 -diaglist=/home/username/cdmspp_localdir/dialist

Run a regression using any design root

  % sims -sys=cmp1 -group=cmp1_mini_T2 -dv_root=/home/username/cdmspp_localdir

Run a regression using any design root and a graft model

  % sims -sys=cmp1 -group=cmp1_mini_T2 -dv_root=/home/username/cdmspp_localdir \
       -graft_flist=/home/regress/graftfile

Rerun a diag in a regression (results will be put inside a new rerun_<N> subdir)
Command to be issued from inside the original run directory

  % sims -rerun

Rerun a diag, overwriting the original run directory

  % sims -rerun -overwrite



=head1 Example Makefile showing NTB usage

 ################################################################################
 ## Description:
 ## -----------
 ## Top level Makefile for compiling Vera/NTB environment.
 ## runs with "gmake" only, not with "make".
 ##
 ## See sims help for standard Makefile example
 ##
 ################################################################################
 
 # To do a quick NTB compile after source changes, do this. It is faster than running sims.
 # gmake VERA_SYS_DEFS="-DSPC_BENCH" NTB_DIAG=wherever/diag.vr ntb_diag
 # If you are using these provided defines below (USE_NTB_ALL or USE_NTB_LIB)
 # then add USE_NTB_LIB=1, etc, to gmake call.
 #
 
 # what does sims pass in to gmake?
 # If using the two pass libtb.so method:
 # 1) If you use this in your config file, -vera_build_args=VERA_SYS_DEFS="-DSPC_BENCH"
 #    then gmake passes VERA_SYS_DEFS="-DSPC_BENCH"
 # 2) Path to "diag" or a dummy diag. NTB_DIAG=/import/n3-aus-dump1/jp148204/wrk1/r1/diag.vr
 # 3) Sets this define, USE_NTB_LIB=1
 # 4) ntb_diag as the 'target'
 # 5) Your vera program block must be called vera_top!!!
 #
 # If using the all-in-one compile method:
 # 1) If you use this in your config file, -vera_build_args=VERA_SYS_DEFS="-DSPC_BENCH"
 #    then gmake passes VERA_SYS_DEFS="-DSPC_BENCH"
 # 2) Sets this define, USE_NTB_ALL=1
 # 3) ntb_all as the 'target'
 # 4) Your vera program block should be called vera_top
 
 # To enable RVM, use -vera_build_args=USE_RVM=1 in your config file.
 # This Makefile does not support non-NTB + RVM.
 
 
 ################################################################################
 # variable declarations
 ################################################################################
 
 .SUFFIXES:
 
 
 # CHANGE THIS LINE  vvvvv  <------------------
 SYS_NAME         ?= sparc
 # CHANGE THIS LINE  ^^^^^  <------------------
 
 
 
 ECHO           := echo
 COPY_CMD        = cp -pf $< $@ 
 SPACE          := $(EMPTY) $(EMPTY)
 # sims over-rides this. Do not remove.
 VERA_LIBDIR    ?= ${PWD}/lib
 # NOT for users to use, ONLY CONFIG FILE and sims. Do not remove.
 VERA_SYS_DEFS  ?=
 NTB_BUILD_ARGS ?=
 NTB_DIAG_ARGS  ?=
 # NOT for users to use, ONLY SIMS. For special 2 pass vcs options. Do not remove.
 VCS_USE_CLI    ?=
 VCS_USE_VCSD   ?=
 
 
 # These 3 defines are for any user to use and over-ride at will.
 # Example:
 # -vera_build_args="VERA_DEFS2=-DMYDEFINE -DTHIS" for either NTB or vera.
 # -vera_build_args="VERA_DEFS2=-ntb_define THIS THAT" will work if NTB ONLY.
 VERA_DEFS       ?=
 VERA_DEFS2      ?=
 # User options that need to be applied when making libtb.so file AND the simv file.
 TWOPASS_OPTION  ?=
 
 
 # other compile options that users could possibly over-ride, CAREFULLY.
 # NTB_OPTS
 # VERA_DEBUG
 # DEBUG
 
 # Use -vera_build_args=VERA_DEBUG=1
 ifdef USE_VERA_DEBUG
   VERA_DEBUG    ?= -g
 endif
 
 # use -vera_build_args=TEST=1
 ifdef TEST
   TESTING := test
 else
   TESTING :=
 endif
 
 
 #############################################
 # PATHS & FILES SPECIFIC TO YOUR BENCH      #
 # These are places where files can be found #
 #############################################
 BENCH_DIR      := ${DV_ROOT}/verif/env/$(SYS_NAME)/vera
 COMMON_VERA    := ${DV_ROOT}/verif/env/common/vera
 COMMON_VERILOG := ${DV_ROOT}/verif/env/common/verilog
 COMMON_RTL     := ${DV_ROOT}/design/sys/cpu_common
  
 # VPATH holds all paths to all include files. Do not change VPATH name or delete it!!!
 # This path is searched by gmake/vera/vcs, IN ORDER, until include file is found.
 # !!! KEEP UP TO DATE !!!
  
 VPATH          := $(BENCH_DIR) $(BENCH_DIR)/interfaces $(BENCH_DIR)/include \
 $(BENCH_DIR)/classes $(COMMON_VERA)/include $(COMMON_VERA)/classes $(COMMON_VERA) $(COMMON_RTL)/include
 
 # All files that we want to *compile*.
 # Files will be processed IN THIS ORDER. Put base classes first, etc.
 # If Vera, will get fresh .vro files made from these files if the .vr has changed
 # or any vrh/vri has changed. If NTB, all will be compiled but only if needed.
 # 
 # NTB needs a list with FULL PATH, so ALWAYS use FULL PATH!
 ORDERD_SRC_LIST   := \
 $(COMMON_VERA)/classes/std_display_class.vr \
 $(COMMON_VERA)/classes/baseParamsClass.vr \
 $(COMMON_VERA)/classes/sparcParams.vr \
 $(COMMON_VERA)/classes/memArray.vr \
 $(COMMON_VERA)/classes/l1tag.vr \
 $(COMMON_VERA)/classes/baseUtilsClass.vr \
 $(COMMON_VERA)/ccxDevices/ccxDevBaseBFM.vr \
 $(COMMON_VERA)/ccxDevices/ccxDevMemBFM.vr \
 $(COMMON_VERA)/classes/sparcBenchUtils.vr \
 $(BENCH_DIR)/classes/utilsClass.vr \
 $(BENCH_DIR)/classes/sparcEnv.vr \
 $(COMMON_VERA)/ccxDevices/basePktClass.vr \
 $(COMMON_VERA)/ccxDevices/cpxPktClass.vr \
 $(COMMON_VERA)/ccxDevices/pcxPktClass.vr \
 $(COMMON_VERA)/ccxDevices/ccxPktMon.vr
 
 # The bench_top.vr file and the vera/NTB diag...
 
 # default bench top for vera/ntb
 BENCH_TOP  = $(BENCH_DIR)/spc2_top.vr
 
 # If using NTB all-in-one compile method (no vera diags), the top is straightforward.
 # NTB_DIAG will not be defined.
 ifdef USE_NTB_ALL
 BENCH_TOP  = $(BENCH_DIR)/sparc_top.vr
 endif
 
 # If using ntb_lib (libtb.so) method, there may be a diag and the diag
 # and top may be the same (common with RVM method). This is up to the developer.
 ifdef USE_NTB_LIB
 # If your diag is a class or task definition then you will have a permanent top
 # and a potential diag so use the next 2 lines.
 # BENCH_TOP += $(BENCH_DIR)/sparc_top.vr
 # ORDERD_SRC_LIST  += $(NTB_DIAG)
 # Otherwise, if your diag is *also* the bench top (common with RVM method),
 # then BENCH_TOP and NTB_DIAG are the same. We will use the passed in NTB_DIAG
 # as the BENCH_TOP.
 BENCH_TOP += $(NTB_DIAG)
 endif
 
 ORDERD_SRC_LIST  += $(BENCH_TOP)
 
 ##############################
 ### NTB ONLY ###
 ##############################
 # make an include path list so files can be found.
 NTB_INCDIR     := $(subst $(SPACE),"+",$(VPATH))
 
 # -ntb_opts are compile time opts
 NTB_OPTS       ?= -ntb_opts check+dep_check+tb_timescale=1ps/1ps+partsel+compat
 ifdef USE_RVM
 NTB_OPTS       += +rvm
 endif
 # nullcheck   for debug but is SLOW
 
 # If defines come in as -DTHIS then make them NTB style
 NTB_DEFS       := $(subst -D,-ntb_define$(SPACE),$(VERA_DEFS))
 NTB_DEFS       += $(subst -D,-ntb_define$(SPACE),$(VERA_DEFS2))
 NTB_DEFS       += $(subst -D,-ntb_define$(SPACE),$(VERA_SYS_DEFS))
 
 # applies to the libtb.so compile AND the all-in-one compile.
 NTB_COMMON     := -ntb_define NTB $(NTB_DEFS) \
 -ntb_filext .vr+.vrh+.vri+.vrl+.vh+ $(NTB_OPTS) -ntb_incdir $(NTB_INCDIR) \
 +define+NTB $(NTB_BUILD_ARGS) $(ORDERD_SRC_LIST) 
 
 # How to compile VCS for lib file use. This will create a $(VERA_LIBDIR)/ntb_flist
 # file that sims uses directly when doing the VCS build (using the vshell).
 NTB_LIB_FLIST  := -ntb_vl $(TWOPASS_OPTION) $(VCS_USE_CLI) $(VCS_USE_VCSD) \
 +define+NTB +define+NTB_LIB $(VERA_LIBDIR)/${SYS_NAME}_top_shell.v
 
 # command to do the libtb.so file compile and to do the vshell compile.
 NTB_LIB_COMPILE  := vcs -ntb_cmp $(TWOPASS_OPTION) $(VCS_USE_CLI) $(VCS_USE_VCSD) \
 -ntb_sfname ${SYS_NAME}_top_shell.v -ntb_sname vera_top -ntb_spath $(VERA_LIBDIR) \
 +error+5 -ntb_define NTB_LIB $(NTB_COMMON) 
 
 # How to compile NTB and VCS together at once (all-in-one method).
 # This will create a $(VERA_LIBDIR)/ntb_flist file that sims
 # uses directly when doing the VCS build.
 NTB_ALL_FLIST  :=  -ntb $(NTB_COMMON) +define+NTB_ALL
 
 
 ##############################
 ### VERA & NTB ###
 ##############################
 DEPENDENCIES   := $(foreach dir,$(VPATH),$(wildcard $(dir)/*.vr?))
 
 
 ##############################
 ### VERA ONLY ###
 ##############################
 # all .vr files without full path
 ORDERD_LIST    := $(notdir $(ORDERD_SRC_LIST))
 # ORDERD_VRH     := $(patsubst %.vr,$(VERA_LIBDIR)/%.vrh,$(ORDERD_LIST))
 # targets list. .vro's we want to make.
 ORDERD_VRO     := $(patsubst %.vr,$(VERA_LIBDIR)/%.vro,$(ORDERD_LIST))
 EMPTY          :=
 VERA_OPTS      ?= -max_error 5 -q
 VERA_INCDIR    := $(subst $(SPACE),$(SPACE)-I,$(VPATH))
 VERA_INCDIR    := -I$(VERA_INCDIR) -I$(VERA_LIBDIR)
 VERA_VRH       := vera -cmp $(VERA_INCDIR) $(VERA_OPTS) -hnu $(VERA_DEFS) $(VERA_DEFS2) $(VERA_DEFS3) $(VERA_SYS_DEFS) $(LOCAL_DEFS)
 VERA_VRO       := vera -cmp $(VERA_INCDIR) $(VERA_OPTS) $(VERA_DEFS) $(VERA_DEFS2) $(VERA_DEFS3) $(VERA_SYS_DEFS) $(LOCAL_DEFS) $(VERA_DEBUG)
 
 
 
 ################################################################################
 # targets
 ################################################################################
 # default target is vera
 all: vera
 
 # Make a flist for VCS to use during simv compile.
 # Make the NTB vshell file to use during simv compile if ntb_lib.
 # NTB diag is handled later in ntb_diag:
 ifdef USE_NTB_LIB
 ntb_build: $(TESTING) makedir $(VERA_LIBDIR)/${SYS_NAME}_top_shell.v
 	@if (test -f  $(VERA_LIBDIR)/ntb_flist) then rm -f $(VERA_LIBDIR)/ntb_flist ; fi
 	@echo $(NTB_LIB_FLIST) > $(VERA_LIBDIR)/ntb_flist
 else
 # NTB/VCS all-in-one compile. Just make a flist for simv compile.
 # This method does NOT allow you to build in unique vera diags.
 ntb_build: $(TESTING) makedir
 	@if (test -f  $(VERA_LIBDIR)/ntb_flist) then rm -f $(VERA_LIBDIR)/ntb_flist ; fi
 	@echo $(NTB_ALL_FLIST) > $(VERA_LIBDIR)/ntb_flist
 endif
 
 clean:
 	rm -rf $(VERA_LIBDIR)/* ; rm -f $(VERA_LIBDIR)/../${SYS_NAME}_top_shell.v
 
 # Second pass of the NTB two pass libtb.so compile method.
 # This compiles libtb.so in a unique location using a unique (or default/dummy) vera diag.
 ntb_diag: $(TESTING) $(VERA_LIBDIR)/libtb.so
 
 makedir:
 	@if (test ! -d  $(VERA_LIBDIR)) then mkdir -p $(VERA_LIBDIR) ; fi
 
 test: 
 	@echo "<<Invoke Dir>>" ${PWD} "\n"
 	@echo "<<BENCH_DIR>>" $(BENCH_DIR) "\n"
 	@echo "<<DEPENDENCIES>>" $(DEPENDENCIES) "\n"
 	@echo "<<NTB_INCDIR>>" $(NTB_INCDIR) "\n"
 	@echo "<<VERA_INCDIR>>" $(VERA_INCDIR) "\n"
 	@echo "<<ORDERD_VRO>>" $(ORDERD_VRO) "\n"
	@echo "<<NTB_BUILD_ARGS>>" $(NTB_BUILD_ARGS) "\n"
	@echo "<<NTB_DIAG_ARGS>>" $(NTB_DIAG_ARGS) "\n"
 	@echo "<<VERA_VRO>>" $(VERA_VRO) "\n"
 	@echo "<<ORDERD_SRC_LIST>>" $(ORDERD_SRC_LIST) "\n"
 	@echo "<<NTB_ALL_FLIST>>" $(NTB_ALL_FLIST) "\n"
 	@echo "<<NTB_LIB_FLIST>>" $(NTB_LIB_FLIST) "\n"
 	@echo "<<NTB_LIB_COMPILE>>" $(NTB_LIB_COMPILE) "\n"
 	@echo "<<VERA_LIBDIR>>" $(VERA_LIBDIR) "\n"
 	@echo "<<NTB_DIAG>>" $(NTB_DIAG) "\n"
 
 
 #################################
 # Original Vera, not NTB, targets
 #################################
 
 vera: $(TESTING) makedir copy_vera_stuff copy_dep $(ORDERD_VRO)
 
 # When using vera diags, you must copy any include files/$(DEPENDENCIES)
 # that the diag needs into VERA_LIBDIR.
 # Be aware, you could possibly get name collisions in $(VERA_LIBDIR)
 # which could cause problems. See VPATH
 copy_dep:
 	@cp -fp $(DEPENDENCIES) $(VERA_LIBDIR)
 
 copy_vera_stuff:
 	@vera -V
 	@rm -f $(VERA_LIBDIR)/../$(SYS_NAME)_top_shell.v
 	@cp -fp include/*vcon* $(VERA_LIBDIR)
 
 vrh:
 	@echo "To make a vrh for your class do --> " $(VERA_VRH) "path_to_class"
 
 
 
 ################################################################################
 # lowest level rules
 ################################################################################
 
 # vera vr files:
 # About $(DEPENDENCIES)... This is a list of vrh/vri files that are in
 # the directories identified by the bench developer. Vera is given
 # this list in the form of include paths. Vera will compile with the
 # ORIGINAL vrh/vri file, not a copy. You -->MUST<-- use #include <file>
 # syntax, not #include "file", if you want Vera's -I to find the right
 # include file every time. See VPATH.
 # 
 # This dependency technique is not perfect (there are more explicit
 # ways) but what it WILL do is base a Vera compile on whether any Vera
 # include/dependency file has changed. If any $(DEPENDENCIES) file has
 # changed, a new .vro file will be made for every .vr file. If only a
 # single .vr file has changed, a new .vro is made only for that .vr
 # file.
 $(VERA_LIBDIR)/%.vro: %.vr $(DEPENDENCIES)
 	@$(ECHO) $(INDENT) ">>>> Vera: compiling $(notdir $<)"
 ifeq ($(TESTING), test)
 	@$(ECHO) $(VERA_VRO) $< $@
 endif
 	@$(VERA_VRO) $< $@
 
 # ntb w/ lib file use, shell file:
 # Will rebuild the shell if any DEPENDENCIES file or BENCH_TOP or Makefile has changed.
 $(VERA_LIBDIR)/${SYS_NAME}_top_shell.v: $(BENCH_DIR)/Makefile $(DEPENDENCIES) $(ORDERD_SRC_LIST)
 	@$(ECHO) $(INDENT) ">>>> Vera/NTB: compiling NTB testbench shell file (-ntb_shell_only) from ${PWD}: $(NTB_LIB)"
 ifeq ($(TESTING), test)
 	@$(ECHO) $(NTB_LIB_COMPILE) -ntb_shell_only
 endif
 	$(NTB_LIB_COMPILE) -ntb_shell_only
 
 # ntb w/ lib file use, libtb.so file:
 # Will rebuild if any DEPENDENCIES file or ORDERD_SRC_LIST or the Makefile file has changed.
 # add $(VERA_LIBDIR)/diagChanged to end of next line for sims 1.272
 $(VERA_LIBDIR)/libtb.so:  $(BENCH_DIR)/Makefile $(DEPENDENCIES) $(ORDERD_SRC_LIST)
 	@$(ECHO) $(INDENT) ">>>> Vera/NTB: compiling NTB testbench libtb.so file (-ntb_noshell) from ${PWD}: $(NTB_LIB)"
 ifeq ($(TESTING), test)
 	@$(ECHO) $(NTB_LIB_COMPILE) $(NTB_DIAG_ARGS) -ntb_noshell
 endif
 	$(NTB_LIB_COMPILE) $(NTB_DIAG_ARGS) -ntb_noshell
  
  
 ifndef DEBUG
 .SILENT:
 endif



=cut
#}}}
