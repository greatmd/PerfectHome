.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GDS2 3"
.TH GDS2 3 "2003-03-28" "perl v5.8.0" "User Contributed Perl Documentation"
\&\s-1GDS2\s0 \- \s-1GDS2\s0 stream module
.SH "Description"
.IX Header "Description"
This is \s-1GDS2\s0, a module for quickly creating programs to read and/or write \s-1GDS2\s0 files.
.PP
Send feedback/suggestions to
schumack@cpan.org
.SH "Create Method"
.IX Header "Create Method"
.Sh "new \- open gds2 file"
.IX Subsection "new - open gds2 file"
.Vb 3
\&  usage:
\&  my $gds2File  = new GDS2(-fileName => "filename.gds2"); ## to read 
\&  my $gds2File2 = new GDS2(-fileName => ">filename.gds2"); ## to write
.Ve
.Sh "close \- close gds2 file"
.IX Subsection "close - close gds2 file"
.Vb 7
\&  usage:
\&  $gds2File -> close;
\&   -or-
\&  $gds2File -> close(-markEnd=>1); ## experimental  -- some systems have trouble closing files
\&  $gds2File -> close(-pad=>2048);  ## experimental  -- pad end with \e0's till file size is a 
\&                                   ## multiple of number. Note: old reel to reel tapes on Calma
\&                                   ## systems used 2048 byte blocks
.Ve
.SH "High Level Write Methods"
.IX Header "High Level Write Methods"
.Sh "\fIprintInitLib()\fP \- Does all the things needed to start a library"
.IX Subsection "printInitLib() - Does all the things needed to start a library"
.Vb 5
\&   usage:
\&     $gds2File -> printInitLib(-name => "testlib",   ##writes HEADER,BGNLIB,LIBNAME,and UNITS records
\&                               -isoDate => 0|1       ## (optional) use ISO 4 digit date 2001 vs 101
\&                              );
\&     ## defaults to current date for library date and 1e-3 and 1e-9 for units
.Ve
.PP
.Vb 2
\&   note:
\&     remember to close library with printEndlib()
.Ve
.Sh "printBgnstr \- Does all the things needed to start a structure definition"
.IX Subsection "printBgnstr - Does all the things needed to start a structure definition"
.Vb 4
\&   usage:
\&    $gds2File -> printBgnstr(-name => "nand3" ## writes BGNSTR and STRNAME records
\&                             -isoDate => 1|0  ## (optional) use ISO 4 digit date 2001 vs 101
\&                             );
.Ve
.PP
.Vb 2
\&   note:
\&     remember to close with printEndstr()
.Ve
.Sh "printPath \- prints a gds2 path"
.IX Subsection "printPath - prints a gds2 path"
.Vb 10
\&  usage: 
\&    $gds2File -> printPath(
\&                    -layer=>#,
\&                    -dataType=>#, ##optional
\&                    -pathType=>#,
\&                    -width=>#.#,
\&                    -unitWidth=>#,    ## (optional) directly specify width in data base units (vs -width which is multipled by resolution)
\&                    -xy=>\e@array,     ## array of reals
\&                    -xyInt=>\e@array,  ## array of internal ints (optional -wks better if you are modifying an existing GDS2 file)
\&                  );
.Ve
.PP
.Vb 8
\&  note:
\&    layer defaults to 0 if -layer not used
\&    pathType defaults to 0 if -pathType not used
\&      pathType 0 = square end
\&               1 = round end
\&               2 = square - extended 1/2 width
\&               4 = custom plus variable path extension...
\&    width defaults to 0.0 if -width not used
.Ve
.Sh "printBoundary \- prints a gds2 boundary"
.IX Subsection "printBoundary - prints a gds2 boundary"
.Vb 7
\&  usage: 
\&    $gds2File -> printBoundary(
\&                    -layer=>#,
\&                    -dataType=>#,
\&                    -xy=>\e@array,     ## array of reals
\&                    -xyInt=>\e@array,  ## array of internal ints (optional -wks better if you are modifying an existing GDS2 file)
\&                 );
.Ve
.PP
.Vb 3
\&  note:
\&    layer defaults to 0 if -layer not used
\&    dataType defaults to 0 if -dataType not used
.Ve
.Sh "printSref \- prints a gds2 Structure REFerence"
.IX Subsection "printSref - prints a gds2 Structure REFerence"
.Vb 9
\&  usage: 
\&    $gds2File -> printSref(
\&                    -name=>string,   ## Name of structure
\&                    -xy=>\e@array,    ## array of reals
\&                    -xyInt=>\e@array, ## array of internal ints (optional -wks better than -xy if you are modifying an existing GDS2 file)
\&                    -angle=>#.#,     ## (optional) Default is 0.0
\&                    -mag=>#.#,       ## (optional) Default is 1.0
\&                    -reflect=>0|1    ## (optional)
\&                 );
.Ve
.PP
.Vb 2
\&  note:
\&    best not to specify angle or mag if not needed
.Ve
.Sh "printAref \- prints a gds2 Array REFerence"
.IX Subsection "printAref - prints a gds2 Array REFerence"
.Vb 11
\&  usage: 
\&    $gds2File -> printAref(
\&                    -name=>string,   ## Name of structure
\&                    -columns=>#,     ## Default is 1
\&                    -rows=>#,        ## Default is 1
\&                    -xy=>\e@array,    ## array of reals
\&                    -xyInt=>\e@array, ## array of internal ints (optional -wks better if you are modifying an existing GDS2 file)
\&                    -angle=>#.#,     ## (optional) Default is 0.0
\&                    -mag=>#.#,       ## (optional) Default is 1.0
\&                    -reflect=>0|1    ## (optional)
\&                 );
.Ve
.PP
.Vb 2
\&  note:
\&    best not to specify angle or mag if not needed
.Ve
.Sh "printText \- prints a gds2 Text"
.IX Subsection "printText - prints a gds2 Text"
.Vb 16
\&  usage: 
\&    $gds2File -> printText(
\&                    -string=>string,
\&                    -layer=>#,      ## Default is 0
\&                    -textType=>#,   ## Default is 0
\&                    -font=>#,       ## 0-3
\&                    -top, or -middle, -bottom,     ##optional vertical presentation
\&                    -left, or -center, or -right,  ##optional horizontal presentation
\&                    -xy=>\e@array,     ## array of reals
\&                    -xyInt=>\e@array,  ## array of internal ints (optional -wks better if you are modifying an existing GDS2 file)
\&                    -x=>#.#,        ## optional way of passing in x value
\&                    -y=>#.#,        ## optional way of passing in y value
\&                    -angle=>#.#,    ## (optional) Default is 0.0
\&                    -mag=>#.#,      ## (optional) Default is 1.0
\&                    -reflect=>#,    ## (optional) Default is 0
\&                 );
.Ve
.PP
.Vb 2
\&  note:
\&    best not to specify reflect, angle or mag if not needed
.Ve
.SH "Low Level Generic Write Methods"
.IX Header "Low Level Generic Write Methods"
.Sh "\fIsaveGds2Record()\fP \- low level method to create a gds2 record given record type and data (if required). Data of more than one item should be given as a list."
.IX Subsection "saveGds2Record() - low level method to create a gds2 record given record type and data (if required). Data of more than one item should be given as a list."
.Vb 1
\&  NOTE: THIS ONLY USES GDS2 OBJECT TO GET RESOLUTION
.Ve
.PP
.Vb 7
\&  usage:
\&    saveGds2Record(
\&            -type=>string,
\&            -data=>data_If_Needed, ##optional for some types
\&            -scale=>#.#,           ##optional number to scale data to. I.E -scale=>0.5 #default is NOT to scale
\&            -snap=>#.#,            ##optional number to snap data to I.E. -snap=>0.005 #default is 1 resolution unit, typically 0.001
\&    );
.Ve
.PP
.Vb 4
\&  examples:
\&    my $gds2File = new GDS2(-fileName => ">$fileName");
\&    my $record = $gds2File -> saveGds2Record(-type=>'header',-data=>3);
\&    $gds2FileOut -> printGds2Record(-type=>'record',-data=>$record);
.Ve
.Sh "\fIprintGds2Record()\fP \- low level method to print a gds2 record given record type and data (if required). Data of more than one item should be given as a list."
.IX Subsection "printGds2Record() - low level method to print a gds2 record given record type and data (if required). Data of more than one item should be given as a list."
.Vb 7
\&  usage:
\&    printGds2Record(
\&            -type=>string,
\&            -data=>data_If_Needed, ##optional for some types
\&            -scale=>#.#,           ##optional number to scale data to. I.E -scale=>0.5 #default is NOT to scale
\&            -snap=>#.#,            ##optional number to snap data to I.E. -snap=>0.005 #default is 1 resolution unit, typically 0.001
\&    );
.Ve
.PP
.Vb 2
\&  examples:
\&    my $gds2File = new GDS2(-fileName => ">$fileName");
.Ve
.PP
.Vb 8
\&    $gds2File -> printGds2Record(-type=>'header',-data=>3);
\&    $gds2File -> printGds2Record(-type=>'bgnlib',-data=>[99,12,1,22,33,0,99,12,1,22,33,9]);
\&    $gds2File -> printGds2Record(-type=>'libname',-data=>"testlib");
\&    $gds2File -> printGds2Record(-type=>'units',-data=>[0.001, 1e-9]);
\&    $gds2File -> printGds2Record(-type=>'bgnstr',-data=>[99,12,1,22,33,0,99,12,1,22,33,9]);
\&    ...
\&    $gds2File -> printGds2Record(-type=>'endstr');
\&    $gds2File -> printGds2Record(-type=>'endlib');
.Ve
.PP
.Vb 6
\&  Note: the special record type of 'record' can be used to copy a complete record
\&  just read in:
\&    while (my $record = $gds2FileIn -> readGds2Record()) 
\&    {
\&        $gds2FileOut -> printGds2Record(-type=>'record',-data=>$record);
\&    }
.Ve
.Sh "printRecord \- prints a record just read"
.IX Subsection "printRecord - prints a record just read"
.Vb 4
\&  usage:
\&    $gds2File -> printRecord(
\&                  -data => $record 
\&                );
.Ve
.SH "Low Level Generic Read Methods"
.IX Header "Low Level Generic Read Methods"
.Sh "readGds2Record \- reads record header and data section"
.IX Subsection "readGds2Record - reads record header and data section"
.Vb 8
\&  usage:
\&  while ($gds2File -> readGds2Record)
\&  {
\&      if ($gds2File -> returnRecordTypeString eq 'LAYER')
\&      {
\&          $layersFound[$gds2File -> layer] = 1;
\&      }
\&  }
.Ve
.Sh "readGds2RecordHeader \- only reads gds2 record header section (2 bytes)"
.IX Subsection "readGds2RecordHeader - only reads gds2 record header section (2 bytes)"
.Sh "readGds2RecordData \- only reads record data section"
.IX Subsection "readGds2RecordData - only reads record data section"
.Vb 10
\&  slightly faster if you just want a certain thing...
\&  usage:
\&  while ($gds2File -> readGds2RecordHeader) 
\&  {
\&      if ($gds2File -> returnRecordTypeString eq 'LAYER')
\&      {
\&          $gds2File -> readGds2RecordData;
\&          $layersFound[$gds2File -> returnLayer] = 1;
\&      }
\&  }
.Ve
.SH "Low Level Generic Evaluation Methods"
.IX Header "Low Level Generic Evaluation Methods"
.Sh "returnRecordType \- returns current (read) record type as integer"
.IX Subsection "returnRecordType - returns current (read) record type as integer"
.Vb 5
\&  usage:
\&  if ($gds2File -> returnRecordType == 6)
\&  {
\&      print "found STRNAME";
\&  }
.Ve
.Sh "returnRecordTypeString \- returns current (read) record type as string"
.IX Subsection "returnRecordTypeString - returns current (read) record type as string"
.Vb 5
\&  usage:
\&  if ($gds2File -> returnRecordTypeString eq 'LAYER')
\&  {
\&      code goes here...
\&  }
.Ve
.Sh "returnRecordAsString \- returns current (read) record as a string"
.IX Subsection "returnRecordAsString - returns current (read) record as a string"
.Vb 5
\&  usage:
\&  while ($gds2File -> readGds2Record) 
\&  {
\&      print $gds2File -> returnRecordAsString;
\&  }
.Ve
.Sh "returnXyAsArray \- returns current (read) \s-1XY\s0 record as an array"
.IX Subsection "returnXyAsArray - returns current (read) XY record as an array"
.Vb 7
\&  usage:
\&    $gds2File -> returnXyAsArray(
\&                    -asInteger => 0|1  ## (optional) default is true. Return integer 
\&                                       ## array or if false return array of reals.
\&                    -withClosure => 0|1  ## (optional) default is true. Whether to 
\&                                         ##return a rectangle with 5 or 4 points.
\&               );
.Ve
.PP
.Vb 5
\&  example:
\&  while ($gds2File -> readGds2Record) 
\&  {
\&      my @xy = $gds2File -> returnXyAsArray if ($gds2File -> isXy);
\&  }
.Ve
.Sh "returnRecordAsPerl \- returns current (read) record as a perl command to facilitate the creation of parameterized gds2 data with perl."
.IX Subsection "returnRecordAsPerl - returns current (read) record as a perl command to facilitate the creation of parameterized gds2 data with perl."
.Vb 8
\&  usage:
\&  #!/usr/local/bin/perl
\&  use GDS2;
\&  my $gds2File = new GDS2(-fileName=>"test.gds");
\&  while ($gds2File -> readGds2Record) 
\&  {
\&      print $gds2File -> returnRecordAsPerl;
\&  }
.Ve
.SH "Low Level Specific Write Methods"
.IX Header "Low Level Specific Write Methods"
.Sh "printAngle \- prints \s-1ANGLE\s0 record"
.IX Subsection "printAngle - prints ANGLE record"
.Vb 2
\&  usage:
\&    $gds2File -> printAngle(-num=>#.#);
.Ve
.Sh "printAttrtable \- prints \s-1ATTRTABLE\s0 record"
.IX Subsection "printAttrtable - prints ATTRTABLE record"
.Vb 2
\&  usage:
\&    $gds2File -> printAttrtable(-string=>$string);
.Ve
.Sh "printBgnextn \- prints \s-1BGNEXTN\s0 record"
.IX Subsection "printBgnextn - prints BGNEXTN record"
.Vb 2
\&  usage:
\&    $gds2File -> printBgnextn(-num=>#.#);
.Ve
.Sh "printBgnlib \- prints \s-1BGNLIB\s0 record"
.IX Subsection "printBgnlib - prints BGNLIB record"
.Vb 4
\&  usage:
\&    $gds2File -> printBgnlib(
\&                            -isoDate => 0|1 ## (optional) use ISO 4 digit date 2001 vs 101
\&                           );
.Ve
.Sh "printBox \- prints \s-1BOX\s0 record"
.IX Subsection "printBox - prints BOX record"
.Vb 2
\&  usage:
\&    $gds2File -> printBox;
.Ve
.Sh "printBoxtype \- prints \s-1BOXTYPE\s0 record"
.IX Subsection "printBoxtype - prints BOXTYPE record"
.Vb 2
\&  usage:
\&    $gds2File -> printBoxtype(-num=>#);
.Ve
.Sh "printColrow \- prints \s-1COLROW\s0 record"
.IX Subsection "printColrow - prints COLROW record"
.Vb 2
\&  usage:
\&    $gds2File -> printBoxtype(-columns=>#, -rows=>#);
.Ve
.Sh "printDatatype \- prints \s-1DATATYPE\s0 record"
.IX Subsection "printDatatype - prints DATATYPE record"
.Vb 2
\&  usage:
\&    $gds2File -> printDatatype(-num=>#);
.Ve
.Sh "printElkey \- prints \s-1ELKEY\s0 record"
.IX Subsection "printElkey - prints ELKEY record"
.Vb 2
\&  usage:
\&    $gds2File -> printElkey(-num=>#);
.Ve
.Sh "printEndel \- closes an element definition"
.IX Subsection "printEndel - closes an element definition"
.Sh "printEndextn \- prints path end extension record"
.IX Subsection "printEndextn - prints path end extension record"
.Vb 2
\&  usage:
\&    $gds2File printEndextn -> (-num=>#.#);
.Ve
.Sh "printEndlib \- closes a library definition"
.IX Subsection "printEndlib - closes a library definition"
.Sh "printEndstr \- closes a structure definition"
.IX Subsection "printEndstr - closes a structure definition"
.Sh "printEndmasks \- prints a \s-1ENDMASKS\s0"
.IX Subsection "printEndmasks - prints a ENDMASKS"
.Sh "printFonts \- prints a \s-1FONTS\s0 record"
.IX Subsection "printFonts - prints a FONTS record"
.Vb 2
\&  usage:
\&    $gds2File -> printFonts(-string=>'names_of_font_files');
.Ve
.Sh "printHeader \- Prints a rev 3 header"
.IX Subsection "printHeader - Prints a rev 3 header"
.Vb 4
\&  usage:
\&    $gds2File -> printHeader(
\&                  -num => #  ## optional, defaults to 3. valid revs are 0,3,4,5,and 600
\&                );
.Ve
.Sh "printLayer \- prints a \s-1LAYER\s0 number"
.IX Subsection "printLayer - prints a LAYER number"
.Vb 4
\&  usage:
\&    $gds2File -> printLayer(
\&                  -num => #  ## optional, defaults to 0. 
\&                );
.Ve
.Sh "printLibname \- Prints library name"
.IX Subsection "printLibname - Prints library name"
.Vb 2
\&  usage:
\&    printLibname(-name=>$name);
.Ve
.Sh "printPathtype \- prints a \s-1PATHTYPE\s0 number"
.IX Subsection "printPathtype - prints a PATHTYPE number"
.Vb 4
\&  usage:
\&    $gds2File -> printPathtype(
\&                  -num => #  ## optional, defaults to 0. 
\&                );
.Ve
.Sh "printMag \- prints a \s-1MAG\s0 number"
.IX Subsection "printMag - prints a MAG number"
.Vb 4
\&  usage:
\&    $gds2File -> printMag(
\&                  -num => #.#  ## optional, defaults to 0.0 
\&                );
.Ve
.Sh "printNodetype \- prints a \s-1NODETYPE\s0 number"
.IX Subsection "printNodetype - prints a NODETYPE number"
.Vb 4
\&  usage:
\&    $gds2File -> printNodetype(
\&                  -num => #  
\&                );
.Ve
.Sh "printPresentation \- prints a text presentation record"
.IX Subsection "printPresentation - prints a text presentation record"
.Vb 6
\&  usage:
\&    $gds2File -> printPresentation(
\&                  -font => #,  ##optional, defaults to 0, valid numbers are 0-3
\&                  -top, ||-middle, || -bottom, ## vertical justification
\&                  -left, ||-center, || -right, ## horizontal justification
\&                );
.Ve
.PP
.Vb 2
\&  example:
\&    gds2File -> printPresentation(-font=>0,-top,-left);
.Ve
.Sh "printPropattr \- prints a property id number"
.IX Subsection "printPropattr - prints a property id number"
.Vb 2
\&  usage:
\&    $gds2File -> printPropattr( -num => # );
.Ve
.Sh "printPropvalue \- prints a property value string"
.IX Subsection "printPropvalue - prints a property value string"
.Vb 2
\&  usage:
\&    $gds2File -> printPropvalue( -string => $string );
.Ve
.Sh "printSname \- prints a \s-1SNAME\s0 string"
.IX Subsection "printSname - prints a SNAME string"
.Vb 2
\&  usage:
\&    $gds2File -> printSname( -name => $cellName );
.Ve
.Sh "printStrans \- prints a \s-1STRANS\s0 record"
.IX Subsection "printStrans - prints a STRANS record"
.Vb 2
\&  usage:
\&    $gds2File -> printStrans( -reflect );
.Ve
.Sh "printString \- prints a \s-1STRING\s0 record"
.IX Subsection "printString - prints a STRING record"
.Vb 2
\&  usage:
\&    $gds2File -> printSname( -string => $text );
.Ve
.Sh "printStrname \- prints a structure name string"
.IX Subsection "printStrname - prints a structure name string"
.Vb 2
\&  usage:
\&    $gds2File -> printStrname( -name => $cellName );
.Ve
.Sh "printTexttype \- prints a text type number"
.IX Subsection "printTexttype - prints a text type number"
.Vb 2
\&  usage:
\&    $gds2File -> printTexttype( -num => # );
.Ve
.Sh "printUnits \- Prints units record."
.IX Subsection "printUnits - Prints units record."
.Vb 1
\&  Defaults to 1e-3 and 1e-9
.Ve
.Sh "printPropattr \- prints a width number"
.IX Subsection "printPropattr - prints a width number"
.Vb 2
\&  usage:
\&    $gds2File -> printWidth( -num => # );
.Ve
.Sh "printXy \- prints an \s-1XY\s0 array"
.IX Subsection "printXy - prints an XY array"
.Vb 2
\&  usage:
\&    $gds2File -> printXy( -xy => \e@array );
.Ve
.SH "Low Level Specific Evaluation Methods"
.IX Header "Low Level Specific Evaluation Methods"
.Sh "returnDatatype \- returns datatype # if record is \s-1DATATYPE\s0 else returns \-1"
.IX Subsection "returnDatatype - returns datatype # if record is DATATYPE else returns -1"
.Vb 2
\&  usage:
\&    $dataTypesFound[$gds2File -> returnDatatype] = 1;
.Ve
.Sh "returnPathtype \- returns pathtype # if record is \s-1PATHTYPE\s0 else returns \-1"
.IX Subsection "returnPathtype - returns pathtype # if record is PATHTYPE else returns -1"
.Vb 1
\&  usage:
.Ve
.Sh "returnTexttype \- returns texttype # if record is \s-1TEXTTYPE\s0 else returns \-1"
.IX Subsection "returnTexttype - returns texttype # if record is TEXTTYPE else returns -1"
.Vb 2
\&  usage:
\&    $TextTypesFound[$gds2File -> returnTexttype] = 1;
.Ve
.Sh "returnWidth \- returns width # if record is \s-1WIDTH\s0 else returns \-1"
.IX Subsection "returnWidth - returns width # if record is WIDTH else returns -1"
.Vb 1
\&  usage:
.Ve
.Sh "returnLayer \- returns layer # if record is \s-1LAYER\s0 else returns \-1"
.IX Subsection "returnLayer - returns layer # if record is LAYER else returns -1"
.Vb 2
\&  usage:
\&    $layersFound[$gds2File -> returnLayer] = 1;
.Ve
.Sh "returnBgnextn \- returns bgnextn if record is \s-1BGNEXTN\s0 else returns 0"
.IX Subsection "returnBgnextn - returns bgnextn if record is BGNEXTN else returns 0"
.Vb 1
\&  usage:
.Ve
.Sh "returnEndextn\- returns endextn if record is \s-1ENDEXTN\s0 else returns 0"
.IX Subsection "returnEndextn- returns endextn if record is ENDEXTN else returns 0"
.Vb 1
\&  usage:
.Ve
.Sh "returnString \- return string if record type is \s-1STRING\s0 else ''"
.IX Subsection "returnString - return string if record type is STRING else ''"
.Sh "returnSname \- return string if record type is \s-1SNAME\s0 else ''"
.IX Subsection "returnSname - return string if record type is SNAME else ''"
.Sh "returnStrname \- return string if record type is \s-1STRNAME\s0 else ''"
.IX Subsection "returnStrname - return string if record type is STRNAME else ''"
.SH "Low Level Specific Boolean Methods"
.IX Header "Low Level Specific Boolean Methods"
.Sh "isAref \- return 0 or 1 depending on whether current record is an aref"
.IX Subsection "isAref - return 0 or 1 depending on whether current record is an aref"
.Sh "isBgnlib \- return 0 or 1 depending on whether current record is a bgnlib"
.IX Subsection "isBgnlib - return 0 or 1 depending on whether current record is a bgnlib"
.Sh "isBgnstr \- return 0 or 1 depending on whether current record is a bgnstr"
.IX Subsection "isBgnstr - return 0 or 1 depending on whether current record is a bgnstr"
.Sh "isBoundary \- return 0 or 1 depending on whether current record is a boundary"
.IX Subsection "isBoundary - return 0 or 1 depending on whether current record is a boundary"
.Sh "isDatatype \- return 0 or 1 depending on whether current record is datatype"
.IX Subsection "isDatatype - return 0 or 1 depending on whether current record is datatype"
.Sh "isEndlib \- return 0 or 1 depending on whether current record is endlib"
.IX Subsection "isEndlib - return 0 or 1 depending on whether current record is endlib"
.Sh "isEndel \- return 0 or 1 depending on whether current record is endel"
.IX Subsection "isEndel - return 0 or 1 depending on whether current record is endel"
.Sh "isEndstr \- return 0 or 1 depending on whether current record is endstr"
.IX Subsection "isEndstr - return 0 or 1 depending on whether current record is endstr"
.Sh "isHeader \- return 0 or 1 depending on whether current record is a header"
.IX Subsection "isHeader - return 0 or 1 depending on whether current record is a header"
.Sh "isLibname \- return 0 or 1 depending on whether current record is a libname"
.IX Subsection "isLibname - return 0 or 1 depending on whether current record is a libname"
.Sh "isPath \- return 0 or 1 depending on whether current record is a path"
.IX Subsection "isPath - return 0 or 1 depending on whether current record is a path"
.Sh "isSref \- return 0 or 1 depending on whether current record is an sref"
.IX Subsection "isSref - return 0 or 1 depending on whether current record is an sref"
.Sh "isSrfname \- return 0 or 1 depending on whether current record is an srfname"
.IX Subsection "isSrfname - return 0 or 1 depending on whether current record is an srfname"
.Sh "isText \- return 0 or 1 depending on whether current record is a text"
.IX Subsection "isText - return 0 or 1 depending on whether current record is a text"
.Sh "isUnits \- return 0 or 1 depending on whether current record is units"
.IX Subsection "isUnits - return 0 or 1 depending on whether current record is units"
.Sh "isLayer \- return 0 or 1 depending on whether current record is layer"
.IX Subsection "isLayer - return 0 or 1 depending on whether current record is layer"
.Sh "isStrname \- return 0 or 1 depending on whether current record is strname"
.IX Subsection "isStrname - return 0 or 1 depending on whether current record is strname"
.Sh "isWidth \- return 0 or 1 depending on whether current record is width"
.IX Subsection "isWidth - return 0 or 1 depending on whether current record is width"
.Sh "isXy \- return 0 or 1 depending on whether current record is xy"
.IX Subsection "isXy - return 0 or 1 depending on whether current record is xy"
.Sh "isSname \- return 0 or 1 depending on whether current record is sname"
.IX Subsection "isSname - return 0 or 1 depending on whether current record is sname"
.Sh "isColrow \- return 0 or 1 depending on whether current record is colrow"
.IX Subsection "isColrow - return 0 or 1 depending on whether current record is colrow"
.Sh "isTextnode \- return 0 or 1 depending on whether current record is a textnode"
.IX Subsection "isTextnode - return 0 or 1 depending on whether current record is a textnode"
.Sh "isNode \- return 0 or 1 depending on whether current record is a node"
.IX Subsection "isNode - return 0 or 1 depending on whether current record is a node"
.Sh "isTexttype \- return 0 or 1 depending on whether current record is a texttype"
.IX Subsection "isTexttype - return 0 or 1 depending on whether current record is a texttype"
.Sh "isPresentation \- return 0 or 1 depending on whether current record is a presentation"
.IX Subsection "isPresentation - return 0 or 1 depending on whether current record is a presentation"
.Sh "isSpacing \- return 0 or 1 depending on whether current record is a spacing"
.IX Subsection "isSpacing - return 0 or 1 depending on whether current record is a spacing"
.Sh "isString \- return 0 or 1 depending on whether current record is a string"
.IX Subsection "isString - return 0 or 1 depending on whether current record is a string"
.Sh "isStrans \- return 0 or 1 depending on whether current record is a strans"
.IX Subsection "isStrans - return 0 or 1 depending on whether current record is a strans"
.Sh "isMag \- return 0 or 1 depending on whether current record is a mag"
.IX Subsection "isMag - return 0 or 1 depending on whether current record is a mag"
.Sh "isAngle \- return 0 or 1 depending on whether current record is a angle"
.IX Subsection "isAngle - return 0 or 1 depending on whether current record is a angle"
.Sh "isUinteger \- return 0 or 1 depending on whether current record is a uinteger"
.IX Subsection "isUinteger - return 0 or 1 depending on whether current record is a uinteger"
.Sh "isUstring \- return 0 or 1 depending on whether current record is a ustring"
.IX Subsection "isUstring - return 0 or 1 depending on whether current record is a ustring"
.Sh "isReflibs \- return 0 or 1 depending on whether current record is a reflibs"
.IX Subsection "isReflibs - return 0 or 1 depending on whether current record is a reflibs"
.Sh "isFonts \- return 0 or 1 depending on whether current record is a fonts"
.IX Subsection "isFonts - return 0 or 1 depending on whether current record is a fonts"
.Sh "isPathtype \- return 0 or 1 depending on whether current record is a pathtype"
.IX Subsection "isPathtype - return 0 or 1 depending on whether current record is a pathtype"
.Sh "isGenerations \- return 0 or 1 depending on whether current record is a generations"
.IX Subsection "isGenerations - return 0 or 1 depending on whether current record is a generations"
.Sh "isAttrtable \- return 0 or 1 depending on whether current record is a attrtable"
.IX Subsection "isAttrtable - return 0 or 1 depending on whether current record is a attrtable"
.Sh "isStyptable \- return 0 or 1 depending on whether current record is a styptable"
.IX Subsection "isStyptable - return 0 or 1 depending on whether current record is a styptable"
.Sh "isStrtype \- return 0 or 1 depending on whether current record is a strtype"
.IX Subsection "isStrtype - return 0 or 1 depending on whether current record is a strtype"
.Sh "isEflags \- return 0 or 1 depending on whether current record is a eflags"
.IX Subsection "isEflags - return 0 or 1 depending on whether current record is a eflags"
.Sh "isElkey \- return 0 or 1 depending on whether current record is a elkey"
.IX Subsection "isElkey - return 0 or 1 depending on whether current record is a elkey"
.Sh "isLinktype \- return 0 or 1 depending on whether current record is a linktype"
.IX Subsection "isLinktype - return 0 or 1 depending on whether current record is a linktype"
.Sh "isLinkkeys \- return 0 or 1 depending on whether current record is a linkkeys"
.IX Subsection "isLinkkeys - return 0 or 1 depending on whether current record is a linkkeys"
.Sh "isNodetype \- return 0 or 1 depending on whether current record is a nodetype"
.IX Subsection "isNodetype - return 0 or 1 depending on whether current record is a nodetype"
.Sh "isPropattr \- return 0 or 1 depending on whether current record is a propattr"
.IX Subsection "isPropattr - return 0 or 1 depending on whether current record is a propattr"
.Sh "isPropvalue \- return 0 or 1 depending on whether current record is a propvalue"
.IX Subsection "isPropvalue - return 0 or 1 depending on whether current record is a propvalue"
.Sh "isBox \- return 0 or 1 depending on whether current record is a box"
.IX Subsection "isBox - return 0 or 1 depending on whether current record is a box"
.Sh "isBoxtype \- return 0 or 1 depending on whether current record is a boxtype"
.IX Subsection "isBoxtype - return 0 or 1 depending on whether current record is a boxtype"
.Sh "isPlex \- return 0 or 1 depending on whether current record is a plex"
.IX Subsection "isPlex - return 0 or 1 depending on whether current record is a plex"
.Sh "isBgnextn \- return 0 or 1 depending on whether current record is a bgnextn"
.IX Subsection "isBgnextn - return 0 or 1 depending on whether current record is a bgnextn"
.Sh "isEndextn \- return 0 or 1 depending on whether current record is a endextn"
.IX Subsection "isEndextn - return 0 or 1 depending on whether current record is a endextn"
.Sh "isTapenum \- return 0 or 1 depending on whether current record is a tapenum"
.IX Subsection "isTapenum - return 0 or 1 depending on whether current record is a tapenum"
.Sh "isTapecode \- return 0 or 1 depending on whether current record is a tapecode"
.IX Subsection "isTapecode - return 0 or 1 depending on whether current record is a tapecode"
.Sh "isStrclass \- return 0 or 1 depending on whether current record is a strclass"
.IX Subsection "isStrclass - return 0 or 1 depending on whether current record is a strclass"
.Sh "isReserved \- return 0 or 1 depending on whether current record is a reserved"
.IX Subsection "isReserved - return 0 or 1 depending on whether current record is a reserved"
.Sh "isFormat \- return 0 or 1 depending on whether current record is a format"
.IX Subsection "isFormat - return 0 or 1 depending on whether current record is a format"
.Sh "isMask \- return 0 or 1 depending on whether current record is a mask"
.IX Subsection "isMask - return 0 or 1 depending on whether current record is a mask"
.Sh "isEndmasks \- return 0 or 1 depending on whether current record is a endmasks"
.IX Subsection "isEndmasks - return 0 or 1 depending on whether current record is a endmasks"
.Sh "isLibdirsize \- return 0 or 1 depending on whether current record is a libdirsize"
.IX Subsection "isLibdirsize - return 0 or 1 depending on whether current record is a libdirsize"
.Sh "isLibsecur \- return 0 or 1 depending on whether current record is a libsecur"
.IX Subsection "isLibsecur - return 0 or 1 depending on whether current record is a libsecur"
.Sh "tellSize \- return current byte position (\s-1NOT\s0 zero based)"
.IX Subsection "tellSize - return current byte position (NOT zero based)"
.Vb 2
\&  usage:
\&    my $position = $gds2File -> tellSize;
.Ve
.SH "Examples"
.IX Header "Examples"
.Vb 8
\&  Layer change:
\&    here's a bare bones script to change all layer 59 to 66 given a file to
\&    read and a new file to create.
\&    #!/usr/local/bin/perl -w
\&    use strict;
\&    use GDS2;
\&    my $fileName1 = $ARGV[0];
\&    my $fileName2 = $ARGV[1];
.Ve
.PP
.Vb 2
\&    my $gds2File1 = new GDS2(-fileName => $fileName1);
\&    my $gds2File2 = new GDS2(-fileName => ">$fileName2");
.Ve
.PP
.Vb 11
\&    while (my $record = $gds2File1 -> readGds2Record) 
\&    {
\&        if ($gds2File1 -> returnLayer == 59)
\&        {
\&            $gds2File2 -> printLayer(-num=>66);
\&        }
\&        else
\&        {
\&            $gds2File2 -> printRecord(-data=>$record);
\&        }
\&    }
.Ve
.PP
.Vb 5
\&  Gds2 dump:
\&    here's a program to dump the contents of a stream file.
\&    #!/usr/local/bin/perl -w
\&    use GDS2;
\&    $\e="\en";
.Ve
.PP
.Vb 5
\&    my $gds2File = new GDS2(-fileName=>$ARGV[0]);
\&    while ($gds2File -> readGds2Record) 
\&    {
\&        print $gds2File -> returnRecordAsString;
\&    }
.Ve
.PP
.Vb 30
\&  Create a complete GDS2 stream file from scratch:
\&    #!/usr/local/bin/perl -w
\&    use GDS2;
\&    my $gds2File = new GDS2(-fileName=>'>test.gds');
\&    $gds2File -> printInitLib(-name=>'testlib'); 
\&    $gds2File -> printBgnstr(-name=>'test');
\&    $gds2File -> printPath(
\&                    -layer=>6,
\&                    -pathType=>0,
\&                    -width=>2.4,
\&                    -xy=>[0,0, 10.5,0, 10.5,3.3],
\&                 );
\&    $gds2File -> printSref(
\&                    -name=>'contact',
\&                    -xy=>[4,5.5],
\&                 );
\&    $gds2File -> printAref(
\&                    -name=>'contact',
\&                    -columns=>2,
\&                    -rows=>3,
\&                    -xy=>[0,0],
\&                 );
\&    $gds2File -> printEndstr;
\&    $gds2File -> printBgnstr(-name => 'contact'); 
\&    $gds2File -> printBoundary(
\&                    -layer=>10,
\&                    -xy=>[0,0, 1,0, 1,1, 0,1],
\&                 );
\&    $gds2File -> printEndstr;
\&    $gds2File -> printEndlib();
.Ve
.SH "GDS2 Stream Format"
.IX Header "GDS2 Stream Format"
.Vb 50
\& #########################################################################################
\& # 
\& # Gds2 stream format is composed of variable length records. The mininum
\& # length record is 4 bytes. The 1st 2 bytes of a record contain a count (in 8 bit
\& # bytes) of the total record length.  The 3rd byte of the header is the record
\& # type. The 4th byte describes the type of data contained w/in the record. The
\& # 5th through last bytes are data.
\& # 
\& # If the output file is a mag tape, then the records of the library are written
\& # out in 2048-byte physical blocks. Records may overlap block boundaries.
\& # For this reason I think gds2 is often padded with null bytes so that the 
\& # file size ends up being a multiple of 2048.
\& # 
\& # A null word consists of 2 consecutive zero bytes. Use null words to fill the
\& # space between:
\& #     o the last record of a library and the end of its block
\& #     o the last record of a tape in a mult-reel stream file.
\& # 
\& # DATA TYPE        VALUE  RECORD
\& # ---------        -----  -----------------------
\& # no data present     0   4 byte header + 0
\& #
\& # Bit Array           1   4 byte header + 2 bytes data
\& #
\& # 2byte Signed Int    2  SMMMMMMM MMMMMMMM  -> S - sign ;  M - magnitude. 
\& #                        Twos complement format, with the most significant byte first.
\& #                        I.E.
\& #                        0x0001 = 1
\& #                        0x0002 = 2
\& #                        0x0089 = 137
\& #                        0xffff = -1
\& #                        0xfffe = -2
\& #                        0xff77 = -137
\& # 
\& # 4byte Signed Int    3  SMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM 
\& #
\& # 8byte Real          5  SEEEEEEE MMMMMMMM MMMMMMMM MMMMMMMM E-expon in excess-64 
\& #                        MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM representation 
\& #
\& #                        Mantissa == pos fraction >=1/16 && <1 bit 8==1/2, 9==1/4 etc...
\& #                        The first bit is the sign (1 = negative), the next 7 bits
\& #                        are the exponent, you have to subtract 64 from this number to
\& #                        get the real value. The next seven bytes are the mantissa in 
\& #                        4 word floating point representation.
\& #                
\& #
\& # string              6  odd length strings must be padded w/ null character and 
\& #                        byte count++
\& # 
\& #########################################################################################
.Ve
.SH "Backus-naur representation of GDS2 Stream Syntax"
.IX Header "Backus-naur representation of GDS2 Stream Syntax"
.Vb 34
\& ################################################################################
\& #  <STREAM FORMAT>::= HEADER BGNLIB [LIBDIRSIZE] [SRFNAME] [LIBSECR]           #
\& #                     LIBNAME [REFLIBS] [FONTS] [ATTRTABLE] [GENERATIONS]      #
\& #                     [<FormatType>] UNITS {<structure>}* ENDLIB               #
\& #                                                                              #
\& #  <FormatType>::=    FORMAT | FORMAT {MASK}+ ENDMASKS                         #
\& #                                                                              #
\& #  <structure>::=     BGNSTR STRNAME [STRCLASS] {<element>}* ENDSTR            #
\& #                                                                              #
\& #  <element>::=       {<boundary> | <path> | <SREF> | <AREF> | <text> |        #
\& #                      <node> | <box} {<property>}* ENDEL                      #
\& #                                                                              #
\& #  <boundary>::=      BOUNDARY [ELFLAGS] [PLEX] LAYER DATATYPE XY              #
\& #                                                                              #
\& #  <path>::=          PATH [ELFLAGS] [PLEX] LAYER DATATYPE [PATHTYPE]          #
\& #                     [WIDTH] [BGNEXTN] [ENDEXTN] [XY]                         #
\& #                                                                              #
\& #  <SREF>::=          SREF [ELFLAGS] [PLEX] SNAME [<strans>] XY                #
\& #                                                                              #
\& #  <AREF>::=          AREF [ELFLAGS] [PLEX] SNAME [<strans>] COLROW XY         #
\& #                                                                              #
\& #  <text>::=          TEXT [ELFLAGS] [PLEX] LAYER <textbody>                   #
\& #                                                                              #
\& #  <textbody>::=      TEXTTYPE [PRESENTATION] [PATHTYPE] [WIDTH] [<strans>] XY #
\& #                     STRING                                                   #
\& #                                                                              #
\& #  <strans>::=        STRANS [MAG] [ANGLE]                                     #
\& #                                                                              #
\& #  <node>::=          NODE [ELFLAGS] [PLEX] LAYER NODETYPE XY                  #
\& #                                                                              #
\& #  <box>::=           BOX [ELFLAGS] [PLEX] LAYER BOXTYPE XY                    #
\& #                                                                              #
\& #  <property>::=      PROPATTR PROPVALUE                                       #
\& ################################################################################
.Ve
.SH "GDS2 Stream Record Datatypes"
.IX Header "GDS2 Stream Record Datatypes"
.Vb 9
\& ################################################################################
\& NO_DATA       =  0;
\& BIT_ARRAY     =  1;
\& INTEGER_2     =  2;
\& INTEGER_4     =  3;
\& REAL_4        =  4; ## NOT supported, never really used
\& REAL_8        =  5;
\& ACSII_STRING  =  6;
\& ################################################################################
.Ve
.SH "GDS2 Stream Record Types"
.IX Header "GDS2 Stream Record Types"
.Vb 83
\& ################################################################################
\& HEADER        =  0;   ## 2-byte Signed Integer
\& BGNLIB        =  1;   ## 2-byte Signed Integer
\& LIBNAME       =  2;   ## ASCII String
\& UNITS         =  3;   ## 8-byte Real
\& ENDLIB        =  4;   ## no data present
\& BGNSTR        =  5;   ## 2-byte Signed Integer
\& STRNAME       =  6;   ## ASCII String
\& ENDSTR        =  7;   ## no data present
\& BOUNDARY      =  8;   ## no data present
\& PATH          =  9;   ## no data present
\& SREF          = 10;   ## no data present
\& AREF          = 11;   ## no data present
\& TEXT          = 12;   ## no data present
\& LAYER         = 13;   ## 2-byte Signed Integer
\& DATATYPE      = 14;   ## 2-byte Signed Integer
\& WIDTH         = 15;   ## 4-byte Signed Integer
\& XY            = 16;   ## 4-byte Signed Integer
\& ENDEL         = 17;   ## no data present
\& SNAME         = 18;   ## ASCII String
\& COLROW        = 19;   ## 2 2-byte Signed Integer <= 32767
\& TEXTNODE      = 20;   ## no data present
\& NODE          = 21;   ## no data present
\& TEXTTYPE      = 22;   ## 2-byte Signed Integer
\& PRESENTATION  = 23;   ## Bit Array. One word (2 bytes) of bit flags. Bits 11 and 
\&                       ##   12 together specify the font 00->font 0 11->font 3.
\&                       ##   Bits 13 and 14 specify the vertical presentation, 15
\&                       ##   and 16 the horizontal presentation. 00->'top/left' 01->
\&                       ##   middle/center 10->bottom/right bits 1-10 were reserved 
\&                       ##   for future use and should be 0.
\& SPACING       = 24;   ## discontinued
\& STRING        = 25;   ## ASCII String <= 512 characters
\& STRANS        = 26;   ## Bit Array: 2 bytes of bit flags for graphic presentation
\&                       ##   The 1st (high order or leftmost) bit specifies
\&                       ##   reflection. If set then reflection across the X-axis
\&                       ##   is applied before rotation. The 14th bit flags 
\&                       ##   absolute mag, the 15th absolute angle, the other bits
\&                       ##   were reserved for future use and should be 0.
\& MAG           = 27;   ## 8-byte Real
\& ANGLE         = 28;   ## 8-byte Real
\& UINTEGER      = 29;   ## UNKNOWN User int, used only in Calma V2.0
\& USTRING       = 30;   ## UNKNOWN User string, used only in Calma V2.0
\& REFLIBS       = 31;   ## ASCII String
\& FONTS         = 32;   ## ASCII String
\& PATHTYPE      = 33;   ## 2-byte Signed Integer
\& GENERATIONS   = 34;   ## 2-byte Signed Integer
\& ATTRTABLE     = 35;   ## ASCII String
\& STYPTABLE     = 36;   ## ASCII String "Unreleased feature"
\& STRTYPE       = 37;   ## 2-byte Signed Integer "Unreleased feature"
\& EFLAGS        = 38;   ## BIT_ARRAY  Flags for template and exterior data.  
\&                       ## bits 15 to 0, l to r 0=template, 1=external data, others unused
\& ELKEY         = 39;   ## INTEGER_4  "Unreleased feature"
\& LINKTYPE      = 40;   ## UNKNOWN    "Unreleased feature"
\& LINKKEYS      = 41;   ## UNKNOWN    "Unreleased feature"
\& NODETYPE      = 42;   ## INTEGER_2  Nodetype specification. On Calma this could be 0 to 63,
\&                       ##   GDSII allows 0 to 255. Of course a 16 bit integer allows up to 65535...
\& PROPATTR      = 43;   ## INTEGER_2  Property number.
\& PROPVALUE     = 44;   ## STRING     Property value. On GDSII, 128 characters max, unless an 
\&                       ##   SREF, AREF, or NODE, which may have 512 characters.
\& BOX           = 45;   ## NO_DATA    The beginning of a BOX element.
\& BOXTYPE       = 46;   ## INTEGER_2  Boxtype specification.
\& PLEX          = 47;   ## INTEGER_4  Plex number and plexhead flag. The least significant bit of 
\&                       ##   the most significant byte is the plexhead flag.
\& BGNEXTN       = 48;   ## INTEGER_4  Path extension beginning for pathtype 4 in Calma CustomPlus. 
\&                       ##   In database units, may be negative.
\& ENDEXTN       = 49;   ## INTEGER_4  Path extension end for pathtype 4 in Calma CustomPlus. In 
\&                       ##   database units, may be negative.
\& TAPENUM       = 50;   ## INTEGER_2  Tape number for multi-reel stream file.
\& TAPECODE      = 51;   ## INTEGER_2  Tape code to verify that the reel is from the proper set. 
\&                       ##   12 bytes that are supposed to form a unique tape code.
\& STRCLASS      = 52;   ## BIT_ARRAY  Calma use only. 
\& RESERVED      = 53;   ## INTEGER_4  Used to be NUMTYPES per Calma GDSII Stream Format Manual, v6.0.
\& FORMAT        = 54;   ## INTEGER_2  Archive or Filtered flag.  0: Archive 1: filtered
\& MASK          = 55;   ## STRING     Only in filtered streams. Layers and datatypes used for mask 
\&                       ##   in a filtered stream file. A string giving ranges of layers and datatypes
\&                       ##   separated by a semicolon. There may be more than one mask in a stream file.
\& ENDMASKS      = 56;   ## NO_DATA    The end of mask descriptions.
\& LIBDIRSIZE    = 57;   ## INTEGER_2  Number of pages in library director, a GDSII thing, it seems 
\&                       ##   to have only been used when Calma INFORM was creating a new library.
\& SRFNAME       = 58;   ## STRING     Calma "Sticks"(c) rule file name.
\& LIBSECUR      = 59;   ## INTEGER_2  Access control list stuff for CalmaDOS, ancient. INFORM used
\&                       ##   this when creating a new library. Had 1 to 32 entries with group 
\&                       ##   numbers, user numbers and access rights.
.Ve
