.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Digest 3"
.TH Digest 3 "2002-06-01" "perl v5.8.0" "Perl Programmers Reference Guide"
.SH "NAME"
Digest:: \- Modules that calculate message digests
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  $md2 = Digest->MD2;
\&  $md5 = Digest->MD5;
.Ve
.PP
.Vb 2
\&  $sha1 = Digest->SHA1;
\&  $sha1 = Digest->new("SHA-1");
.Ve
.PP
.Vb 1
\&  $hmac = Digest->HMAC_MD5($key);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Digest::\*(C'\fR modules calculate digests, also called \*(L"fingerprints\*(R"
or \*(L"hashes\*(R", of some data, called a message.  The digest is (usually)
some small/fixed size string.  The actual size of the digest depend of
the algorithm used.  The message is simply a sequence of arbitrary
bytes.
.PP
An important property of the digest algorithms is that the digest is
\&\fIlikely\fR to change if the message change in some way.  Another
property is that digest functions are one-way functions, i.e. it
should be \fIhard\fR to find a message that correspond to some given
digest.  Algorithms differ in how \*(L"likely\*(R" and how \*(L"hard\*(R", as well as
how efficient they are to compute.
.PP
All \f(CW\*(C`Digest::\*(C'\fR modules provide the same programming interface.  A
functional interface for simple use, as well as an object oriented
interface that can handle messages of arbitrary length and which can
read files directly.
.PP
The digest can be delivered in three formats:
.IP "\fIbinary\fR" 8
.IX Item "binary"
This is the most compact form, but it is not well suited for printing
or embedding in places that can't handle arbitrary data.
.IP "\fIhex\fR" 8
.IX Item "hex"
A twice as long string of (lowercase) hexadecimal digits.
.IP "\fIbase64\fR" 8
.IX Item "base64"
A string of portable printable characters.  This is the base64 encoded
representation of the digest with any trailing padding removed.  The
string will be about 30% longer than the binary version.
MIME::Base64 tells you more about this encoding.
.PP
The functional interface is simply importable functions with the same
name as the algorithm.  The functions take the message as argument and
return the digest.  Example:
.PP
.Vb 2
\&  use Digest::MD5 qw(md5);
\&  $digest = md5($message);
.Ve
.PP
There are also versions of the functions with \*(L"_hex\*(R" or \*(L"_base64\*(R"
appended to the name, which returns the digest in the indicated form.
.SH "OO INTERFACE"
.IX Header "OO INTERFACE"
The following methods are available for all \f(CW\*(C`Digest::\*(C'\fR modules:
.IP "$ctx = Digest\->\s-1XXX\s0($arg,...)" 4
.IX Item "$ctx = Digest->XXX($arg,...)"
.PD 0
.ie n .IP "$ctx = Digest\->new(\s-1XXX\s0 => $arg,...)" 4
.el .IP "$ctx = Digest\->new(\s-1XXX\s0 => \f(CW$arg\fR,...)" 4
.IX Item "$ctx = Digest->new(XXX => $arg,...)"
.IP "$ctx = Digest::XXX\->new($arg,...)" 4
.IX Item "$ctx = Digest::XXX->new($arg,...)"
.PD
The constructor returns some object that encapsulate the state of the
message-digest algorithm.  You can add data to the object and finally
ask for the digest.  The \*(L"\s-1XXX\s0\*(R" should of course be replaced by the proper
name of the digest algorithm you want to use.
.Sp
The two first forms are simply syntactic sugar which automatically
load the right module on first use.  The second form allow you to use
algorithm names which contains letters which are not legal perl
identifiers, e.g. \*(L"\s-1SHA\-1\s0\*(R".
.Sp
If \fInew()\fR is called as an instance method (i.e. \f(CW$ctx\fR\->new) it will just
reset the state the object to the state of a newly created object.  No
new object is created in this case, and the return value is the
reference to the object (i.e. \f(CW$ctx\fR).
.IP "$ctx\->reset" 4
.IX Item "$ctx->reset"
This is just an alias for \f(CW$ctx\fR\->new.
.IP "$ctx\->add($data,...)" 4
.IX Item "$ctx->add($data,...)"
The \f(CW$data\fR provided as argument are appended to the message we
calculate the digest for.  The return value is the \f(CW$ctx\fR object itself.
.IP "$ctx\->addfile($io_handle)" 4
.IX Item "$ctx->addfile($io_handle)"
The \f(CW$io_handle\fR is read until \s-1EOF\s0 and the content is appended to the
message we calculate the digest for.  The return value is the \f(CW$ctx\fR
object itself.
.IP "$ctx\->digest" 4
.IX Item "$ctx->digest"
Return the binary digest for the message.
.Sp
Note that the \f(CW\*(C`digest\*(C'\fR operation is effectively a destructive,
read-once operation. Once it has been performed, the \f(CW$ctx\fR object is
automatically \f(CW\*(C`reset\*(C'\fR and can be used to calculate another digest
value.
.IP "$ctx\->hexdigest" 4
.IX Item "$ctx->hexdigest"
Same as \f(CW$ctx\fR\->digest, but will return the digest in hexadecimal form.
.IP "$ctx\->b64digest" 4
.IX Item "$ctx->b64digest"
Same as \f(CW$ctx\fR\->digest, but will return the digest as a base64 encoded
string.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Digest::MD5, Digest::SHA1, Digest::HMAC, Digest::MD2
.PP
MIME::Base64
.SH "AUTHOR"
.IX Header "AUTHOR"
Gisle Aas <gisle@aas.no>
.PP
The \f(CW\*(C`Digest::\*(C'\fR interface is based on the interface originally
developed by Neil Winton for his \f(CW\*(C`MD5\*(C'\fR module.
