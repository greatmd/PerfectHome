.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Blowfish 3"
.TH Blowfish 3 "2001-11-12" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
Crypt::Blowfish \- Perl Blowfish encryption module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use Crypt::Blowfish;
\&  my $cipher = new Crypt::Blowfish $key; 
\&  my $ciphertext = $cipher->encrypt($plaintext);
\&  my $plaintext  = $cipher->decrypt($ciphertext);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Blowfish is capable of strong encryption and can use key sizes up
to 56 bytes (a 448 bit key).  You're encouraged to take advantage
of the full key size to ensure the strongest encryption possible
from this module.
.PP
Crypt::Blowfish has the following methods:
.Sp
.Vb 4
\& blocksize()
\& keysize()
\& encrypt()
\& decrypt()
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "blocksize" 4
.IX Item "blocksize"
Returns the size (in bytes) of the block cipher.
.Sp
Crypt::Blowfish doesn't return a key size due to its ability
to use variable-length keys. (well, more accurately, it won't
as of 2.09 .. for now, it does.  expect that to change)
.IP "new" 4
.IX Item "new"
.Vb 1
\&        my $cipher = new Crypt::Blowfish $key;
.Ve
.Sp
This creates a new Crypt::Blowfish BlockCipher object, using \f(CW$key\fR,
where \f(CW$key\fR is a key of \f(CW\*(C`keysize()\*(C'\fR bytes (minimum of eight bytes).
.IP "encrypt" 4
.IX Item "encrypt"
.Vb 2
\&        my $cipher = new Crypt::Blowfish $key;
\&        my $ciphertext = $cipher->encrypt($plaintext);
.Ve
.Sp
This function encrypts \f(CW$plaintext\fR and returns the \f(CW$ciphertext\fR
where \f(CW$plaintext\fR and \f(CW$ciphertext\fR must be of \f(CW\*(C`blocksize()\*(C'\fR bytes.
(hint:  Blowfish is an 8 byte block cipher)
.IP "decrypt" 4
.IX Item "decrypt"
.Vb 2
\&        my $cipher = new Crypt::Blowfish $key;
\&        my $plaintext = $cipher->decrypt($ciphertext);
.Ve
.Sp
This function decrypts \f(CW$ciphertext\fR and returns the \f(CW$plaintext\fR
where \f(CW$plaintext\fR and \f(CW$ciphertext\fR must be of \f(CW\*(C`blocksize()\*(C'\fR bytes.
(hint:  see previous hint)
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 4
\&        my $key = pack("H16", "0123456789ABCDEF");  # min. 8 bytes
\&        my $cipher = new Crypt::Blowfish $key;
\&        my $ciphertext = $cipher->encrypt("plaintex");  # SEE NOTES 
\&        print unpack("H16", $ciphertext), "\en";
.Ve
.SH "PLATFORMS"
.IX Header "PLATFORMS"
.Vb 2
\&        Please see the README document for platforms and performance
\&        tests.
.Ve
.SH "NOTES"
.IX Header "NOTES"
The module is capable of being used with Crypt::CBC.  You're
encouraged to read the perldoc for Crypt::CBC if you intend to
use this module for Cipher Block Chaining modes.  In fact, if
you have any intentions of encrypting more than eight bytes of
data with this, or any other block cipher, you're going to need
\&\fBsome\fR type of block chaining help.  Crypt::CBC tends to be
very good at this.  If you're not going to encrypt more than 
eight bytes, your data \fBmust\fR be \fBexactly\fR eight bytes long.
If need be, do your own padding. \*(L"\e0\*(R" as a null byte is perfectly
valid to use for this.  Additionally, the current maintainer for 
Crypt::Blowfish may or may not release Crypt::CBC_R which 
replaces the default 'RandomIV' initialization vector in 
Crypt::CBC with a random initialization vector.  (to the limits 
of /dev/urandom and associates)  In either case, please email
amused@pobox.com for Crypt::CBC_R.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Crypt::CBC,
Crypt::DES,
Crypt::IDEA
.PP
Bruce Schneier, \fIApplied Cryptography\fR, 1995, Second Edition,
published by John Wiley & Sons, Inc.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
The implementation of the Blowfish algorithm was developed by,
and is copyright of, A.M. Kuchling.
.PP
Other parts of the perl extension and module are
copyright of Systemics Ltd ( http://www.systemics.com/ ). 
.PP
Code revisions, updates, and standalone release are copyright
1999\-2001 W3Works, \s-1LLC\s0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Original algorithm, Bruce Shneier.  Original implementation, A.M.
Kuchling.  Original Perl implementation, Systemics Ltd.  Current
maintenance by W3Works, \s-1LLC\s0.
.PP
Current revision and maintainer:  Dave Paris <amused@pobox.com>
