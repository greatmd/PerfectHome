.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pastel::Color 3"
.TH Pastel::Color 3 "2003-04-06" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
Pastel::Color
.PP
The Pastel::Color class encapsulates colors in the default sRGB color space. At present
sRGB is the only Colorspace implemented.
.SH "Description"
.IX Header "Description"
Every color has an implicit alpha value of 1.0 or an explicit one provided in the
constructor. The alpha value defines the transparency of a color and can be represented
by a float value in the range 0.0 \- 1.0 . An alpha value of 1.0 
means that the color is completely opaque and an alpha value of 0 or 0.0 means that
the color is completely transparent.
.PP
The default color space for the Pastel::Color \s-1API\s0 is sRGB (at present the only colorspace
implemented). For further information on sRGB, see
<http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html>.
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 2
\&  use Pastel::Graphics;
\&  use strict;
.Ve
.PP
.Vb 3
\&  my $color  = Pastel::Color->new (10, 20, 30);
\&  my $color1 = Pastel::Color->new (-r=>10, -g=>20, -b=>30, -a=>0.5);
\&  my $color2 = Pastel::Color->new (10, 20, 30, 0.5); # $color now 50% transparent
.Ve
.PP
.Vb 4
\&  my $graphics = Pastel::Graphics->new(-width=>800, -height=>600);
\&  $graphics->set_paint($color); # All the drawing from now on will be in $color
\&  ...
\&  ...
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.ie n .IP "Pastel::Color\->new( $int\fR, \f(CW$int\fR, \f(CW$int);" 4
.el .IP "Pastel::Color\->new( \f(CW$int\fR, \f(CW$int\fR, \f(CW$int\fR);" 4
.IX Item "Pastel::Color->new( $int, $int, $int);"
Creates an sRGB color with the specified red, green, blue in the range (0 \- 255).
The tranparency is set to 1.0. Fully opaque.
.ie n .IP "Pastel::Color\->new( $int\fR, \f(CW$int\fR, \f(CW$int\fR, \f(CW$float_alpha)" 4
.el .IP "Pastel::Color\->new( \f(CW$int\fR, \f(CW$int\fR, \f(CW$int\fR, \f(CW$float_alpha\fR)" 4
.IX Item "Pastel::Color->new( $int, $int, $int, $float_alpha)"
Creates an sRGB color with the specified red, green, blue in the range (0 \- 255).
Alpha values in the range (0.0 \- 1.0). 
.IP "Pastel::Color\->new(\-r=>$int, \-g=>$int, \-b=>$int, \-a=>$float);" 4
.IX Item "Pastel::Color->new(-r=>$int, -g=>$int, -b=>$int, -a=>$float);"
With Perl style named parameters.
\&\-r = Red, \-g = Green , \-b = Blue, \-a = Alpha
.SH "FIELDS"
.IX Header "FIELDS"
.IP "_rgb_value" 4
.IX Item "_rgb_value"
Private.A value calculated from the Red, Green and the Blue integers supplied in the
constructors. Alpha value supplied is not stored in this value because of rounding
problems is Perl.
.IP "_alpha" 4
.IX Item "_alpha"
Private. Stores the transparency float value.
.SH "ACCESSORS"
.IX Header "ACCESSORS"
.Sh "\fIget_rgb()\fP"
.IX Subsection "get_rgb()"
Returns \s-1RGB\s0 value of the color. Red channel by bits 16\-23, Green by bits 8\-15
and Blue by bits 0\-7. Transparency value is not stored at bits 24\-32, unlike the
Java implementation, to avoid rounding error problems in Perl. To get Transparency
(alpha) value use \fIget_alpha()\fR method.
.PP
Usage: \f(CW$color\fR\->\fIget_rgb()\fR
.Sh "\fIget_red()\fP"
.IX Subsection "get_red()"
Return the Red chaneel value in integer in the range 0\-255.
.PP
Usage: \f(CW$color\fR\->\fIget_red()\fR
.Sh "\fIget_green()\fP"
.IX Subsection "get_green()"
Return the Green chaneel value in integer in the range 0\-255.
.PP
Usage: \f(CW$color\fR\->\fIget_green()\fR
.Sh "\fIget_blue()\fP"
.IX Subsection "get_blue()"
Return the Blue chaneel value in integer in the range 0\-255.
.PP
Usage: \f(CW$color\fR\->\fIget_blue()\fR
.Sh "\fIget_alpha()\fP"
.IX Subsection "get_alpha()"
Return the Alpha (transparency) value in the range 0.0 \- 1.0.
.PP
Usage: \f(CW$color\fR\->\fIget_alpha()\fR
.SH "METHODS"
.IX Header "METHODS"
.Sh "\fIbrighter()\fP"
.IX Subsection "brighter()"
Return a brighter version of the present Color object.
.PP
.Vb 1
\&    Usage: my $brighter = $color->brighter();
.Ve
.Sh "\fIdarker()\fP"
.IX Subsection "darker()"
Return a darker version of the present color object.
.PP
.Vb 1
\& Usage: my $darker_color = $color->darker();
.Ve
.Sh "\fIblack()\fP"
.IX Subsection "black()"
Return a color object \*(L"black\*(R".
.PP
.Vb 1
\& Usage: my $graphics->set_paint( Pastel::Color->black() );
.Ve
.Sh "\fIblue()\fP"
.IX Subsection "blue()"
Return a color object \*(L"blue\*(R"
.PP
.Vb 1
\& Usage: my $graphics->set_paint ( Pastel::Color->blue());
.Ve
.Sh "\fIred()\fP"
.IX Subsection "red()"
Returns a color object \*(L"red\*(R".
.PP
.Vb 1
\& Usage: my $graphics->set_paint ( Pastel::Color->red());
.Ve
.Sh "\fIwhite()\fP"
.IX Subsection "white()"
Returns a color object \*(L"white\*(R".
.PP
.Vb 1
\& Usage: my $graphics->set_paint ( Pastel::Color->white());
.Ve
.Sh "\fIlight_gray()\fP"
.IX Subsection "light_gray()"
Returns a color object \*(L"light_gray\*(R".
.PP
.Vb 1
\& Usage: my $graphics->set_paint ( Pastel::Color->light_gray());
.Ve
.Sh "\fIgray()\fP"
.IX Subsection "gray()"
Returns a color object \*(L"gray\*(R".
.PP
.Vb 1
\& Usage: my $graphics->set_paint ( Pastel::Color->gray());
.Ve
.Sh "\fIdark_gray()\fP"
.IX Subsection "dark_gray()"
Returns a color object \*(L"dark_gray\*(R".
.PP
.Vb 1
\& Usage: my $graphics->set_paint ( Pastel::Color->dark_gray());
.Ve
.Sh "\fIpink()\fP"
.IX Subsection "pink()"
Returns a color object \*(L"pink\*(R".
.PP
.Vb 1
\& Usage: my $graphics->set_paint ( Pastel::Color->pink());
.Ve
.Sh "\fIorange()\fP"
.IX Subsection "orange()"
Returns a color object \*(L"red\*(R".
.PP
.Vb 1
\& Usage: my $graphics->set_paint ( Pastel::Color->orange());
.Ve
.Sh "\fIyellow()\fP"
.IX Subsection "yellow()"
Returns a color object \*(L"yellow\*(R".
.PP
.Vb 1
\& Usage: my $graphics->set_paint ( Pastel::Color->yellow());
.Ve
.Sh "\fIgreen()\fP"
.IX Subsection "green()"
Returns a color object \*(L"green\*(R".
.PP
.Vb 1
\& Usage: my $graphics->set_paint ( Pastel::Color->green());
.Ve
.Sh "\fImagenta()\fP"
.IX Subsection "magenta()"
Returns a color object \*(L"magenta\*(R".
.PP
.Vb 1
\& Usage: my $graphics->set_paint ( Pastel::Color->magenta());
.Ve
.Sh "\fIcyan()\fP"
.IX Subsection "cyan()"
Returns a color object \*(L"cyan\*(R".
.PP
.Vb 1
\& Usage: my $graphics->set_paint ( Pastel::Color->cyan());
.Ve
.ie n .Sh "equals(Color $color)"
.el .Sh "equals(Color \f(CW$color\fP)"
.IX Subsection "equals(Color $color)"
Returns true if \f(CW$color\fR is equivalent to the present color. This method
compares the \*(L"red\*(R", \*(L"green\*(R", \*(L"blue\*(R" and the \*(L"alpha\*(R" value of the two colors
and return 1 if both are same or returns 0 if they are diffrent.
.PP
.Vb 3
\& Usage: my $color1 = Pastel::Color->new(255, 255, 255);
\&        my $white = Pastel::Color->white();
\&        print "They are same" if $color1->equals($white);
.Ve
.Sh "\fIto_string()\fP"
.IX Subsection "to_string()"
Returns the string representation of the object.
.PP
.Vb 1
\& Usage: $color->to_string();
.Ve
.SH "PRIVATE METHODS"
.IX Header "PRIVATE METHODS"
.Sh "\fIto_svg()\fP"
.IX Subsection "to_svg()"
Return the string Pastel coded form of this object. Called by any object with
style color.
