.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Time::HiRes 3"
.TH Time::HiRes 3 "2002-06-01" "perl v5.8.0" "Perl Programmers Reference Guide"
.SH "NAME"
Time::HiRes \- High resolution alarm, sleep, gettimeofday, interval timers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Time::HiRes qw( usleep ualarm gettimeofday tv_interval );
.Ve
.PP
.Vb 1
\&  usleep ($microseconds);
.Ve
.PP
.Vb 2
\&  ualarm ($microseconds);
\&  ualarm ($microseconds, $interval_microseconds);
.Ve
.PP
.Vb 2
\&  $t0 = [gettimeofday];
\&  ($seconds, $microseconds) = gettimeofday;
.Ve
.PP
.Vb 3
\&  $elapsed = tv_interval ( $t0, [$seconds, $microseconds]);
\&  $elapsed = tv_interval ( $t0, [gettimeofday]);
\&  $elapsed = tv_interval ( $t0 );
.Ve
.PP
.Vb 1
\&  use Time::HiRes qw ( time alarm sleep );
.Ve
.PP
.Vb 4
\&  $now_fractions = time;
\&  sleep ($floating_seconds);
\&  alarm ($floating_seconds);
\&  alarm ($floating_seconds, $floating_interval);
.Ve
.PP
.Vb 2
\&  use Time::HiRes qw( setitimer getitimer
\&                      ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF );
.Ve
.PP
.Vb 2
\&  setitimer ($which, $floating_seconds, $floating_interval );
\&  getitimer ($which);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Time::HiRes\*(C'\fR module implements a Perl interface to the usleep,
ualarm, gettimeofday, and setitimer/getitimer system calls. See the
\&\s-1EXAMPLES\s0 section below and the test scripts for usage; see your system
documentation for the description of the underlying usleep, ualarm,
gettimeofday, and setitimer/getitimer calls.
.PP
If your system lacks \fIgettimeofday\fR\|(2) or an emulation of it you don't
get \fIgettimeofday()\fR or the one-arg form of \fItv_interval()\fR.
If you don't have \fIusleep\fR\|(3) or \fIselect\fR\|(2) you don't get \fIusleep()\fR
or \fIsleep()\fR.  If your system don't have \fIualarm\fR\|(3) or \fIsetitimer\fR\|(2) you
don't get \fIualarm()\fR or \fIalarm()\fR.  If you try to import an unimplemented
function in the \f(CW\*(C`use\*(C'\fR statement it will fail at compile time.
.PP
The following functions can be imported from this module.
No functions are exported by default.
.IP "gettimeofday ()" 4
.IX Item "gettimeofday ()"
In array context returns a 2 element array with the seconds and
microseconds since the epoch.  In scalar context returns floating
seconds like \fITime::HiRes::time()\fR (see below).
.ie n .IP "usleep ( $useconds )" 4
.el .IP "usleep ( \f(CW$useconds\fR )" 4
.IX Item "usleep ( $useconds )"
Sleeps for the number of microseconds specified.  Returns the number
of microseconds actually slept.  Can sleep for more than one second
unlike the usleep system call. See also \fITime::HiRes::sleep()\fR below.
.ie n .IP "ualarm ( $useconds\fR [, \f(CW$interval_useconds ] )" 4
.el .IP "ualarm ( \f(CW$useconds\fR [, \f(CW$interval_useconds\fR ] )" 4
.IX Item "ualarm ( $useconds [, $interval_useconds ] )"
Issues a ualarm call; interval_useconds is optional and will be 0 if 
unspecified, resulting in alarm-like behaviour.
.IP "tv_interval" 4
.IX Item "tv_interval"
\&\f(CW\*(C`tv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )\*(C'\fR
.Sp
Returns the floating seconds between the two times, which should have
been returned by \fIgettimeofday()\fR. If the second argument is omitted,
then the current time is used.
.IP "time ()" 4
.IX Item "time ()"
Returns a floating seconds since the epoch. This function can be
imported, resulting in a nice drop-in replacement for the \f(CW\*(C`time\*(C'\fR
provided with core Perl, see the \s-1EXAMPLES\s0 below.
.Sp
\&\fB\s-1NOTE\s0 1\fR: this higher resolution timer can return values either less or
more than the core \fItime()\fR, depending on whether your platforms rounds
the higher resolution timer values up, down, or to the nearest to get
the core \fItime()\fR, but naturally the difference should be never more than
half a second.
.Sp
\&\fB\s-1NOTE\s0 2\fR: Since Sunday, September 9th, 2001 at 01:46:40 \s-1AM\s0 \s-1GMT\s0
(when the \fItime()\fR seconds since epoch rolled over to 1_000_000_000),
the default floating point format of Perl and the seconds since epoch
have conspired to produce an apparent bug: if you print the value of
\&\fITime::HiRes::time()\fR you seem to be getting only five decimals, not six
as promised (microseconds).  Not to worry, the microseconds are there
(assuming your platform supports such granularity).  What is going on
is that the default floating point format of Perl only outputs 15
digits.  In this case that means ten digits before the decimal
separator and five after.  To see the microseconds you can use either
printf/sprintf with \f(CW\*(C`%.6f\*(C'\fR, or the \fIgettimeofday()\fR function in list
context, which will give you the seconds and microseconds as two
separate values.
.ie n .IP "sleep ( $floating_seconds )" 4
.el .IP "sleep ( \f(CW$floating_seconds\fR )" 4
.IX Item "sleep ( $floating_seconds )"
Sleeps for the specified amount of seconds.  Returns the number of
seconds actually slept (a floating point value).  This function can be
imported, resulting in a nice drop-in replacement for the \f(CW\*(C`sleep\*(C'\fR
provided with perl, see the \s-1EXAMPLES\s0 below.
.ie n .IP "alarm ( $floating_seconds\fR [, \f(CW$interval_floating_seconds ] )" 4
.el .IP "alarm ( \f(CW$floating_seconds\fR [, \f(CW$interval_floating_seconds\fR ] )" 4
.IX Item "alarm ( $floating_seconds [, $interval_floating_seconds ] )"
The \s-1SIGALRM\s0 signal is sent after the specfified number of seconds.
Implemented using \fIualarm()\fR.  The \f(CW$interval_floating_seconds\fR argument
is optional and will be 0 if unspecified, resulting in \fIalarm()\fR\-like
behaviour.  This function can be imported, resulting in a nice drop-in
replacement for the \f(CW\*(C`alarm\*(C'\fR provided with perl, see the \s-1EXAMPLES\s0 below.
.IP "setitimer" 4
.IX Item "setitimer"
\&\f(CW\*(C`setitimer ( $which, $floating_seconds [, $interval_floating_seconds ] )\*(C'\fR
.Sp
Start up an interval timer: after a certain time, a signal arrives,
and more signals may keep arriving at certain intervals.  To disable
a timer, use time of zero.  If interval is set to zero (or unspecified),
the timer is disabled \fBafter\fR the next delivered signal.
.Sp
Use of interval timers may interfere with \fIalarm()\fR, \fIsleep()\fR, and \fIusleep()\fR.
In standard-speak the \*(L"interaction is unspecified\*(R", which means that
\&\fIanything\fR may happen: it may work, it may not.
.Sp
In scalar context, the remaining time in the timer is returned.
.Sp
In list context, both the remaining time and the interval are returned.
.Sp
There are three interval timers: the \f(CW$which\fR can be \s-1ITIMER_REAL\s0,
\&\s-1ITIMER_VIRTUAL\s0, or \s-1ITIMER_PROF\s0.
.Sp
\&\s-1ITIMER_REAL\s0 results in \fIalarm()\fR\-like behavior.  Time is counted in
\&\fIreal time\fR, that is, wallclock time.  \s-1SIGALRM\s0 is delivered when
the timer expires.
.Sp
\&\s-1ITIMER_VIRTUAL\s0 counts time in (process) \fIvirtual time\fR, that is, only
when the process is running.  In multiprocessor/user/CPU systems this
may be more or less than real or wallclock time.  (This time is also
known as the \fIuser time\fR.)  \s-1SIGVTALRM\s0 is delivered when the timer expires.
.Sp
\&\s-1ITIMER_PROF\s0 counts time when either the process virtual time or when
the operating system is running on behalf of the process (such as
I/O).  (This time is also known as the \fIsystem time\fR.)  (Collectively
these times are also known as the \fI\s-1CPU\s0 time\fR.)  \s-1SIGPROF\s0 is delivered
when the timer expires.  \s-1SIGPROF\s0 can interrupt system calls.
.Sp
The semantics of interval timers for multithreaded programs are
system\-specific, and some systems may support additional interval
timers.  See your \fIsetitimer()\fR documentation.
.ie n .IP "getitimer ( $which )" 4
.el .IP "getitimer ( \f(CW$which\fR )" 4
.IX Item "getitimer ( $which )"
Return the remaining time in the interval timer specified by \f(CW$which\fR.
.Sp
In scalar context, the remaining time is returned.
.Sp
In list context, both the remaining time and the interval are returned.
The interval is always what you put in using \fIsetitimer()\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&  use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);
.Ve
.PP
.Vb 2
\&  $microseconds = 750_000;
\&  usleep $microseconds;
.Ve
.PP
.Vb 2
\&  # signal alarm in 2.5s & every .1s thereafter
\&  ualarm 2_500_000, 100_000;
.Ve
.PP
.Vb 2
\&  # get seconds and microseconds since the epoch
\&  ($s, $usec) = gettimeofday;
.Ve
.PP
.Vb 7
\&  # measure elapsed time 
\&  # (could also do by subtracting 2 gettimeofday return values)
\&  $t0 = [gettimeofday];
\&  # do bunch of stuff here
\&  $t1 = [gettimeofday];
\&  # do more stuff here
\&  $t0_t1 = tv_interval $t0, $t1;
.Ve
.PP
.Vb 2
\&  $elapsed = tv_interval ($t0, [gettimeofday]);
\&  $elapsed = tv_interval ($t0); # equivalent code
.Ve
.PP
.Vb 8
\&  #
\&  # replacements for time, alarm and sleep that know about
\&  # floating seconds
\&  #
\&  use Time::HiRes;
\&  $now_fractions = Time::HiRes::time;
\&  Time::HiRes::sleep (2.5);
\&  Time::HiRes::alarm (10.6666666);
.Ve
.PP
.Vb 4
\&  use Time::HiRes qw ( time alarm sleep );
\&  $now_fractions = time;
\&  sleep (2.5);
\&  alarm (10.6666666);
.Ve
.PP
.Vb 2
\&  # Arm an interval timer to go off first at 10 seconds and
\&  # after that every 2.5 seconds, in process virtual time
.Ve
.PP
.Vb 1
\&  use Time::HiRes qw ( setitimer ITIMER_VIRTUAL time );
.Ve
.PP
.Vb 2
\&  $SIG{VTLARM} = sub { print time, "\en" };
\&  setitimer(ITIMER_VIRTUAL, 10, 2.5);
.Ve
.SH "C API"
.IX Header "C API"
In addition to the perl \s-1API\s0 described above, a C \s-1API\s0 is available for
extension writers.  The following C functions are available in the
modglobal hash:
.PP
.Vb 4
\&  name             C prototype
\&  ---------------  ----------------------
\&  Time::NVtime     double (*)()
\&  Time::U2time     void (*)(UV ret[2])
.Ve
.PP
Both functions return equivalent information (like \f(CW\*(C`gettimeofday\*(C'\fR)
but with different representations.  The names \f(CW\*(C`NVtime\*(C'\fR and \f(CW\*(C`U2time\*(C'\fR
were selected mainly because they are operating system independent.
(\f(CW\*(C`gettimeofday\*(C'\fR is Un*x\-centric.)
.PP
Here is an example of using NVtime from C:
.PP
.Vb 6
\&  double (*myNVtime)();
\&  SV **svp = hv_fetch(PL_modglobal, "Time::NVtime", 12, 0);
\&  if (!svp)         croak("Time::HiRes is required");
\&  if (!SvIOK(*svp)) croak("Time::NVtime isn't a function pointer");
\&  myNVtime = INT2PTR(double(*)(), SvIV(*svp));
\&  printf("The current time is: %f\en", (*myNVtime)());
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
Notice that the core \fItime()\fR maybe rounding rather than truncating.
What this means that the core \fItime()\fR may be giving time one second
later than \fIgettimeofday()\fR, also known as \fITime::HiRes::time()\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
D. Wegscheid <wegscd@whirlpool.com>
R. Schertler <roderick@argon.org>
J. Hietaniemi <jhi@iki.fi>
G. Aas <gisle@aas.no>
.SH "REVISION"
.IX Header "REVISION"
$Id: HiRes.pm,v 1.20 1999/03/16 02:26:13 wegscd Exp $
.PP
$Log: HiRes.pm,v $
Revision 1.20  1999/03/16 02:26:13  wegscd
Add documentation for NVTime and U2Time.
.PP
Revision 1.19  1998/09/30 02:34:42  wegscd
No changes, bump version.
.PP
Revision 1.18  1998/07/07 02:41:35  wegscd
No changes, bump version.
.PP
Revision 1.17  1998/07/02 01:45:13  wegscd
Bump version to 1.17
.PP
Revision 1.16  1997/11/13 02:06:36  wegscd
version bump to accomodate HiRes.xs fix.
.PP
Revision 1.15  1997/11/11 02:17:59  wegscd
\&\s-1POD\s0 editing, courtesy of Gisle Aas.
.PP
Revision 1.14  1997/11/06 03:14:35  wegscd
Update version # for Makefile.PL and HiRes.xs changes.
.PP
Revision 1.13  1997/11/05 05:36:25  wegscd
change version # for Makefile.pl and HiRes.xs changes.
.PP
Revision 1.12  1997/10/13 20:55:33  wegscd
Force a new version for Makefile.PL changes.
.PP
Revision 1.11  1997/09/05 19:59:33  wegscd
New version to bump version for \s-1README\s0 and Makefile.PL fixes.
Fix bad \s-1RCS\s0 log.
.PP
Revision 1.10  1997/05/23 01:11:38  wegscd
Conditional compilation; \s-1EXPORT_FAIL\s0 fixes.
.PP
Revision 1.2  1996/12/30 13:28:40  wegscd
Update documentation for what to do when missing \fIualarm()\fR and friends.
.PP
Revision 1.1  1996/10/17 20:53:31  wegscd
Fix =head1 being next to _\|_END_\|_ so pod2man works
.PP
Revision 1.0  1996/09/03 18:25:15  wegscd
Initial revision
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1996\-1997 Douglas E. Wegscheid.
All rights reserved. This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.
