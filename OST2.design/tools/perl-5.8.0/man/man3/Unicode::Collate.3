.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Unicode::Collate 3"
.TH Unicode::Collate 3 "2002-06-01" "perl v5.8.0" "Perl Programmers Reference Guide"
.SH "NAME"
Unicode::Collate \- Unicode Collation Algorithm
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Unicode::Collate;
.Ve
.PP
.Vb 2
\&  #construct
\&  $Collator = Unicode::Collate->new(%tailoring);
.Ve
.PP
.Vb 2
\&  #sort
\&  @sorted = $Collator->sort(@not_sorted);
.Ve
.PP
.Vb 2
\&  #compare
\&  $result = $Collator->cmp($a, $b); # returns 1, 0, or -1.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Constructor and Tailoring"
.IX Subsection "Constructor and Tailoring"
The \f(CW\*(C`new\*(C'\fR method returns a collator object.
.PP
.Vb 20
\&   $Collator = Unicode::Collate->new(
\&      alternate => $alternate,
\&      backwards => $levelNumber, # or \e@levelNumbers
\&      entry => $element,
\&      normalization  => $normalization_form,
\&      ignoreName => qr/$ignoreName/,
\&      ignoreChar => qr/$ignoreChar/,
\&      katakana_before_hiragana => $bool,
\&      level => $collationLevel,
\&      overrideCJK => \e&overrideCJK,
\&      overrideHangul => \e&overrideHangul,
\&      preprocess => \e&preprocess,
\&      rearrange => \e@charList,
\&      table => $filename,
\&      undefName => qr/$undefName/,
\&      undefChar => qr/$undefChar/,
\&      upper_before_lower => $bool,
\&   );
\&   # if %tailoring is false (i.e. empty),
\&   # $Collator should do the default collation.
.Ve
.IP "alternate" 4
.IX Item "alternate"
\&\-\- see 3.2.2 Alternate Weighting, \s-1UTR\s0 #10.
.Sp
This key allows to alternate weighting for variable collation elements,
which are marked with an \s-1ASTERISK\s0 in the table
(\s-1NOTE:\s0 Many punction marks and symbols are variable in \fIallkeys.txt\fR).
.Sp
.Vb 1
\&   alternate => 'blanked', 'non-ignorable', 'shifted', or 'shift-trimmed'.
.Ve
.Sp
These names are case\-insensitive.
By default (if specification is omitted), 'shifted' is adopted.
.Sp
.Vb 2
\&   'Blanked'        Variable elements are ignorable at levels 1 through 3;
\&                    considered at the 4th level.
.Ve
.Sp
.Vb 1
\&   'Non-ignorable'  Variable elements are not reset to ignorable.
.Ve
.Sp
.Vb 3
\&   'Shifted'        Variable elements are ignorable at levels 1 through 3
\&                    their level 4 weight is replaced by the old level 1 weight.
\&                    Level 4 weight for Non-Variable elements is 0xFFFF.
.Ve
.Sp
.Vb 2
\&   'Shift-Trimmed'  Same as 'shifted', but all FFFF's at the 4th level
\&                    are trimmed.
.Ve
.IP "backwards" 4
.IX Item "backwards"
\&\-\- see 3.1.2 French Accents, \s-1UTR\s0 #10.
.Sp
.Vb 1
\&     backwards => $levelNumber or \e@levelNumbers
.Ve
.Sp
Weights in reverse order; ex. level 2 (diacritic ordering) in French.
If omitted, forwards at all the levels.
.IP "entry" 4
.IX Item "entry"
\&\-\- see 3.1 Linguistic Features; 3.2.1 File Format, \s-1UTR\s0 #10.
.Sp
Overrides a default order or defines additional collation elements
.Sp
.Vb 5
\&  entry => <<'ENTRIES', # use the UCA file format
\&00E6 ; [.0861.0020.0002.00E6] [.08B1.0020.0002.00E6] # ligature <ae> as <a><e>
\&0063 0068 ; [.0893.0020.0002.0063]      # "ch" in traditional Spanish
\&0043 0068 ; [.0893.0020.0008.0043]      # "Ch" in traditional Spanish
\&ENTRIES
.Ve
.IP "ignoreName" 4
.IX Item "ignoreName"
.PD 0
.IP "ignoreChar" 4
.IX Item "ignoreChar"
.PD
\&\-\- see Completely Ignorable, 3.2.2 Alternate Weighting, \s-1UTR\s0 #10.
.Sp
Makes the entry in the table ignorable.
If a collation element is ignorable,
it is ignored as if the element had been deleted from there.
.Sp
E.g. when 'a' and 'e' are ignorable,
\&'element' is equal to 'lament' (or 'lmnt').
.IP "level" 4
.IX Item "level"
\&\-\- see 4.3 Form a sort key for each string, \s-1UTR\s0 #10.
.Sp
Set the maximum level.
Any higher levels than the specified one are ignored.
.Sp
.Vb 4
\&  Level 1: alphabetic ordering
\&  Level 2: diacritic ordering
\&  Level 3: case ordering
\&  Level 4: tie-breaking (e.g. in the case when alternate is 'shifted')
.Ve
.Sp
.Vb 1
\&  ex.level => 2,
.Ve
.Sp
If omitted, the maximum is the 4th.
.IP "normalization" 4
.IX Item "normalization"
\&\-\- see 4.1 Normalize each input string, \s-1UTR\s0 #10.
.Sp
If specified, strings are normalized before preparation of sort keys
(the normalization is executed after preprocess).
.Sp
As a form name, one of the following names must be used.
.Sp
.Vb 4
\&  'C'  or 'NFC'  for Normalization Form C
\&  'D'  or 'NFD'  for Normalization Form D
\&  'KC' or 'NFKC' for Normalization Form KC
\&  'KD' or 'NFKD' for Normalization Form KD
.Ve
.Sp
If omitted, the string is put into Normalization Form D.
.Sp
If \f(CW\*(C`undef\*(C'\fR is passed explicitly as the value for this key,
any normalization is not carried out (this may make tailoring easier
if any normalization is not desired).
.Sp
see \fB\s-1CAVEAT\s0\fR.
.IP "overrideCJK" 4
.IX Item "overrideCJK"
\&\-\- see 7.1 Derived Collation Elements, \s-1UTR\s0 #10.
.Sp
By default, mapping of \s-1CJK\s0 Unified Ideographs
uses the Unicode codepoint order.
But the mapping of \s-1CJK\s0 Unified Ideographs may be overrided.
.Sp
ex. \s-1CJK\s0 Unified Ideographs in the \s-1JIS\s0 code point order.
.Sp
.Vb 7
\&  overrideCJK => sub {
\&      my $u = shift;             # get a Unicode codepoint
\&      my $b = pack('n', $u);     # to UTF-16BE
\&      my $s = your_unicode_to_sjis_converter($b); # convert
\&      my $n = unpack('n', $s);   # convert sjis to short
\&      [ $n, 0x20, 0x2, $u ];     # return the collation element
\&  },
.Ve
.Sp
ex. ignores all \s-1CJK\s0 Unified Ideographs.
.Sp
.Vb 1
\&  overrideCJK => sub {()}, # CODEREF returning empty list
.Ve
.Sp
.Vb 2
\&   # where ->eq("Pe\ex{4E00}rl", "Perl") is true
\&   # as U+4E00 is a CJK Unified Ideograph and to be ignorable.
.Ve
.Sp
If \f(CW\*(C`undef\*(C'\fR is passed explicitly as the value for this key,
weights for \s-1CJK\s0 Unified Ideographs are treated as undefined.
But assignment of weight for \s-1CJK\s0 Unified Ideographs
in table or entry is still valid.
.IP "overrideHangul" 4
.IX Item "overrideHangul"
\&\-\- see 7.1 Derived Collation Elements, \s-1UTR\s0 #10.
.Sp
By default, Hangul Syllables are decomposed into Hangul Jamo.
But the mapping of Hangul Syllables may be overrided.
.Sp
This tag works like overrideCJK, so see there for examples.
.Sp
If you want to override the mapping of Hangul Syllables,
the Normalization Forms D and \s-1KD\s0 are not appropriate
(they will be decomposed before overriding).
.Sp
If \f(CW\*(C`undef\*(C'\fR is passed explicitly as the value for this key,
weight for Hangul Syllables is treated as undefined
without decomposition into Hangul Jamo.
But definition of weight for Hangul Syllables
in table or entry is still valid.
.IP "preprocess" 4
.IX Item "preprocess"
\&\-\- see 5.1 Preprocessing, \s-1UTR\s0 #10.
.Sp
If specified, the coderef is used to preprocess
before the formation of sort keys.
.Sp
ex. dropping English articles, such as \*(L"a\*(R" or \*(L"the\*(R".
Then, \*(L"the pen\*(R" is before \*(L"a pencil\*(R".
.Sp
.Vb 5
\&     preprocess => sub {
\&           my $str = shift;
\&           $str =~ s/\eb(?:an?|the)\es+//gi;
\&           $str;
\&        },
.Ve
.IP "rearrange" 4
.IX Item "rearrange"
\&\-\- see 3.1.3 Rearrangement, \s-1UTR\s0 #10.
.Sp
Characters that are not coded in logical order and to be rearranged.
By default,
.Sp
.Vb 1
\&    rearrange => [ 0x0E40..0x0E44, 0x0EC0..0x0EC4 ],
.Ve
.Sp
If you want to disallow any rearrangement,
pass \f(CW\*(C`undef\*(C'\fR or \f(CW\*(C`[]\*(C'\fR (a reference to an empty list)
as the value for this key.
.IP "table" 4
.IX Item "table"
\&\-\- see 3.2 Default Unicode Collation Element Table, \s-1UTR\s0 #10.
.Sp
You can use another element table if desired.
The table file must be in your \f(CW\*(C`lib/Unicode/Collate\*(C'\fR directory.
.Sp
By default, the file \f(CW\*(C`lib/Unicode/Collate/allkeys.txt\*(C'\fR is used.
.Sp
If \f(CW\*(C`undef\*(C'\fR is passed explicitly as the value for this key,
no file is read (but you can define collation elements via entry).
.Sp
A typical way to define a collation element table
without any file of table:
.Sp
.Vb 11
\&   $onlyABC = Unicode::Collate->new(
\&       table => undef,
\&       entry => << 'ENTRIES',
\&0061 ; [.0101.0020.0002.0061] # LATIN SMALL LETTER A
\&0041 ; [.0101.0020.0008.0041] # LATIN CAPITAL LETTER A
\&0062 ; [.0102.0020.0002.0062] # LATIN SMALL LETTER B
\&0042 ; [.0102.0020.0008.0042] # LATIN CAPITAL LETTER B
\&0063 ; [.0103.0020.0002.0063] # LATIN SMALL LETTER C
\&0043 ; [.0103.0020.0008.0043] # LATIN CAPITAL LETTER C
\&ENTRIES
\&    );
.Ve
.IP "undefName" 4
.IX Item "undefName"
.PD 0
.IP "undefChar" 4
.IX Item "undefChar"
.PD
\&\-\- see 6.3.4 Reducing the Repertoire, \s-1UTR\s0 #10.
.Sp
Undefines the collation element as if it were unassigned in the table.
This reduces the size of the table.
If an unassigned character appears in the string to be collated,
the sort key is made from its codepoint
as a single-character collation element,
as it is greater than any other assigned collation elements
(in the codepoint order among the unassigned characters).
But, it'd be better to ignore characters
unfamiliar to you and maybe never used.
.IP "katakana_before_hiragana" 4
.IX Item "katakana_before_hiragana"
.PD 0
.IP "upper_before_lower" 4
.IX Item "upper_before_lower"
.PD
\&\-\- see 6.6 Case Comparisons; 7.3.1 Tertiary Weight Table, \s-1UTR\s0 #10.
.Sp
By default, lowercase is before uppercase
and hiragana is before katakana.
.Sp
If the tag is made true, this is reversed.
.Sp
\&\fB\s-1NOTE\s0\fR: These tags simplemindedly assume
any lowercase/uppercase or hiragana/katakana distinctions
should occur in level 3, and their weights at level 3
should be same as those mentioned in 7.3.1, \s-1UTR\s0 #10.
If you define your collation elements which violates this,
these tags doesn't work validly.
.Sh "Methods for Collation"
.IX Subsection "Methods for Collation"
.ie n .IP """@sorted = $Collator\->sort(@not_sorted)""" 4
.el .IP "\f(CW@sorted = $Collator\->sort(@not_sorted)\fR" 4
.IX Item "@sorted = $Collator->sort(@not_sorted)"
Sorts a list of strings.
.ie n .IP """$result = $Collator\->cmp($a, $b)""" 4
.el .IP "\f(CW$result = $Collator\->cmp($a, $b)\fR" 4
.IX Item "$result = $Collator->cmp($a, $b)"
Returns 1 (when \f(CW$a\fR is greater than \f(CW$b\fR)
or 0 (when \f(CW$a\fR is equal to \f(CW$b\fR)
or \-1 (when \f(CW$a\fR is lesser than \f(CW$b\fR).
.ie n .IP """$result = $Collator\->eq($a, $b)""" 4
.el .IP "\f(CW$result = $Collator\->eq($a, $b)\fR" 4
.IX Item "$result = $Collator->eq($a, $b)"
.PD 0
.ie n .IP """$result = $Collator\->ne($a, $b)""" 4
.el .IP "\f(CW$result = $Collator\->ne($a, $b)\fR" 4
.IX Item "$result = $Collator->ne($a, $b)"
.ie n .IP """$result = $Collator\->lt($a, $b)""" 4
.el .IP "\f(CW$result = $Collator\->lt($a, $b)\fR" 4
.IX Item "$result = $Collator->lt($a, $b)"
.ie n .IP """$result = $Collator\->le($a, $b)""" 4
.el .IP "\f(CW$result = $Collator\->le($a, $b)\fR" 4
.IX Item "$result = $Collator->le($a, $b)"
.ie n .IP """$result = $Collator\->gt($a, $b)""" 4
.el .IP "\f(CW$result = $Collator\->gt($a, $b)\fR" 4
.IX Item "$result = $Collator->gt($a, $b)"
.ie n .IP """$result = $Collator\->ge($a, $b)""" 4
.el .IP "\f(CW$result = $Collator\->ge($a, $b)\fR" 4
.IX Item "$result = $Collator->ge($a, $b)"
.PD
They works like the same name operators as theirs.
.Sp
.Vb 6
\&   eq : whether $a is equal to $b.
\&   ne : whether $a is not equal to $b.
\&   lt : whether $a is lesser than $b.
\&   le : whether $a is lesser than $b or equal to $b.
\&   gt : whether $a is greater than $b.
\&   ge : whether $a is greater than $b or equal to $b.
.Ve
.ie n .IP """$sortKey = $Collator\->getSortKey($string)""" 4
.el .IP "\f(CW$sortKey = $Collator\->getSortKey($string)\fR" 4
.IX Item "$sortKey = $Collator->getSortKey($string)"
\&\-\- see 4.3 Form a sort key for each string, \s-1UTR\s0 #10.
.Sp
Returns a sort key.
.Sp
You compare the sort keys using a binary comparison
and get the result of the comparison of the strings using \s-1UCA\s0.
.Sp
.Vb 1
\&   $Collator->getSortKey($a) cmp $Collator->getSortKey($b)
.Ve
.Sp
.Vb 1
\&      is equivalent to
.Ve
.Sp
.Vb 1
\&   $Collator->cmp($a, $b)
.Ve
.ie n .IP """$sortKeyForm = $Collator\->viewSortKey($string)""" 4
.el .IP "\f(CW$sortKeyForm = $Collator\->viewSortKey($string)\fR" 4
.IX Item "$sortKeyForm = $Collator->viewSortKey($string)"
Returns a string formalized to display a sort key.
Weights are enclosed with \f(CW'['\fR and \f(CW']'\fR
and level boundaries are denoted by \f(CW'|'\fR.
.Sp
.Vb 3
\&   use Unicode::Collate;
\&   my $c = Unicode::Collate->new();
\&   print $c->viewSortKey("Perl"),"\en";
.Ve
.Sp
.Vb 3
\&    # output:
\&    # [09B3 08B1 09CB 094F|0020 0020 0020 0020|0008 0002 0002 0002|FFFF FFFF FFFF FFFF]
\&    #  Level 1             Level 2             Level 3             Level 4
.Ve
.ie n .IP """$position = $Collator\->index($string, $substring)""" 4
.el .IP "\f(CW$position = $Collator\->index($string, $substring)\fR" 4
.IX Item "$position = $Collator->index($string, $substring)"
.PD 0
.ie n .IP """($position, $length) = $Collator\->index($string, $substring)""" 4
.el .IP "\f(CW($position, $length) = $Collator\->index($string, $substring)\fR" 4
.IX Item "($position, $length) = $Collator->index($string, $substring)"
.PD
\&\-\- see 6.8 Searching, \s-1UTR\s0 #10.
.Sp
If \f(CW$substring\fR matches a part of \f(CW$string\fR, returns
the position of the first occurrence of the matching part in scalar context;
in list context, returns a two-element list of
the position and the length of the matching part.
.Sp
\&\fBNotice\fR that the length of the matching part may differ from
the length of \f(CW$substring\fR.
.Sp
\&\fBNote\fR that the position and the length are counted on the string
after the process of preprocess, normalization, and rearrangement.
Therefore, in case the specified string is not binary equal to
the preprocessed/normalized/rearranged string, the position and the length
may differ form those on the specified string. But it is guaranteed
that, if matched, it returns a non-negative value as \f(CW$position\fR.
.Sp
If \f(CW$substring\fR does not match any part of \f(CW$string\fR,
returns \f(CW\*(C`\-1\*(C'\fR in scalar context and
an empty list in list context.
.Sp
e.g. you say
.Sp
.Vb 7
\&  my $Collator = Unicode::Collate->new( normalization => undef, level => 1 );
\&  my $str = "Ich mu\ex{00DF} studieren.";
\&  my $sub = "m\ex{00FC}ss";
\&  my $match;
\&  if (my($pos,$len) = $Collator->index($str, $sub)) {
\&      $match = substr($str, $pos, $len);
\&  }
.Ve
.Sp
and get \f(CW"mu\ex{00DF}"\fR in \f(CW$match\fR since \f(CW\*(C`"mu\*(C'\fRß\f(CW\*(C`"\*(C'\fR
is primary equal to \f(CW\*(C`"m\*(C'\fRü\f(CW\*(C`ss"\*(C'\fR. 
.Sh "Other Methods"
.IX Subsection "Other Methods"
.IP "UCA_Version" 4
.IX Item "UCA_Version"
Returns the version number of Unicode Technical Standard 10
this module consults.
.IP "Base_Unicode_Version" 4
.IX Item "Base_Unicode_Version"
Returns the version number of the Unicode Standard
this module is based on.
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.Sh "\s-1TODO\s0"
.IX Subsection "TODO"
Unicode::Collate has not been ported to \s-1EBCDIC\s0.  The code mostly would
work just fine but a decision needs to be made: how the module should
work in \s-1EBCDIC\s0?  Should the low 256 characters be understood as
Unicode or as \s-1EBCDIC\s0 code points?  Should one be chosen or should
there be a way to do either?  Or should such translation be left
outside the module for the user to do, for example by using
\&\fIEncode::from_to()\fR?
(or \fIutf8::unicode_to_native()\fR/\fIutf8::native_to_unicode()\fR?)
.Sh "\s-1CAVEAT\s0"
.IX Subsection "CAVEAT"
Use of the \f(CW\*(C`normalization\*(C'\fR parameter requires
the \fBUnicode::Normalize\fR module.
.PP
If you need not it (say, in the case when you need not
handle any combining characters),
assign \f(CW\*(C`normalization => undef\*(C'\fR explicitly.
.PP
\&\-\- see 6.5 Avoiding Normalization, \s-1UTR\s0 #10.
.Sh "\s-1BUGS\s0"
.IX Subsection "BUGS"
\&\f(CW\*(C`index()\*(C'\fR is an experimental method and
its return value may be unreliable.
The correct implementation for \f(CW\*(C`index()\*(C'\fR must be based
on Locale-Sensitive Support: Level 3 in \s-1UTR\s0 #18,
\&\fIUnicode Regular Expression Guidelines\fR.
.PP
See also 4.2 Locale-Dependent Graphemes in \s-1UTR\s0 #18.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\s-1SADAHIRO\s0 Tomoyuki, <SADAHIRO@cpan.org>
.PP
.Vb 1
\&  http://homepage1.nifty.com/nomenclator/perl/
.Ve
.PP
.Vb 1
\&  Copyright(C) 2001-2002, SADAHIRO Tomoyuki. Japan. All rights reserved.
.Ve
.PP
.Vb 2
\&  This library is free software; you can redistribute it
\&  and/or modify it under the same terms as Perl itself.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "http://www.unicode.org/unicode/reports/tr10/" 4
.IX Item "http://www.unicode.org/unicode/reports/tr10/"
Unicode Collation Algorithm \- \s-1UTR\s0 #10
.IP "http://www.unicode.org/unicode/reports/tr10/allkeys.txt" 4
.IX Item "http://www.unicode.org/unicode/reports/tr10/allkeys.txt"
The Default Unicode Collation Element Table
.IP "http://www.unicode.org/unicode/reports/tr15/" 4
.IX Item "http://www.unicode.org/unicode/reports/tr15/"
Unicode Normalization Forms \- \s-1UAX\s0 #15
.IP "http://www.unicode.org/unicode/reports/tr18" 4
.IX Item "http://www.unicode.org/unicode/reports/tr18"
Unicode Regular Expression Guidelines \- \s-1UTR\s0 #18
.IP "Unicode::Normalize" 4
.IX Item "Unicode::Normalize"
