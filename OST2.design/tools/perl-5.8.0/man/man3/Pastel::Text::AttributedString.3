.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pastel::Text::AttributedString 3"
.TH Pastel::Text::AttributedString 3 "2003-04-29" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
Pastel::Text::AttributedString \- For drawing text with attributes.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  $as = Pastel::Text::AttributedString->new(-text=>"Some text");
.Ve
.PP
.Vb 2
\&  # create a font object
\&  $font = Pastel::Font->new(-family=>"Arial", -style=>"bold", -size=>14);
.Ve
.PP
.Vb 4
\&  # create a hash containing font
\&  $att{FONT} = $font;
\&  $att{X}    = 100;
\&  $att{Y}    = 200;
.Ve
.PP
.Vb 2
\&  $as1 = Pastel:: Text::AttributedString->new(-text=>"Some text",
\&                                              -attributes=> \e%att);
.Ve
.PP
.Vb 1
\&  my $g = Pastel::Graphics->new();
.Ve
.PP
.Vb 2
\&  # draw both the string
\&  $g->draw_string($as, 10, 20);
.Ve
.PP
.Vb 3
\&  # no x and y coordinates. Remember, we created the hash containing
\&  # coordinates
\&  $g->draw_string($as1);
.Ve
.PP
.Vb 2
\&  # set some attributes to $as. 
\&  $as->add_attribute("COLOR", Pastel::Color->red, 0, 3);
.Ve
.PP
.Vb 2
\&  # draw the sting now
\&  $g->draw_string($as, 200, 300);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1SVG\s0 \*(L"tspan\*(R" elements are supported by this module. Unlike
AttributedString class in Java, you do not pass
AttributedCharacterIterator to the graphics context. But pass the
AttributedString class itself.
.PP
The following text attributes are defined and can be used with this module\-
.PP
.Vb 1
\&  FONT          A Pastel::Font object
.Ve
.PP
.Vb 4
\&  FAMILY        A string describing the family name of the font. If the
\&                FONT attibute is already set then this attribute is ignored.
\&                Should not be a composite of more than one attributes. e.g.
\&                "Arial" is a valid attibute value but "Arial-Bold" is not.
.Ve
.PP
.Vb 1
\&  POSTURE       REGULAR or OBLIQUE or ITALIC
.Ve
.PP
.Vb 1
\&  WEIGHT        REGULAR or BOLD. Default REGULAR.
.Ve
.PP
.Vb 1
\&  SIZE          Point size.
.Ve
.PP
.Vb 1
\&  COLOR         Pastel::Color object.
.Ve
.PP
.Vb 1
\&  UNDERLINE     ON
.Ve
.PP
.Vb 1
\&  STRIKETHROUGH ON
.Ve
.PP
.Vb 1
\&  ANCHOR        START or MIDDLE or END
.Ve
.PP
.Vb 1
\&  STROKE_WIDTH  Numeric value denoting stroke-width in pixels
.Ve
.PP
.Vb 1
\&  STROKE_COLOR  Pastel::Color object
.Ve
.PP
.Vb 1
\&  ROTATE        Numeric value indicating the rotation of the glyph
.Ve
.PP
Note that X and Y coordinates are not valid attributes.
.PP
Each AttributedString class contains the \f(CW\*(C`root\*(C'\fR attribute, which is
applied to the whole string. The are three ways to put this root
attributes: (1) pass the attributes as hash in the construtor; (2) use
the \f(CW\*(C`add_attribute()\*(C'\fR method with only the first two arguments; (3)
use \f(CW\*(C`add_attribute()\*(C'\fR method with the first index 0 and the last
index equals to the length of the whole string.
.PP
In addition to the \f(CW\*(C`root\*(C'\fR element the AttributedString contains
several \f(CW"runs"\fR. Each run is represented by a single \f(CW\*(C`<tspan\*(C'\fR> element.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.Sh "Pastel::Text::AttributedString\->new(\-text=>$string)"
.IX Subsection "Pastel::Text::AttributedString->new(-text=>$string)"
Creates and returns an AttributedString object with no attributes defined.
.Sh "Pastel::Text::AttributedString\->new(\-text=>$string, \-attributes=>\e%att);"
.IX Subsection "Pastel::Text::AttributedString->new(-text=>$string, -attributes=>%att);"
Creates and returns an AttributedString object with attributes defined
for the whole string.%att is a hash containing the attributes in key
value pairs.
.SH "METHODS"
.IX Header "METHODS"
.SH "PRIVATE METHODS"
.IX Header "PRIVATE METHODS"
.ie n .Sh "_create_new_run($key, $value\fP, \f(CW$start\fP, \f(CW$end)"
.el .Sh "_create_new_run($key, \f(CW$value\fP, \f(CW$start\fP, \f(CW$end\fP)"
.IX Subsection "_create_new_run($key, $value, $start, $end)"
If there is no run present this method actually creates a new run. Should be called when \f(CW$self\fR\->{runcount} = 0.
.PP
.Vb 2
\& Returns  : Nothing.
\& Arguments: Same as add_attribute()
.Ve
.Sh "\fI_break_run()\fP"
.IX Subsection "_break_run()"
Describe your function here
.PP
.Vb 2
\& Returns  : 
\& Arguments:
.Ve
.Sh "_valid_key($string)"
.IX Subsection "_valid_key($string)"
Validate the string whether it is a legal \f(CW\*(C`key\*(C'\fR or not. The function
loops through the array in \f(CW\*(C`valid_keys\*(C'\fR attribute and returns true,
if it is present or false it it is not.
.PP
.Vb 2
\& Returns  : 1 if $string is a valid key or return C<undef>.
\& Arguments: A string.
.Ve
.Sh "\fI_get_attributes_as_style()\fP"
.IX Subsection "_get_attributes_as_style()"
Describe your function here
.PP
.Vb 2
\& Returns  : 
\& Arguments:
.Ve
.SH "CONTACT"
.IX Header "CONTACT"
Malay <curiouser@ccmb.res.in>
