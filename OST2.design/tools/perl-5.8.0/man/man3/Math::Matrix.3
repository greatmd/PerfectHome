.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Matrix 3"
.TH Matrix 3 "2001-09-24" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
Math::Matrix \- Multiply and invert Matrices
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Math::Matrix;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The following methods are available:
.Sh "new"
.IX Subsection "new"
Constructor arguments are a list of references to arrays of the same
length.  The arrays are copied. The method returns \fBundef\fR in case of
error.
.PP
.Vb 3
\&        $a = new Math::Matrix ([rand,rand,rand],
\&                               [rand,rand,rand],
\&                               [rand,rand,rand]);
.Ve
.PP
If you call  \f(CW\*(C`new\*(C'\fR as method, a zero filled matrix with identical deminsions is returned.
.Sh "clone"
.IX Subsection "clone"
You can clone a matrix by calling:
.PP
.Vb 1
\&        $b = $a->clone;
.Ve
.Sh "size"
.IX Subsection "size"
You can determine the dimensions of a matrix by calling:
.PP
.Vb 1
\&        ($m, $n) = $a->size;
.Ve
.Sh "concat"
.IX Subsection "concat"
Concatenates two matrices of same row count. The result is a new
matrix or \fBundef\fR in case of error.
.PP
.Vb 2
\&        $b = new Math::Matrix ([rand],[rand],[rand]);
\&        $c = $a->concat($b);
.Ve
.Sh "transpose"
.IX Subsection "transpose"
Returns the transposed matrix. This is the matrix where colums and
rows of the argument matrix are swaped.
.Sh "multiply"
.IX Subsection "multiply"
Multiplies two matrices where the length of the rows in the first
matrix is the same as the length of the columns in the second
matrix. Returns the product or \fBundef\fR in case of error.
.Sh "solve"
.IX Subsection "solve"
Solves a equation system given by the matrix. The number of colums
must be greater than the number of rows. If variables are dependent
from each other, the second and all further of the dependent
coefficients are 0. This means the method can handle such systems. The
method returns a matrix containing the solutions in its columns or
\&\fBundef\fR in case of error.
.Sh "multiply_scalar"
.IX Subsection "multiply_scalar"
Multiplies a matrix and a scalar resulting in a matrix of the same
dimensions with each element scaled with the scalar.
.PP
.Vb 1
\&  $a->multiply_scalar(2);  scale matrix by factor 2
.Ve
.Sh "add"
.IX Subsection "add"
Add two matrices of the same dimensions.
.Sh "substract"
.IX Subsection "substract"
Shorthand for \f(CW\*(C`add($other\->negative)\*(C'\fR
.Sh "equal"
.IX Subsection "equal"
Decide if two matrices are equal.  Beware of rounding errors!
.Sh "slice"
.IX Subsection "slice"
Extract columns:
.PP
.Vb 1
\&  a->slice(1,3,5);
.Ve
.Sh "determinant"
.IX Subsection "determinant"
Compute the determinant of a matrix.
.Sh "dot_product"
.IX Subsection "dot_product"
Compute the dot product of two vectors.
.Sh "absolute"
.IX Subsection "absolute"
Compute the absolute value of a vector.
.Sh "normalizing"
.IX Subsection "normalizing"
Normalize a vector.
.Sh "cross_product"
.IX Subsection "cross_product"
Compute the cross-product of vectors.
.Sh "print"
.IX Subsection "print"
Prints the matrix on \s-1STDOUT\s0. If the method has additional parameters,
these are printed before the matrix is printed.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 1
\&        use Math::Matrix;
.Ve
.PP
.Vb 11
\&        srand(time);
\&        $a = new Math::Matrix ([rand,rand,rand], 
\&                         [rand,rand,rand], 
\&                         [rand,rand,rand]);
\&        $x = new Math::Matrix ([rand,rand,rand]);
\&        $a->print("A\en");
\&        $E = $a->concat($x->transpose);
\&        $E->print("Equation system\en");
\&        $s = $E->solve;
\&        $s->print("Solutions s\en");
\&        $a->multiply($s)->print("A*s\en");
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Ulrich Pfeifer <\fIpfeifer@ls6.informatik.uni\-dortmund.de\fR>
.PP
Brian J. Watson <\fIbjbrew@power.net\fR>
.PP
Matthew Brett <matthew.brett@mrc\-cbu.cam.ac.uk>
