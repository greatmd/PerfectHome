.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rijndael 3"
.TH Rijndael 3 "2001-09-17" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
Crypt::Rijndael \- Crypt::CBC compliant Rijndael encryption module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Crypt::Rijndael;
.Ve
.PP
.Vb 2
\& # keysize() is 32, but 24 and 16 are also possible
\& # blocksize() is 16
.Ve
.PP
.Vb 1
\& $cipher = new Crypt::Rijndael "a" x 32, Crypt::Rijndael::MODE_CBC;
.Ve
.PP
.Vb 4
\& $cipher->set_iv($iv);
\& $crypted = $cipher->encrypt($plaintext);
\& # - OR -
\& $plaintext = $cipher->decrypt($crypted);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements the Rijndael cipher, which has just been selected
as the Advanced Encryption Standard.
.IP "keysize" 4
.IX Item "keysize"
Returns the keysize, which is 32 (bytes). The Rijndael cipher
actually supports keylengths of 16, 24 or 32 bytes, but there is no
way to communicate this to \f(CW\*(C`Crypt::CBC\*(C'\fR.
.IP "blocksize" 4
.IX Item "blocksize"
The blocksize for Rijndael is 16 bytes (128 bits), although the
algorithm actually supports any blocksize that is any multiple of
our bytes.  128 bits, is however, the AES-specified block size,
so this is all we support.
.ie n .IP "$cipher = new $key\fR [, \f(CW$mode]" 4
.el .IP "$cipher = new \f(CW$key\fR [, \f(CW$mode\fR]" 4
.IX Item "$cipher = new $key [, $mode]"
Create a new \f(CW\*(C`Crypt::Rijndael\*(C'\fR cipher object with the given key
(which must be 128, 192 or 256 bits long). The additional \f(CW$mode\fR
argument is the encryption mode, either \f(CW\*(C`MODE_ECB\*(C'\fR (electronic
codebook mode, the default), \f(CW\*(C`MODE_CBC\*(C'\fR (cipher block chaining, the
same that \f(CW\*(C`Crypt::CBC\*(C'\fR does), \f(CW\*(C`MODE_CFB\*(C'\fR (128\-bit cipher feedback),
\&\f(CW\*(C`MODE_OFB\*(C'\fR (128\-bit output feedback), or \f(CW\*(C`MODE_CTR\*(C'\fR (counter mode).
.Sp
\&\s-1ECB\s0 mode is very insecure (read a book on cryptography if you dont
know why!), so you should probably use \s-1CBC\s0 mode.
.IP "$cipher\->set_iv($iv)" 4
.IX Item "$cipher->set_iv($iv)"
This allows you to change the initial value vector used by the
chaining modes.  It is not relevant for \s-1ECB\s0 mode.
.IP "$cipher\->encrypt($data)" 4
.IX Item "$cipher->encrypt($data)"
Encrypt data. The size of \f(CW$data\fR must be a multiple of \f(CW\*(C`blocksize\*(C'\fR
(16 bytes), otherwise this function will croak. Apart from that, it
can be of (almost) any length.
.IP "$cipher\->decrypt($data)" 4
.IX Item "$cipher->decrypt($data)"
Decrypts \f(CW$data\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 1
\&  L<Crypt::CBC>, http://www.csrc.nist.gov/encryption/aes/
.Ve
.SH "BUGS"
.IX Header "BUGS"
Should \s-1EXPORT\s0 or \s-1EXPORT_OK\s0 the \s-1MODE\s0 constants.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\& Rafael R. Sevilla <sevillar@team.ph.inter.net>
.Ve
.PP
.Vb 2
\& The Rijndael Algorithm was developed by Vincent Rijmen and Joan Daemen,
\& and has been selected as the US Government's Advanced Encryption Standard.
.Ve
