.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::Format 3"
.TH DBI::Format 3 "2002-10-01" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
DBI::Format \- A package for displaying result tables
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # create a new result object
\&  $r = DBI::Format->new('var1' => 'val1', ...);
.Ve
.PP
.Vb 2
\&  # Prepare it for output by creating a header
\&  $r->header($sth, $fh);
.Ve
.PP
.Vb 4
\&  # In a loop, display rows
\&  while ($ref = $sth->fetchrow_arrayref()) {
\&    $r->row($ref);
\&  }
.Ve
.PP
.Vb 2
\&  # Finally create a trailer
\&  $r->trailer();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1THIS\s0 \s-1PACKAGE\s0 \s-1IS\s0 \s-1STILL\s0 \s-1VERY\s0 \s-1EXPERIMENTAL\s0. \s-1THINGS\s0 \s-1WILL\s0 \s-1CHANGE\s0.
.PP
This package is used for making the output of DBI::Shell configurable.
The idea is to derive a subclass for any kind of output table you might
create. Examples are
.IP "\(bu" 8
a very simple output format as offered by \fIDBI::neat_list()\fR.
\&\*(L"\s-1AVAILABLE\s0 \s-1SUBCLASSES\s0\*(R".
.IP "\(bu" 8
a box format, as offered by the Data::ShowTable module.
.IP "\(bu" 8
\&\s-1HTML\s0 format, as used in \s-1CGI\s0 binaries
.IP "\(bu" 8
postscript, to be piped into lpr or something similar
.PP
In the future the package should also support interactive methods, for
example tab completion.
.PP
These are the available methods:
.IP "new(@attr)" 8
.IX Item "new(@attr)"
.PD 0
.IP "new(\e%attr)" 8
.IX Item "new(%attr)"
.PD
(Class method) This is the constructor. You'd rather call a subclass
constructor. The construcor is accepting either a list of key/value
pairs or a hash ref.
.ie n .IP "header($sth, $fh)" 8
.el .IP "header($sth, \f(CW$fh\fR)" 8
.IX Item "header($sth, $fh)"
(Instance method) This is called when a new result table should be
created to display the results of the statement handle \fB$sth\fR. The
(optional) argument \fB$fh\fR is an \s-1IO\s0 handle (or any object supporting
a \fIprint\fR method), usually you use an IO::Wrap object for \s-1STDIN\s0.
.Sp
The method will query the \fB$sth\fR for its \fI\s-1NAME\s0\fR, \fI\s-1NUM_OF_FIELDS\s0\fR,
\&\fI\s-1TYPE\s0\fR, \fI\s-1SCALE\s0\fR and \fI\s-1PRECISION\s0\fR attributes and typically print a
header. In general you should not assume that \fB$sth\fR is indeed a \s-1DBI\s0
statement handle and better treat it as a hash ref with the above
attributes.
.IP "row($ref)" 8
.IX Item "row($ref)"
(Instance method) Prints the contents of the array ref \fB$ref\fR. Usually
you obtain this array ref by calling \fB$sth\->\f(BIfetchrow_arrayref()\fB\fR.
.IP "trailer" 8
.IX Item "trailer"
(Instance method) Once you have passed all result rows to the result
package, you should call the \fItrailer\fR method. This method can, for
example print the number of result rows.
.SH "AVAILABLE SUBCLASSES"
.IX Header "AVAILABLE SUBCLASSES"
First of all, you can use the DBI::Format package itself: It's
not an abstract base class, but a very simple default using
\&\fIDBI::neat_list()\fR.
.Sh "Ascii boxes"
.IX Subsection "Ascii boxes"
This subclass is using the \fIBox\fR mode of the \fIData::ShowTable\fR module
internally. \fIData::ShowTable\fR\|(3).
.Sh "Raw"
.IX Subsection "Raw"
Row is written without formating.  Columns returned in comma or user defined
separated list.
.Sh "String"
.IX Subsection "String"
Row is written using a string format.  Future releases may include the ability
set the string format, if someone contributes it.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
This module is Copyright (c) 1997, 1998
.PP
.Vb 4
\&    Jochen Wiedmann
\&    Am Eisteich 9
\&    72555 Metzingen
\&    Germany
.Ve
.PP
.Vb 2
\&    Email: joe@ispsoft.de
\&    Phone: +49 7123 14887
.Ve
.PP
The DBD::Proxy module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIDBI::Shell\fR\|(3), \s-1\fIDBI\s0\fR\|(3), \fIdbish\fR\|(1)
