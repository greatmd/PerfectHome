.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Perl::Tidy 3"
.TH Perl::Tidy 3 "2003-10-21" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
Perl::Tidy \- Parses and beautifies perl source
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Perl::Tidy;
.Ve
.PP
.Vb 10
\&    Perl::Tidy::perltidy(
\&        source      => $source,
\&        destination => $destination,
\&        stderr      => $stderr,
\&        argv        => $argv,
\&        perltidyrc  => $perltidyrc,
\&        logfile     => $logfile,
\&        errorfile   => $errorfile,
\&        formatter   => $formatter,  # callback object (see below)
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module makes the functionality of the perltidy utility available to perl
scripts.  Any or all of the input parameters may be omitted, in which case the
\&\f(CW@ARGV\fR array will be used to provide input parameters as described
in the \fIperltidy\fR\|(1) man page.
.PP
For example, the perltidy script is basically just this:
.PP
.Vb 2
\&    use Perl::Tidy;
\&    Perl::Tidy::perltidy();
.Ve
.PP
The module accepts input and output streams by a variety of methods.
The following list of parameters may be any of a the following: a
filename, an \s-1ARRAY\s0 reference, a \s-1SCALAR\s0 reference, or an object with
either a \fBgetline\fR or \fBprint\fR method, as appropriate.
.PP
.Vb 6
\&        source          - the source of the script to be formatted
\&        destination     - the destination of the formatted output
\&        stderr          - standard error output
\&        perltidyrc      - the .perltidyrc file
\&        logfile         - the .LOG file stream, if any 
\&        errorfile       - the .ERR file stream, if any
.Ve
.PP
The following chart illustrates the logic used to decide how to
treat a parameter.
.PP
.Vb 6
\&   ref($param)  $param is assumed to be:
\&   -----------  ---------------------
\&   undef        a filename
\&   SCALAR       ref to string
\&   ARRAY        ref to array
\&   (other)      object with getline (if source) or print method
.Ve
.PP
If the parameter is an object, and the object has a \fBclose\fR method, that
close method will be called at the end of the stream.
.IP "source" 4
.IX Item "source"
If the \fBsource\fR parameter is given, it defines the source of the
input stream.
.IP "destination" 4
.IX Item "destination"
If the \fBdestination\fR parameter is given, it will be used to define the
file or memory location to receive output of perltidy.  
.IP "stderr" 4
.IX Item "stderr"
The \fBstderr\fR parameter allows the calling program to capture the output
to what would otherwise go to the standard error output device.
.IP "perltidyrc" 4
.IX Item "perltidyrc"
If the \fBperltidyrc\fR file is given, it will be used instead of any
\&\fI.perltidyrc\fR configuration file that would otherwise be used. 
.IP "argv" 4
.IX Item "argv"
If the \fBargv\fR parameter is given, it will be used instead of the
\&\fB@ARGV\fR array.  The \fBargv\fR parameter may be a string, a reference to a
string, or a reference to an array.  If it is a string or reference to a
string, it will be parsed into an array of items just as if it were a
command line string.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
The following example passes perltidy a snippet as a reference
to a string and receives the result back in a reference to
an array.  
.PP
.Vb 1
\& use Perl::Tidy;
.Ve
.PP
.Vb 12
\& # some messy source code to format
\& my $source = <<'EOM';
\& use strict;
\& my @editors=('Emacs', 'Vi   '); my $rand = rand();
\& print "A poll of 10 random programmers gave these results:\en";
\& foreach(0..10) {
\& my $i=int ($rand+rand());
\& print " $editors[$i] users are from Venus" . ", " . 
\& "$editors[1-$i] users are from Mars" . 
\& "\en";
\& }
\& EOM
.Ve
.PP
.Vb 4
\& # We'll pass it as ref to SCALAR and receive it in a ref to ARRAY
\& my @dest;
\& perltidy( source => \e$source, destination => \e@dest );
\& foreach (@dest) {print}
.Ve
.SH "Using the \fBformatter\fP Callback Object"
.IX Header "Using the formatter Callback Object"
The \fBformatter\fR parameter is an optional callback object which allows
the calling program to receive tokenized lines directly from perltidy for
further specialized processing.  When this parameter is used, the two
formatting options which are built into perltidy (beautification or
html) are ignored.  The following diagram illustrates the logical flow:
.PP
.Vb 3
\&                    |-- (normal route)   -> code beautification
\&  caller->perltidy->|-- (-html flag )    -> create html 
\&                    |-- (formatter given)-> callback to write_line
.Ve
.PP
This can be useful for processing perl scripts in some way.  The 
parameter \f(CW$formatter\fR in the perltidy call,
.PP
.Vb 1
\&        formatter   => $formatter,
.Ve
.PP
is an object created by the caller with a \f(CW\*(C`write_line\*(C'\fR method which
will accept and process tokenized lines, one line per call.  Here is
a simple example of a \f(CW\*(C`write_line\*(C'\fR which merely prints the line number,
the line type (as determined by perltidy), and the text of the line:
.PP
.Vb 1
\& sub write_line {
.Ve
.PP
.Vb 8
\&     # This is called from perltidy line-by-line
\&     my $self              = shift;
\&     my $line_of_tokens    = shift;
\&     my $line_type         = $line_of_tokens->{_line_type};
\&     my $input_line_number = $line_of_tokens->{_line_number};
\&     my $input_line        = $line_of_tokens->{_line_text};
\&     print "$input_line_number:$line_type:$input_line";
\& }
.Ve
.PP
The complete program, \fBperllinetype\fR, is contained in the examples section of
the source distribution.  As this example shows, the callback method
receives a parameter \fB$line_of_tokens\fR, which is a reference to a hash
of other useful information.  This example uses these hash entries:
.PP
.Vb 3
\& $line_of_tokens->{_line_number} - the line number (1,2,...)
\& $line_of_tokens->{_line_text}   - the text of the line
\& $line_of_tokens->{_line_type}   - the type of the line, one of:
.Ve
.PP
.Vb 14
\&    SYSTEM         - system-specific code before hash-bang line
\&    CODE           - line of perl code (including comments)
\&    POD_START      - line starting pod, such as '=head'
\&    POD            - pod documentation text
\&    POD_END        - last line of pod section, '=cut'
\&    HERE           - text of here-document
\&    HERE_END       - last line of here-doc (target word)
\&    FORMAT         - format section
\&    FORMAT_END     - last line of format section, '.'
\&    DATA_START     - __DATA__ line
\&    DATA           - unidentified text following __DATA__
\&    END_START      - __END__ line
\&    END            - unidentified text following __END__
\&    ERROR          - we are in big trouble, probably not a perl script
.Ve
.PP
Most applications will be only interested in lines of type \fB\s-1CODE\s0\fR.  For
another example, let's write a program which checks for one of the
so-called \fInaughty matching variables\fR \f(CW\*(C`&`\*(C'\fR, \f(CW$&\fR, and \f(CW$'\fR, which
can slow down processing.  Here is a \fBwrite_line\fR, from the example
program \fBfind_naughty.pl\fR, which does that:
.PP
.Vb 1
\& sub write_line {
.Ve
.PP
.Vb 3
\&     # This is called back from perltidy line-by-line
\&     # We're looking for $`, $&, and $'
\&     my ( $self, $line_of_tokens ) = @_;
.Ve
.PP
.Vb 7
\&     # pull out some stuff we might need
\&     my $line_type         = $line_of_tokens->{_line_type};
\&     my $input_line_number = $line_of_tokens->{_line_number};
\&     my $input_line        = $line_of_tokens->{_line_text};
\&     my $rtoken_type       = $line_of_tokens->{_rtoken_type};
\&     my $rtokens           = $line_of_tokens->{_rtokens};
\&     chomp $input_line;
.Ve
.PP
.Vb 2
\&     # skip comments, pod, etc
\&     return if ( $line_type ne 'CODE' );
.Ve
.PP
.Vb 2
\&     # loop over tokens looking for $`, $&, and $'
\&     for ( my $j = 0 ; $j < @$rtoken_type ; $j++ ) {
.Ve
.PP
.Vb 2
\&         # we only want to examine token types 'i' (identifier)
\&         next unless $$rtoken_type[$j] eq 'i';
.Ve
.PP
.Vb 2
\&         # pull out the actual token text
\&         my $token = $$rtokens[$j];
.Ve
.PP
.Vb 7
\&         # and check it
\&         if ( $token =~ /^\e$[\e`\e&\e']$/ ) {
\&             print STDERR
\&               "$input_line_number: $token\en";
\&         }
\&     }
\& }
.Ve
.PP
This example pulls out these tokenization variables from the \f(CW$line_of_tokens\fR
hash reference:
.PP
.Vb 2
\&     $rtoken_type = $line_of_tokens->{_rtoken_type};
\&     $rtokens     = $line_of_tokens->{_rtokens};
.Ve
.PP
The variable \f(CW$rtoken_type\fR is a reference to an array of token type codes,
and \f(CW$rtokens\fR is a reference to a corresponding array of token text.
These are obviously only defined for lines of type \fB\s-1CODE\s0\fR.
Perltidy classifies tokens into types, and has a brief code for each type.
You can get a complete list at any time by running perltidy from the
command line with
.PP
.Vb 1
\&     perltidy --dump-token-types
.Ve
.PP
In the present example, we are only looking for tokens of type \fBi\fR
(identifiers), so the for loop skips past all other types.  When an
identifier is found, its actual text is checked to see if it is one
being sought.  If so, the above write_line prints the token and its
line number.
.PP
The \fBformatter\fR feature is relatively new in perltidy, and further
documentation needs to be written to complete its description.  However,
several example programs have been written and can be found in the
\&\fBexamples\fR section of the source distribution.  Probably the best way
to get started is to find one of the examples which most closely matches
your application and start modifying it.
.PP
For help with perltidy's pecular way of breaking lines into tokens, you
might run, from the command line, 
.PP
.Vb 1
\& perltidy -D filename
.Ve
.PP
where \fIfilename\fR is a short script of interest.  This will produce
\&\fIfilename.DEBUG\fR with interleaved lines of text and their token types.
The \-D flag has been in perltidy from the beginning for this purpose.
If you want to see the code which creates this file, it is
\&\f(CW\*(C`write_debug_entry\*(C'\fR in Tidy.pm.
.SH "EXPORT"
.IX Header "EXPORT"
.Vb 1
\&  &perltidy
.Ve
.SH "CREDITS"
.IX Header "CREDITS"
Thanks to Hugh Myers who developed the initial modular interface 
to perltidy.
.SH "VERSION"
.IX Header "VERSION"
This man page documents Perl::Tidy version 20031021.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Steve Hancock
\& perltidy at users.sourceforge.net
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The \fIperltidy\fR\|(1) man page describes all of the features of perltidy.  It
can be found at http://perltidy.sourceforge.net.
