.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CodeGen::Gui 3"
.TH CodeGen::Gui 3 "2003-05-09" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
\&\fBVerilog::Codegen::Gui\fR \- Verilog code generator GUI
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  $ ./gui.pl [design name]
.Ve
.PP
The \s-1GUI\s0 and its utility scrips are in the \f(CW\*(C`scripts\*(C'\fR folder of the distribution. 
.PP
The design name is optional. If no design name is provided, the \s-1GUI\s0 will check the .vcgrc file for one. If this file does not exists, the design library module defaults to DeviceLibs/Verilog.pm and the objects will reside directly under DeviceLibs/Objects. Otherwise, the design library module will be DeviceLibs/YourDesign.pm  and the objects will reside under DeviceLibs/YourDesign/Objects. You can also set the design name via the \s-1GUI\s0.
.SH "USAGE"
.IX Header "USAGE"
The \s-1GUI\s0 is very simple to use. A short manual:
.PP
To create, test and run Verilog code using the Verilog::CodeGen \s-1GUI:\s0
.Sh "0. Choose your design."
.IX Subsection "0. Choose your design."
In the \fBDesign\fR text entry field, type the full name of the design. Click \fBSet\fR. 
.PP
If the design does not exist, it will be created, that is, an empty structure with skeleton files will be created. Otherwise, the design will be set to the entered value.
.Sh "1. Create or edit the Device Object."
.IX Subsection "1. Create or edit the Device Object."
This is the Perl script that will generate the Verilog code. 
.IP "\(bu" 4
If this is a new file:
.Sp
In the \fBDevice Object Code\fR area text entry field, type the full name of the script, \fIincluding\fR the \f(CW\*(C`.pl\*(C'\fR extension. Click \fBEdit\fR (hitting return does not work). The \s-1GUI\s0 will create a skeleton from a template, and open it in XEmacs. 
.IP "\(bu" 4
If the file already exists: 
.Sp
\&\-If this was the last file to be modified previously, just click \fBEdit\fR. The \s-1GUI\s0 will open the file in XEmacs.
.Sp
\&\-If not, type the beginning of the file in  the \fBDevice Object Code\fR text entry field, then click \fBEdit\fR. The \s-1GUI\s0 will open the first file matching the pattern in XEmacs.
.Sh "2. Test the object code"
.IX Subsection "2. Test the object code"
In the \fBDevice Object Code\fR area, click \fBParse\fR. This executes the script and displays the output in the \fBOutput log\fR window. Ticking the \fBShow result\fR tick box will cause the output to be displayed in an XEmacs window. To close this window, click \fBDone\fR. This is a modal window, in other words it will freeze the main display as long as it stays open.
.Sh "3. Add the Device Object to the Device Library"
.IX Subsection "3. Add the Device Object to the Device Library"
When the object code is bug finished, click \fBUpdate\fR in the \fBDevice Library Module\fR area. This will add the device object to the device library (which is a Perl module). Ticking the \fBShow module\fR tick box will cause the complete library module to be displayed in an XEmacs window. To close this window, click \fBDone\fR. This is a modal window, in other words it will freeze the main display as long as it stays open.
.Sh "4. Create or edit the test bench code"
.IX Subsection "4. Create or edit the test bench code"
This is the Perl script that will generate the Verilog testbench code.
.IP "\(bu" 4
If this is a new file:
.Sp
In the \fBTestbench Code\fR area text entry field, type the full name of the script, \fIincluding\fR the \f(CW\*(C`.pl\*(C'\fR extension, click \fBEdit\fR. The \s-1GUI\s0 will create a skeleton from a template, and open it in XEmacs. 
.IP "\(bu" 4
If the file already exists: 
.Sp
\&\-If this was the last file to be modified previously, just click \fBEdit\fR. The \s-1GUI\s0 will open the file in XEmacs.
.Sp
\&\-If not, type the beginning of the file in  the \fBDevice Object Code\fR text entry field.  The testbench \fImust\fR have the name \f(CW\*(C`test_\*(C'\fR\fI[device obect file name]\fR. Then click \fBEdit\fR. The \s-1GUI\s0 will open the first file matching the pattern in XEmacs.
.Sp
\&\-If the \fBOverwrite\fR tick box is ticked, the existing script will be overwritten with the skeleton. This is usefull in case of major changes to the device object code.
.Sh "5. Test the testbench code"
.IX Subsection "5. Test the testbench code"
In the \fBTestbench Code\fR area, click \fBParse\fR. This executes the script and displays the output in the \fBOutput log\fR window. 
.PP
\&\-Ticking the \fBShow result\fR tick box will cause the output to be displayed in an XEmacs window. To close this window, click \fBDone\fR. This is a modal window, in other words it will freeze the main display as long as it stays open. 
.PP
\&\-Ticking the \fBInspect code\fR tick box will open a browser window with pages generated by the \fBv2html\fR Verilog to \s-1HTML\s0 convertor.
.PP
\&\-Ticking the \fBRun\fR tick box will execute the generated testbench.
.PP
\&\-Ticking the \fBPlot\fR tick box will plot the simulation results (if any exist).
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
.IP "\(bu" 4
\&\fBPerl-Tk\fR (<http://search.cpan.org/CPAN/authors/id/N/NI/NI\-S/Tk\-800.024.tar.gz>)
.Sp
Otherwise, no \s-1GUI\s0
.IP "\(bu" 4
\&\fBXEmacs\fR (<http://xemacs.org>)
.Sp
With \fBgnuserv\fR enabled, i.e. put the line (gnuserv\-start) in your .emacs. Without XEmacs, the \s-1GUI\s0 is rather useless.
.Sp
For a better user experience, customize gnuserv to open files in the active frame. By default, gnuserv will open a new frame for every new file, and you end up with lots of frames.
.Sp
.Vb 4
\&          o Choose Options->Customize->Group
\&          o type gnuserv
\&          o Open the "Gnuserv Frame" section (by clicking on the arrow)
\&          o Tick "Use selected frame"
.Ve
.Sp
I also use the \fBauto-revert-mode\fR <ftp://ftp.csd.uu.se/pub/users/andersl/emacs/autorevert.el> because parsing the test bench code modifies it, and I got annoyed by XEmacs prompting me for confirmation. See the file for details on how to install.
.Sp
The \fBVerilog-mode\fR (<http://www.verilog.com/>)is (obviously) very usefull too.
.IP "\(bu" 4
\&\fBv2html\fR (<http://www.burbleland.com/v2html/v2html.html>)
.Sp
If you want to inspect the generated code, you need the v2html Verilog to \s-1HTML\s0 convertor and a controllable browser, I use galeon (<http://galeon.sourceforge.net>).
.IP "\(bu" 4
\&\fBA Verilog compiler/simulator\fR
.Sp
To run the testbench, I use Icarus Verilog <http://icarus.com/eda/verilog/index.html>, a great open source Verilog simulator.
.IP "\(bu" 4
\&\fBA \s-1VCD\s0 waveform viewer\fR
.Sp
To plot the results, I use GTkWave (<http://www.cs.man.ac.uk/apt/tools/gtkwave/index.html>, a great open source waveform viewer.
.Sh "To use a different Verilog compiler/simulator and/or \s-1VCD\s0 viewer:"
.IX Subsection "To use a different Verilog compiler/simulator and/or VCD viewer:"
In CodeGen.pm, change the following lines:
.PP
.Vb 4
\&   #Modify this to use different compiler/simulator/viewer
\&   my $compiler="/usr/bin/iverilog";
\&   my $simulator="/usr/bin/vvp";
\&   my $vcdviewer="/usr/local/bin/gtkwave";
.Ve
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Convert the utility scripts to functions to be called from Verilog::CodeGen.
.IP "\(bu" 4
Put the \s-1GUI\s0 scripts in a module Gui.pm.
.SH "AUTHOR"
.IX Header "AUTHOR"
W. Vanderbauwhede \fBwim@motherearth.org\fR.
.PP
<http://www.comms.eee.strath.ac.uk/~wim>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002,2003 Wim Vanderbauwhede. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
