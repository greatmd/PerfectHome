.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::BigFloat 3"
.TH Math::BigFloat 3 "2002-06-01" "perl v5.8.0" "Perl Programmers Reference Guide"
.SH "NAME"
Math::BigFloat \- Arbitrary size floating point math package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Math::BigFloat;
.Ve
.PP
.Vb 8
\&  # Number creation
\&  $x = Math::BigFloat->new($str);       # defaults to 0
\&  $nan  = Math::BigFloat->bnan();       # create a NotANumber
\&  $zero = Math::BigFloat->bzero();      # create a +0
\&  $inf = Math::BigFloat->binf();        # create a +inf
\&  $inf = Math::BigFloat->binf('-');     # create a -inf
\&  $one = Math::BigFloat->bone();        # create a +1
\&  $one = Math::BigFloat->bone('-');     # create a -1
.Ve
.PP
.Vb 10
\&  # Testing
\&  $x->is_zero();                # true if arg is +0
\&  $x->is_nan();                 # true if arg is NaN
\&  $x->is_one();                 # true if arg is +1
\&  $x->is_one('-');              # true if arg is -1
\&  $x->is_odd();                 # true if odd, false for even
\&  $x->is_even();                # true if even, false for odd
\&  $x->is_positive();            # true if >= 0
\&  $x->is_negative();            # true if <  0
\&  $x->is_inf(sign);             # true if +inf, or -inf (default is '+')
.Ve
.PP
.Vb 5
\&  $x->bcmp($y);                 # compare numbers (undef,<0,=0,>0)
\&  $x->bacmp($y);                # compare absolutely (undef,<0,=0,>0)
\&  $x->sign();                   # return the sign, either +,- or NaN
\&  $x->digit($n);                # return the nth digit, counting from right
\&  $x->digit(-$n);               # return the nth digit, counting from left
.Ve
.PP
.Vb 1
\&  # The following all modify their first argument:
.Ve
.PP
.Vb 7
\&  # set 
\&  $x->bzero();                  # set $i to 0
\&  $x->bnan();                   # set $i to NaN
\&  $x->bone();                   # set $x to +1
\&  $x->bone('-');                # set $x to -1
\&  $x->binf();                   # set $x to inf
\&  $x->binf('-');                # set $x to -inf
.Ve
.PP
.Vb 6
\&  $x->bneg();                   # negation
\&  $x->babs();                   # absolute value
\&  $x->bnorm();                  # normalize (no-op)
\&  $x->bnot();                   # two's complement (bit wise not)
\&  $x->binc();                   # increment x by 1
\&  $x->bdec();                   # decrement x by 1
.Ve
.PP
.Vb 5
\&  $x->badd($y);                 # addition (add $y to $x)
\&  $x->bsub($y);                 # subtraction (subtract $y from $x)
\&  $x->bmul($y);                 # multiplication (multiply $x by $y)
\&  $x->bdiv($y);                 # divide, set $i to quotient
\&                                # return (quo,rem) or quo if scalar
.Ve
.PP
.Vb 5
\&  $x->bmod($y);                 # modulus
\&  $x->bpow($y);                 # power of arguments (a**b)
\&  $x->blsft($y);                # left shift
\&  $x->brsft($y);                # right shift 
\&                                # return (quo,rem) or quo if scalar
.Ve
.PP
.Vb 2
\&  $x->blog($base);              # logarithm of $x, base defaults to e
\&                                # (other bases than e not supported yet)
.Ve
.PP
.Vb 4
\&  $x->band($y);                 # bit-wise and
\&  $x->bior($y);                 # bit-wise inclusive or
\&  $x->bxor($y);                 # bit-wise exclusive or
\&  $x->bnot();                   # bit-wise not (two's complement)
.Ve
.PP
.Vb 2
\&  $x->bsqrt();                  # calculate square-root
\&  $x->bfac();                   # factorial of $x (1*2*3*4*..$x)
.Ve
.PP
.Vb 2
\&  $x->bround($N);               # accuracy: preserver $N digits
\&  $x->bfround($N);              # precision: round to the $Nth digit
.Ve
.PP
.Vb 3
\&  # The following do not modify their arguments:
\&  bgcd(@values);                # greatest common divisor
\&  blcm(@values);                # lowest common multiplicator
.Ve
.PP
.Vb 2
\&  $x->bstr();                   # return string
\&  $x->bsstr();                  # return string in scientific notation
.Ve
.PP
.Vb 2
\&  $x->bfloor();                 # return integer less or equal than $x
\&  $x->bceil();                  # return integer greater or equal than $x
.Ve
.PP
.Vb 3
\&  $x->exponent();               # return exponent as BigInt
\&  $x->mantissa();               # return mantissa as BigInt
\&  $x->parts();                  # return (mantissa,exponent) as BigInt
.Ve
.PP
.Vb 2
\&  $x->length();                 # number of digits (w/o sign and '.')
\&  ($l,$f) = $x->length();       # number of digits, and length of fraction
.Ve
.PP
.Vb 4
\&  $x->precision();              # return P of $x (or global, if P of $x undef)
\&  $x->precision($n);            # set P of $x to $n
\&  $x->accuracy();               # return A of $x (or global, if A of $x undef)
\&  $x->accuracy($n);             # set A $x to $n
.Ve
.PP
.Vb 2
\&  Math::BigFloat->precision();  # get/set global P for all BigFloat objects
\&  Math::BigFloat->accuracy();   # get/set global A for all BigFloat objects
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (inlcuding basic math operations) are overloaded if you
declare your big floating point numbers as
.PP
.Vb 1
\&  $i = new Math::BigFloat '12_3.456_789_123_456_789E-2';
.Ve
.PP
Operations with overloaded operators preserve the arguments, which is
exactly what you expect.
.Sh "Canonical notation"
.IX Subsection "Canonical notation"
Input to these routines are either BigFloat objects, or strings of the
following four forms:
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+\e.\ed*$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+E[+\-]?\ed+$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed*\e.\ed+E[+\-]?\ed+$/\*(C'\fR
.PP
all with optional leading and trailing zeros and/or spaces. Additonally,
numbers are allowed to have an underscore between any two digits.
.PP
Empty strings as well as other illegal numbers results in 'NaN'.
.PP
\&\fIbnorm()\fR on a BigFloat object is now effectively a no\-op, since the numbers 
are always stored in normalized form. On a string, it creates a BigFloat 
object.
.Sh "Output"
.IX Subsection "Output"
Output values are BigFloat objects (normalized), except for \fIbstr()\fR and \fIbsstr()\fR.
.PP
The string output will always have leading and trailing zeros stripped and drop
a plus sign. \f(CW\*(C`bstr()\*(C'\fR will give you always the form with a decimal point,
while \f(CW\*(C`bsstr()\*(C'\fR (for scientific) gives you the scientific notation.
.PP
.Vb 6
\&        Input                   bstr()          bsstr()
\&        '-0'                    '0'             '0E1'
\&        '  -123 123 123'        '-123123123'    '-123123123E0'
\&        '00.0123'               '0.0123'        '123E-4'
\&        '123.45E-2'             '1.2345'        '12345E-4'
\&        '10E+3'                 '10000'         '1E4'
.Ve
.PP
Some routines (\f(CW\*(C`is_odd()\*(C'\fR, \f(CW\*(C`is_even()\*(C'\fR, \f(CW\*(C`is_zero()\*(C'\fR, \f(CW\*(C`is_one()\*(C'\fR,
\&\f(CW\*(C`is_nan()\*(C'\fR) return true or false, while others (\f(CW\*(C`bcmp()\*(C'\fR, \f(CW\*(C`bacmp()\*(C'\fR)
return either undef, <0, 0 or >0 and are suited for sort.
.PP
Actual math is done by using BigInts to represent the mantissa and exponent.
The sign \f(CW\*(C`/^[+\-]$/\*(C'\fR is stored separately. The string 'NaN' is used to 
represent the result when input arguments are not numbers, as well as 
the result of dividing by zero.
.ie n .Sh """mantissa()""\fP, \f(CW""exponent()""\fP and \f(CW""parts()"""
.el .Sh "\f(CWmantissa()\fP, \f(CWexponent()\fP and \f(CWparts()\fP"
.IX Subsection "mantissa(), exponent() and parts()"
\&\f(CW\*(C`mantissa()\*(C'\fR and \f(CW\*(C`exponent()\*(C'\fR return the said parts of the BigFloat 
as BigInts such that:
.PP
.Vb 4
\&        $m = $x->mantissa();
\&        $e = $x->exponent();
\&        $y = $m * ( 10 ** $e );
\&        print "ok\en" if $x == $y;
.Ve
.PP
\&\f(CW\*(C`($m,$e) = $x\->parts();\*(C'\fR is just a shortcut giving you both of them.
.PP
A zero is represented and returned as \f(CW0E1\fR, \fBnot\fR \f(CW0E0\fR (after Knuth).
.PP
Currently the mantissa is reduced as much as possible, favouring higher
exponents over lower ones (e.g. returning 1e7 instead of 10e6 or 10000000e0).
This might change in the future, so do not depend on it.
.Sh "Accuracy vs. Precision"
.IX Subsection "Accuracy vs. Precision"
See also: Rounding.
.PP
Math::BigFloat supports both precision and accuracy. For a full documentation,
examples and tips on these topics please see the large section in
Math::BigInt.
.PP
Since things like \fIsqrt\fR\|(2) or 1/3 must presented with a limited precision lest
a operation consumes all resources, each operation produces no more than
\&\f(CW\*(C`Math::BigFloat::precision()\*(C'\fR digits.
.PP
In case the result of one operation has more precision than specified,
it is rounded. The rounding mode taken is either the default mode, or the one
supplied to the operation after the \fIscale\fR:
.PP
.Vb 7
\&        $x = Math::BigFloat->new(2);
\&        Math::BigFloat::precision(5);           # 5 digits max
\&        $y = $x->copy()->bdiv(3);               # will give 0.66666
\&        $y = $x->copy()->bdiv(3,6);             # will give 0.666666
\&        $y = $x->copy()->bdiv(3,6,'odd');       # will give 0.666667
\&        Math::BigFloat::round_mode('zero');
\&        $y = $x->copy()->bdiv(3,6);             # will give 0.666666
.Ve
.Sh "Rounding"
.IX Subsection "Rounding"
.IP "ffround ( +$scale )" 2
.IX Item "ffround ( +$scale )"
Rounds to the \f(CW$scale\fR'th place left from the '.', counting from the dot.
The first digit is numbered 1. 
.IP "ffround ( \-$scale )" 2
.IX Item "ffround ( -$scale )"
Rounds to the \f(CW$scale\fR'th place right from the '.', counting from the dot.
.IP "ffround ( 0 )" 2
.IX Item "ffround ( 0 )"
Rounds to an integer.
.IP "fround  ( +$scale )" 2
.IX Item "fround  ( +$scale )"
Preserves accuracy to \f(CW$scale\fR digits from the left (aka significant digits)
and pads the rest with zeros. If the number is between 1 and \-1, the
significant digits count from the first non-zero after the '.'
.IP "fround  ( \-$scale ) and fround ( 0 )" 2
.IX Item "fround  ( -$scale ) and fround ( 0 )"
These are effetively no\-ops.
.PP
All rounding functions take as a second parameter a rounding mode from one of
the following: 'even', 'odd', '+inf', '\-inf', 'zero' or 'trunc'.
.PP
The default rounding mode is 'even'. By using
\&\f(CW\*(C`Math::BigFloat::round_mode($round_mode);\*(C'\fR you can get and set the default
mode for subsequent rounding. The usage of \f(CW\*(C`$Math::BigFloat::$round_mode\*(C'\fR is
no longer supported.
The second parameter to the round functions then overrides the default
temporarily. 
.PP
The \f(CW\*(C`as_number()\*(C'\fR function returns a BigInt from a Math::BigFloat. It uses
\&'trunc' as rounding mode to make it equivalent to:
.PP
.Vb 2
\&        $x = 2.5;
\&        $y = int($x) + 2;
.Ve
.PP
You can override this by passing the desired rounding mode as parameter to
\&\f(CW\*(C`as_number()\*(C'\fR:
.PP
.Vb 2
\&        $x = Math::BigFloat->new(2.5);
\&        $y = $x->as_number('odd');      # $y = 3
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&  # not ready yet
.Ve
.SH "Autocreating constants"
.IX Header "Autocreating constants"
After \f(CW\*(C`use Math::BigFloat ':constant'\*(C'\fR all the floating point constants
in the given scope are converted to \f(CW\*(C`Math::BigFloat\*(C'\fR. This conversion
happens at compile time.
.PP
In particular
.PP
.Vb 1
\&  perl -MMath::BigFloat=:constant -e 'print 2E-100,"\en"'
.Ve
.PP
prints the value of \f(CW\*(C`2E\-100\*(C'\fR. Note that without conversion of 
constants the expression 2E\-100 will be calculated as normal floating point 
number.
.PP
Please note that ':constant' does not affect integer constants, nor binary 
nor hexadecimal constants. Use bignum or Math::BigInt to get this to
work.
.Sh "Math library"
.IX Subsection "Math library"
Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:
.PP
.Vb 1
\&        use Math::BigFloat lib => 'Calc';
.Ve
.PP
You can change this by using:
.PP
.Vb 1
\&        use Math::BigFloat lib => 'BitVect';
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use Math::BigFloat lib => 'Foo,Math::BigInt::Bar';
.Ve
.PP
Calc.pm uses as internal format an array of elements of some decimal base
(usually 1e7, but this might be differen for some systems) with the least
significant digit first, while BitVect.pm uses a bit vector of base 2, most
significant bit first. Other modules might use even different means of
representing the numbers. See the respective module documentation for further
details.
.PP
Please note that Math::BigFloat does \fBnot\fR use the denoted library itself,
but it merely passes the lib argument to Math::BigInt. So, instead of the need
to do:
.PP
.Vb 2
\&        use Math::BigInt lib => 'GMP';
\&        use Math::BigFloat;
.Ve
.PP
you can roll it all into one line:
.PP
.Vb 1
\&        use Math::BigFloat lib => 'GMP';
.Ve
.PP
Use the lib, Luke! And see \*(L"Using Math::BigInt::Lite\*(R" for more details.
.Sh "Using Math::BigInt::Lite"
.IX Subsection "Using Math::BigInt::Lite"
It is possible to use Math::BigInt::Lite with Math::BigFloat:
.PP
.Vb 2
\&        # 1
\&        use Math::BigFloat with => 'Math::BigInt::Lite';
.Ve
.PP
There is no need to \*(L"use Math::BigInt\*(R" or \*(L"use Math::BigInt::Lite\*(R", but you
can combine these if you want. For instance, you may want to use
Math::BigInt objects in your main script, too.
.PP
.Vb 3
\&        # 2
\&        use Math::BigInt;
\&        use Math::BigFloat with => 'Math::BigInt::Lite';
.Ve
.PP
Of course, you can combine this with the \f(CW\*(C`lib\*(C'\fR parameter.
.PP
.Vb 2
\&        # 3
\&        use Math::BigFloat with => 'Math::BigInt::Lite', lib => 'GMP,Pari';
.Ve
.PP
If you want to use Math::BigInt's, too, simple add a Math::BigInt \fBbefore\fR:
.PP
.Vb 3
\&        # 4
\&        use Math::BigInt;
\&        use Math::BigFloat with => 'Math::BigInt::Lite', lib => 'GMP,Pari';
.Ve
.PP
Notice that the module with the last \f(CW\*(C`lib\*(C'\fR will \*(L"win\*(R" and thus
it's lib will be used if the lib is available:
.PP
.Vb 3
\&        # 5
\&        use Math::BigInt lib => 'Bar,Baz';
\&        use Math::BigFloat with => 'Math::BigInt::Lite', lib => 'Foo';
.Ve
.PP
That would try to load Foo, Bar, Baz and Calc (in that order). Or in other
words, Math::BigFloat will try to retain previously loaded libs when you
don't specify it one.
.PP
Actually, the lib loading order would be \*(L"Bar,Baz,Calc\*(R", and then
\&\*(L"Foo,Bar,Baz,Calc\*(R", but independend of which lib exists, the result is the
same as trying the latter load alone, except for the fact that Bar or Baz
might be loaded needlessly in an intermidiate step
.PP
The old way still works though:
.PP
.Vb 3
\&        # 6
\&        use Math::BigInt lib => 'Bar,Baz';
\&        use Math::BigFloat;
.Ve
.PP
But \fBexamples #3 and #4 are recommended\fR for usage.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 2
The following does not work yet:
.Sp
.Vb 4
\&        $m = $x->mantissa();
\&        $e = $x->exponent();
\&        $y = $m * ( 10 ** $e );
\&        print "ok\en" if $x == $y;
.Ve
.IP "\(bu" 2
There is no \fIfmod()\fR function yet.
.SH "CAVEAT"
.IX Header "CAVEAT"
.IP "stringify, \fIbstr()\fR" 1
.IX Item "stringify, bstr()"
Both stringify and \fIbstr()\fR now drop the leading '+'. The old code would return
\&'+1.23', the new returns '1.23'. See the documentation in Math::BigInt for
reasoning and details.
.IP "bdiv" 1
.IX Item "bdiv"
The following will probably not do what you expect:
.Sp
.Vb 1
\&        print $c->bdiv(123.456),"\en";
.Ve
.Sp
It prints both quotient and reminder since print works in list context. Also,
\&\fIbdiv()\fR will modify \f(CW$c\fR, so be carefull. You probably want to use
.Sp
.Vb 2
\&        print $c / 123.456,"\en";
\&        print scalar $c->bdiv(123.456),"\en";  # or if you want to modify $c
.Ve
.Sp
instead.
.IP "Modifying and =" 1
.IX Item "Modifying and ="
Beware of:
.Sp
.Vb 2
\&        $x = Math::BigFloat->new(5);
\&        $y = $x;
.Ve
.Sp
It will not do what you think, e.g. making a copy of \f(CW$x\fR. Instead it just makes
a second reference to the \fBsame\fR object and stores it in \f(CW$y\fR. Thus anything
that modifies \f(CW$x\fR will modify \f(CW$y\fR, and vice versa.
.Sp
.Vb 2
\&        $x->bmul(2);
\&        print "$x, $y\en";       # prints '10, 10'
.Ve
.Sp
If you want a true copy of \f(CW$x\fR, use:
.Sp
.Vb 1
\&        $y = $x->copy();
.Ve
.Sp
See also the documentation in overload regarding \f(CW\*(C`=\*(C'\fR.
.IP "bpow" 1
.IX Item "bpow"
\&\f(CW\*(C`bpow()\*(C'\fR now modifies the first argument, unlike the old code which left
it alone and only returned the result. This is to be consistent with
\&\f(CW\*(C`badd()\*(C'\fR etc. The first will modify \f(CW$x\fR, the second one won't:
.Sp
.Vb 3
\&        print bpow($x,$i),"\en";         # modify $x
\&        print $x->bpow($i),"\en";        # ditto
\&        print $x ** $i,"\en";            # leave $x alone
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Mark Biggar, overloaded interface by Ilya Zakharevich.
Completely rewritten by Tels http://bloodgate.com in 2001.
