.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Parse 3"
.TH Date::Parse 3 "2002-06-06" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
Date::Parse \- Parse date strings into time values
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Date::Parse;
.Ve
.PP
.Vb 1
\&        $time = str2time($date);
.Ve
.PP
.Vb 1
\&        ($ss,$mm,$hh,$day,$month,$year,$zone) = strptime($date);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Date::Parse\*(C'\fR provides two routines for parsing date strings into time values.
.IP "str2time(\s-1DATE\s0 [, \s-1ZONE\s0])" 4
.IX Item "str2time(DATE [, ZONE])"
\&\f(CW\*(C`str2time\*(C'\fR parses \f(CW\*(C`DATE\*(C'\fR and returns a unix time value, or undef upon failure.
\&\f(CW\*(C`ZONE\*(C'\fR, if given, specifies the timezone to assume when parsing if the
date string does not specify a timezome.
.IP "strptime(\s-1DATE\s0 [, \s-1ZONE\s0])" 4
.IX Item "strptime(DATE [, ZONE])"
\&\f(CW\*(C`strptime\*(C'\fR takes the same arguments as str2time but returns an array of
values \f(CW\*(C`($ss,$mm,$hh,$day,$month,$year,$zone)\*(C'\fR. Elements are only defined
if they could be extracted from the date string. The \f(CW$zone\fR element is
the timezone offset in seconds from \s-1GMT\s0. An empty array is returned upon
failure.
.SH "MULTI-LANGUAGE SUPPORT"
.IX Header "MULTI-LANGUAGE SUPPORT"
Date::Parse is capable of parsing dates in several languages, these are
English, French, German and Italian. Changing the language is done via
a static method call, for example
.Sp
.Vb 1
\&        Date::Parse->language('German');
.Ve
.Sp
will cause Date::Parse to attempt to parse any subsequent dates in German.
.Sp
This is only a first pass, I am considering changing this to be
.Sp
.Vb 2
\&        $lang = Date::Language->new('German');
\&        $lang->str2time("25 Jun 1996 21:09:55 +0100");
.Ve
.Sp
I am open to suggestions on this.
.SH "EXAMPLE DATES"
.IX Header "EXAMPLE DATES"
Below is a sample list of dates that are known to be parsable with Date::Parse
.Sp
.Vb 11
\& 1995:01:24T09:08:17.1823213           ISO-8601
\& 1995-01-24T09:08:17.1823213
\& Wed, 16 Jun 94 07:29:35 CST           Comma and day name are optional 
\& Thu, 13 Oct 94 10:13:13 -0700
\& Wed, 9 Nov 1994 09:50:32 -0500 (EST)  Text in ()'s will be ignored.
\& 21 dec 17:05                          Will be parsed in the current time zone
\& 21-dec 17:05
\& 21/dec 17:05
\& 21/dec/93 17:05
\& 1999 10:02:18 "GMT"
\& 16 Nov 94 22:28:20 PST
.Ve
.SH "BUGS"
.IX Header "BUGS"
When both the month and the date are specified in the date as numbers
they are always parsed assuming that the month number comes before the
date. This is the usual format used in American dates.
.Sp
The reason why it is like this and not dynamic is that it must be
deterministic. Several people have suggested using the current locale,
but this will not work as the date being parsed may not be in the format
of the current locale.
.Sp
My plans to address this, which will be in a future release, is to allow
the programmer to state what order they want these values parsed in.
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@pobox.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1995 Graham Barr. All rights reserved. This program is free
software; you can redistribute it and/or modify it under the same terms
as Perl itself.
