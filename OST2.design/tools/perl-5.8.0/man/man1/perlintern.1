.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLINTERN 1"
.TH PERLINTERN 1 "2002-06-08" "perl v5.8.0" "Perl Programmers Reference Guide"
.SH "NAME"
perlintern \- autogenerated documentation of purely \fBinternal\fR
		 Perl functions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This file is the autogenerated documentation of functions in the
Perl interpreter that are documented using Perl's internal documentation
format but are not marked as part of the Perl \s-1API\s0. In other words,
\&\fBthey are not for use in extensions\fR!
.SH "Global Variables"
.IX Header "Global Variables"
.IP "PL_DBsingle" 8
.IX Item "PL_DBsingle"
When Perl is run in debugging mode, with the \fB\-d\fR switch, this \s-1SV\s0 is a
boolean which indicates whether subs are being single\-stepped.
Single-stepping is automatically turned on after every step.  This is the C
variable which corresponds to Perl's \f(CW$DB::single\fR variable.  See
\&\f(CW\*(C`PL_DBsub\*(C'\fR.
.Sp
.Vb 1
\&        SV *    PL_DBsingle
.Ve
.IP "PL_DBsub" 8
.IX Item "PL_DBsub"
When Perl is run in debugging mode, with the \fB\-d\fR switch, this \s-1GV\s0 contains
the \s-1SV\s0 which holds the name of the sub being debugged.  This is the C
variable which corresponds to Perl's \f(CW$DB::sub\fR variable.  See
\&\f(CW\*(C`PL_DBsingle\*(C'\fR.
.Sp
.Vb 1
\&        GV *    PL_DBsub
.Ve
.IP "PL_DBtrace" 8
.IX Item "PL_DBtrace"
Trace variable used when Perl is run in debugging mode, with the \fB\-d\fR
switch.  This is the C variable which corresponds to Perl's \f(CW$DB::trace\fR
variable.  See \f(CW\*(C`PL_DBsingle\*(C'\fR.
.Sp
.Vb 1
\&        SV *    PL_DBtrace
.Ve
.IP "PL_dowarn" 8
.IX Item "PL_dowarn"
The C variable which corresponds to Perl's $^W warning variable.
.Sp
.Vb 1
\&        bool    PL_dowarn
.Ve
.IP "PL_last_in_gv" 8
.IX Item "PL_last_in_gv"
The \s-1GV\s0 which was last used for a filehandle input operation. (\f(CW\*(C`<FH>\*(C'\fR)
.Sp
.Vb 1
\&        GV*     PL_last_in_gv
.Ve
.IP "PL_ofs_sv" 8
.IX Item "PL_ofs_sv"
The output field separator \- \f(CW$,\fR in Perl space.
.Sp
.Vb 1
\&        SV*     PL_ofs_sv
.Ve
.IP "PL_rs" 8
.IX Item "PL_rs"
The input record separator \- \f(CW$/\fR in Perl space.
.Sp
.Vb 1
\&        SV*     PL_rs
.Ve
.SH "GV Functions"
.IX Header "GV Functions"
.IP "is_gv_magical" 8
.IX Item "is_gv_magical"
Returns \f(CW\*(C`TRUE\*(C'\fR if given the name of a magical \s-1GV\s0.
.Sp
Currently only useful internally when determining if a \s-1GV\s0 should be
created even in rvalue contexts.
.Sp
\&\f(CW\*(C`flags\*(C'\fR is not used at present but available for future extension to
allow selecting particular classes of magical variable.
.Sp
.Vb 1
\&        bool    is_gv_magical(char *name, STRLEN len, U32 flags)
.Ve
.SH "IO Functions"
.IX Header "IO Functions"
.IP "start_glob" 8
.IX Item "start_glob"
Function called by \f(CW\*(C`do_readline\*(C'\fR to spawn a glob (or do the glob inside
perl on \s-1VMS\s0). This code used to be inline, but now perl uses \f(CW\*(C`File::Glob\*(C'\fR
this glob starter is only used by miniperl during the build process.
Moving it away shrinks pp_hot.c; shrinking pp_hot.c helps speed perl up.
.Sp
.Vb 1
\&        PerlIO* start_glob(SV* pattern, IO *io)
.Ve
.SH "Pad Data Structures"
.IX Header "Pad Data Structures"
.IP "CvPADLIST" 8
.IX Item "CvPADLIST"
\&\s-1CV\s0's can have CvPADLIST(cv) set to point to an \s-1AV\s0.
.Sp
For these purposes \*(L"forms\*(R" are a kind-of \s-1CV\s0, eval"\*(L"s are too (except they're
not callable at will and are always thrown away after the eval\*(R"" is done
executing).
.Sp
XSUBs don't have CvPADLIST set \- dXSTARG fetches values from PL_curpad,
but that is really the callers pad (a slot of which is allocated by
every entersub).
.Sp
The CvPADLIST \s-1AV\s0 has does not have AvREAL set, so \s-1REFCNT\s0 of component items
is managed \*(L"manual\*(R" (mostly in op.c) rather than normal av.c rules.
The items in the \s-1AV\s0 are not SVs as for a normal \s-1AV\s0, but other AVs:
.Sp
0'th Entry of the CvPADLIST is an \s-1AV\s0 which represents the \*(L"names\*(R" or rather
the \*(L"static type information\*(R" for lexicals.
.Sp
The CvDEPTH'th entry of CvPADLIST \s-1AV\s0 is an \s-1AV\s0 which is the stack frame at that
depth of recursion into the \s-1CV\s0.
The 0'th slot of a frame \s-1AV\s0 is an \s-1AV\s0 which is \f(CW@_\fR.
other entries are storage for variables and op targets.
.Sp
During compilation:
\&\f(CW\*(C`PL_comppad_name\*(C'\fR is set the the the names \s-1AV\s0.
\&\f(CW\*(C`PL_comppad\*(C'\fR is set the the frame \s-1AV\s0 for the frame CvDEPTH == 1.
\&\f(CW\*(C`PL_curpad\*(C'\fR is set the body of the frame \s-1AV\s0 (i.e. AvARRAY(PL_comppad)).
.Sp
Itterating over the names \s-1AV\s0 itterates over all possible pad
items. Pad slots that are SVs_PADTMP (targets/GVs/constants) end up having
&PL_sv_undef \*(L"names\*(R" (see \fIpad_alloc()\fR).
.Sp
Only my/our variable (SVs_PADMY/SVs_PADOUR) slots get valid names.
The rest are op targets/GVs/constants which are statically allocated
or resolved at compile time.  These don't have names by which they
can be looked up from Perl code at run time through eval"\*(L" like
my/our variables can be.  Since they can't be looked up by \*(R"name"
but only by their index allocated at compile time (which is usually
in PL_op\->op_targ), wasting a name \s-1SV\s0 for them doesn't make sense.
.Sp
The SVs in the names \s-1AV\s0 have their \s-1PV\s0 being the name of the variable.
\&\s-1NV+1\s0..IV inclusive is a range of cop_seq numbers for which the name is valid.
For typed lexicals name \s-1SV\s0 is SVt_PVMG and SvSTASH points at the type.
.Sp
If SvFAKE is set on the name \s-1SV\s0 then slot in the frame AVs are
a \s-1REFCNT\s0'ed references to a lexical from \*(L"outside\*(R".
.Sp
If the 'name' is '&' the the corresponding entry in frame \s-1AV\s0
is a \s-1CV\s0 representing a possible closure.
(SvFAKE and name of '&' is not a meaningful combination currently but could
become so if \f(CW\*(C`my sub foo {}\*(C'\fR is implemented.)
.Sp
.Vb 1
\&        AV *    CvPADLIST(CV *cv)
.Ve
.SH "Stack Manipulation Macros"
.IX Header "Stack Manipulation Macros"
.IP "djSP" 8
.IX Item "djSP"
Declare Just \f(CW\*(C`SP\*(C'\fR. This is actually identical to \f(CW\*(C`dSP\*(C'\fR, and declares
a local copy of perl's stack pointer, available via the \f(CW\*(C`SP\*(C'\fR macro.
See \f(CW\*(C`SP\*(C'\fR.  (Available for backward source code compatibility with the
old (Perl 5.005) thread model.)
.Sp
.Vb 1
\&                djSP;
.Ve
.IP "\s-1LVRET\s0" 8
.IX Item "LVRET"
True if this op will be the return value of an lvalue subroutine
.SH "SV Manipulation Functions"
.IX Header "SV Manipulation Functions"
.IP "report_uninit" 8
.IX Item "report_uninit"
Print appropriate \*(L"Use of uninitialized variable\*(R" warning
.Sp
.Vb 1
\&        void    report_uninit()
.Ve
.IP "sv_add_arena" 8
.IX Item "sv_add_arena"
Given a chunk of memory, link it to the head of the list of arenas,
and split it into a list of free SVs.
.Sp
.Vb 1
\&        void    sv_add_arena(char* ptr, U32 size, U32 flags)
.Ve
.IP "sv_clean_all" 8
.IX Item "sv_clean_all"
Decrement the refcnt of each remaining \s-1SV\s0, possibly triggering a
cleanup. This function may have to be called multiple times to free
SVs which are in complex self-referential hierarchies.
.Sp
.Vb 1
\&        I32     sv_clean_all()
.Ve
.IP "sv_clean_objs" 8
.IX Item "sv_clean_objs"
Attempt to destroy all objects not yet freed
.Sp
.Vb 1
\&        void    sv_clean_objs()
.Ve
.IP "sv_free_arenas" 8
.IX Item "sv_free_arenas"
Deallocate the memory used by all arenas. Note that all the individual \s-1SV\s0
heads and bodies within the arenas must already have been freed.
.Sp
.Vb 1
\&        void    sv_free_arenas()
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
The autodocumentation system was originally added to the Perl core by
Benjamin Stuhl. Documentation is by whoever was kind enough to
document their functions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperlguts\fR\|(1), \fIperlapi\fR\|(1)
