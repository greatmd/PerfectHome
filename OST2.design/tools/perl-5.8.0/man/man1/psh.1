.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PSH 1"
.TH PSH 1 "2003-01-02" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
psh \- Perl SHell
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The Perl Shell documentation has been split into a number of different
manpages:
.PP
psh         This overview
.PP
pshdevel    Developing for the Perl Shell
.PP
pshconfig   Configuring the Perl Shell
.PP
pshcomplete \s-1TAB\s0 completions in the Perl Shell
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBpsh\fR is a Perl program which executes a read-eval loop with enough
options so that general behavior reasonably similar to more
traditional shells like '\fBsh\fR' or '\fBbash\fR' can be achieved, while still
allowing arbitrary perl expressions to be evaluated.
.PP
By default within \fBpsh\fR, the Perl \fB\-w\fR flag and '\f(CW\*(C`use strict\*(C'\fR' are not
employed so that the user is not bound by their stipulations. 
They can both be turned on via a command-line flag; or setting
\&\f(CW\*(C`$^W = 1\*(C'\fR will turn on warnings, and calling '\f(CW\*(C`use strict\*(C'\fR' will
(almost) do the usual thing if called by the user (see \s-1LIMITATIONS\s0, below).
.PP
Each line of input is read. \fBpsh\fR knows a number of possible
strategies for evaluating the line, such as "send it to \f(CW\*(C`system()\*(C'\fR if it
starts with the name of an executable visible in \f(CW$ENV{PATH}\fR". (See
below for a complete list.)
Each strategy in turn (from a user-definable
list) examines the command line to see if it can apply, and the first
matching strategy evaluates the line. There is a \fBpsh\fR configuration
variable (see below) which controls whether the perl value of the
evaluation is saved and printed after each command.
.PP
\&\fBpsh\fR automatically collects several lines of input into a unit
processed as a single line if there are unfinished Perl constructs on
the line. In particular, if there is an unmatched quote, paren, brace,
or square bracket, input is read until these characters match. If an
input line contains the Perl \*(L"here document\*(R" construct as in
\&\f(CW\*(C`<<XXX\*(C'\fR, (anywhere on the line), then input is read and
accumulated until \f(CW\*(C`XXX\*(C'\fR occurs on a line by itself. Then the
accumulated input is processed as if it were a single line.
.SH "OPTIONS"
.IX Header "OPTIONS"
The command-line arguments to \fBpsh\fR are:
.PP
.Vb 1
\& psh [-d [options]] [-w] [-F] [-f RC_FILE] [-c STRING ] [FILE1 FILE2 ....]
.Ve
.PP
They are processed in the following order, regardless of what order
they are specified in:
.IP "\(bu \fB\-w\fR" 4
.IX Item "-w"
Enables Perl's warning mode. The \fB\-w\fR switch runs perl with the
\&\fB\-w\fR switch and \*(L"use strict;\*(R".
.IP "\(bu \fB\-d\fR [debug options]" 4
.IX Item "-d [debug options]"
The \fB\-d\fR option puts \fBpsh\fR into \*(L"debugging\*(R" mode, which prints
diagnostic output. Note that you can also enter/leave this
debugging mode in a running \fBpsh\fR via the \f(CW$Psh::debugging\fR variable.
.IP "\(bu \fB\-i\fR" 4
.IX Item "-i"
Only for compatibility reasons and ignored by Perl Shell.
.IP "\(bu \fB\-f\fR \fIfile\fR" 4
.IX Item "-f file"
The \fB\-f\fR option specifies a file of commands to be read in and
evaluated before processing begins. If it is not set, and
\&\f(CW$ENV{HOME}\fR is set, and the file \fI$ENV{\s-1HOME\s0}/.pshrc\fR is present, it
will be used. If \fB\-r\fR is not specified and the current directory is
different from \f(CW$ENV{HOME}\fR and it contains a \fI.pshrc\fR file, that
file will be read and executed in addition to
\&\fI$ENV{\s-1HOME\s0}/.pshrc\fR. 
.IP "\(bu \fB\-F\fR" 4
.IX Item "-F"
No pshrc files will be read and executed.
.IP "\(bu \fB\-c\fR \fIstring\fR" 4
.IX Item "-c string"
If the \fB\-c\fR flag is present, then commands are read from
\&\f(CW\*(C`string\*(C'\fR, and then \fBpsh\fR exits. In particular, any \s-1FILE1\s0
\&... arguments will be ignored.
.PP
If any \s-1FILE1\s0 ... arguments are specified on the command line, they
will be read and executed and then \fBpsh\fR will exit. Otherwise, \fBpsh\fR
will enter an interactive command loop.
.Sh "\s-1TOKENIZATION\s0"
.IX Subsection "TOKENIZATION"
Some evaluation strategies examine the \*(L"words\*(R" of the input. These are
produced by a tokenizer which behaves very similarly to traditional
shells: words are broken at whitespace, '&' is a metacharacter which
means that it always forms its own word, and backslash and double and
single quotes act as quoting characters, preventing word breaks at
whitespace and the \*(L"meta\-ness\*(R" of &.
.PP
If the description of the strategy does not mention the \*(L"words\*(R", then
the tokenization is irrelevant to that strategy.
.Sh "\s-1STANDARD\s0 \s-1EVALUATION\s0 \s-1STRATEGIES\s0"
.IX Subsection "STANDARD EVALUATION STRATEGIES"
\&\fBpsh\fR includes the following evaluation strategies, sorted by the
default order. For adding/removing evaluation
strategies we suggest the usage of the built-in command \*(L"strategy\*(R"
from within psh.
.ie n .IP "\(bu ""comment""" 4
.el .IP "\(bu \f(CWcomment\fR" 4
.IX Item "comment"
If the first word of the input line begins with a '#' character, ignore
the line.
.ie n .IP "\(bu ""bang""" 4
.el .IP "\(bu \f(CWbang\fR" 4
.IX Item "bang"
If the first word of the input line begins with a '!' character, send
everything after the '!' to \fIsystem()\fR.
.ie n .IP "\(bu ""perl""" 4
.el .IP "\(bu \f(CWperl\fR" 4
.IX Item "perl"
If the line begins with 'p!', send the everything after the '!' to the
perl interpreter unchanged.
.ie n .IP "\(bu ""brace""" 4
.el .IP "\(bu \f(CWbrace\fR" 4
.IX Item "brace"
If the first word of the input line begins with a '{' character,
evaluate the entire line as a Perl expression (including the brace).
.ie n .IP "\(bu ""built_in""" 4
.el .IP "\(bu \f(CWbuilt_in\fR" 4
.IX Item "built_in"
If the first word of the input line matches a \fBpsh\fR \*(L"built\-in\*(R"
function, call the subroutine associated with that built\-in; the
subroutine receives a single argument, which is the remainder of the
input line exactly as entered.
.ie n .IP "\(bu ""perlfunc""" 4
.el .IP "\(bu \f(CWperlfunc\fR" 4
.IX Item "perlfunc"
If the first word of the input line matches the name of a defined
Perl subroutine \- or \- if \f(CW$Psh::Strategy::Perlfunc::builtins\fR is set a built-in
Perl function (as determined by the \f(CW%Psh::Strategy::Perlfunc::perl_builtins\fR hash),
pass the line to eval. If \f(CW$Psh::Strategy::Perlfunc::expand_arguments\fR is
true and the line
contains no parens, or braces or commas (except for {a,b,c} as in
shell brace\-expansion), then this strategy tries to
interpret the arguments on the command line in a \*(L"shell\-like\*(R" manner:
strings are literal except for variable expansion, brace expansion,
and glob expansion. 
.Sp
The idea of this strategy is to allow perl functions, especially
subroutines in main, to be called like \*(L"ordinary commands\*(R" (i.e.,
executables on disk). Or put another way, the idea is to replace
bash's \*(L"shell function\*(R" capacity with ordinary Perl subroutines. The
slogan is, \*(L"If the command line looks like an ordinary shell command,
interpret it like one, even if the first word is a Perl subroutine.\*(R"
.ie n .IP "\(bu ""auto_resume"" (not enabled by default)" 4
.el .IP "\(bu \f(CWauto_resume\fR (not enabled by default)" 4
.IX Item "auto_resume (not enabled by default)"
If the input line matches the name of a stopped job then brings that
job to the foreground instead of starting a new programm with that
name.
.ie n .IP "\(bu ""auto_cd"" (not enabled by default)" 4
.el .IP "\(bu \f(CWauto_cd\fR (not enabled by default)" 4
.IX Item "auto_cd (not enabled by default)"
If the input line matches the name of a directory in the current
directory, then change to that directory.
.ie n .IP "\(bu ""perlscript"" (not enabled by default)" 4
.el .IP "\(bu \f(CWperlscript\fR (not enabled by default)" 4
.IX Item "perlscript (not enabled by default)"
If (1) the first word of the input line matches the name of a file found in
one of the directories listed in the path (\f(CW$ENV{PATH}\fR), and (2) that file
starts with \f(CW\*(C`#!/.../perl\*(C'\fR, and (3) that \f(CW\*(C`perl\*(C'\fR is the
same as the Perl under which \fBpsh\fR is running, \fBpsh\fR will fork and run
the script using the already-loaded Perl interpreter. The idea is to
save the exec half of the fork-exec that the executable strategy would 
do; typically the exec is more expensive. Right now this strategy can
only handle the \fB\-w\fR command-line switch on the \f(CW\*(C`#!\*(C'\fR line. Note this 
strategy only makes sense before the \*(L"executable\*(R" strategy; if it came 
after, it could never trigger.
.ie n .IP "\(bu ""executable""" 4
.el .IP "\(bu \f(CWexecutable\fR" 4
.IX Item "executable"
If the first word of the input line matches the name of an executable
file in the path given by \f(CW$ENV{PATH}\fR, then pass the line to
system. Perl variable substitution will be done on the line first if
the \f(CW$Psh::executable_expand_arguments\fR configuration variable is
true and the binary which is executed does not match one of the
regular expresions in \f(CW@Psh::executable_noexpand\fR
.ie n .IP "\(bu ""fallback_builtin""" 4
.el .IP "\(bu \f(CWfallback_builtin\fR" 4
.IX Item "fallback_builtin"
If the first word of the input line is a \*(L"fallback builtin\*(R" provided
for operating systems that do not have common binaries \*(-- such as
\&\*(L"ls\*(R", \*(L"env\*(R", etc, then call the associated subroutine like an ordinary 
builtin. If you want all of these commands to be executed within the
shell, you can move this strategy ahead of executable.
.ie n .IP "\(bu ""eval""" 4
.el .IP "\(bu \f(CWeval\fR" 4
.IX Item "eval"
Pass the line to eval, regardless of any condition. This is a catch-all
strategy; strategies placed after it will never be triggered.
.Sh "\s-1GLOBBING\s0"
.IX Subsection "GLOBBING"
Globbing is used to expand filenames against patterns. Perl Shell
understands the sh '*' and '?' globbing characters (where * matches
any string and ? matches exactly one character).
.PP
In addition, Perl Shell knows the very powerful '**' globbing,
replacing many \f(CW\*(C`find\*(C'\fRs in your daily work. '**' will be replaced
by 'current directories and all sub directories'. For example:
.PP
.Vb 1
\&    grep foo lib/**/*.pm
.Ve
.PP
will search for foo in all *.pm files which are somewhere
(recursivly) within the lib directory.
.Sh "\s-1REDIRECTS\s0"
.IX Subsection "REDIRECTS"
The standard output may be redirected to a file with
.PP
.Vb 1
\&    command > file
.Ve
.PP
and the standard input may be taken from a file with
.PP
.Vb 1
\&    command < file
.Ve
.PP
File descriptors other than 0 and 1 may be specified in an rc-like
syntax.
.PP
To redirect standard error to a file use:
.PP
.Vb 1
\&    command >[2] file
.Ve
.PP
(this is 'command 2> file' in sh\-derivatives! sh-syntax is not
supported)
.PP
To redirect both, standard output and standard error use:
.PP
.Vb 1
\&   command >[all] file
.Ve
.PP
It's also possible to redirect to opened Perl filehandles. If you e.g.
opened a handle \*(L"\s-1FOO\s0\*(R" for writing you may use:
.PP
.Vb 1
\&   command >[=FOO]
.Ve
.PP
to write to that filehandle.
.Sh "\s-1PIPELINES\s0"
.IX Subsection "PIPELINES"
Pipelines are used to construct processing chains.
.PP
.Vb 1
\&    cat a.txt b.txt | wc -l
.Ve
.PP
This is the same as in other shells \- standard output of the first
command will be standard input of the second command.
.PP
To redirect different file descriptors, use e.g.
.PP
.Vb 1
\&    command |[5] command2
.Ve
.PP
to redirect file descriptor 5 to standard input of command.
.PP
It is also possible to redirect to a different filedescriptor than
standard input for the right-hand command:
.PP
.Vb 1
\&    command |[1=5] command2
.Ve
.PP
will redirect standard output from the first command to a newly opened
stream on file descriptor 5 for command. Thus, 'command | command' is
only a short hand version of 'command |[1=0] command'.
.PP
An alias is provided for piping standard error and standard output at
the same time:
.PP
.Vb 1
\&    command |[all] command2
.Ve
.PP
will pipe both to command2 and is so an easier to remember version of
.PP
.Vb 1
\&    command >[2=1] | command2
.Ve
.Sh "\s-1MANIFEST\s0 \s-1FILTERS\s0"
.IX Subsection "MANIFEST FILTERS"
A manifest filter is a chunk of code that causes the creation of a
filter process. They are handy for creating simple one-time filters
because they don't require creating a program file, setting permissions
and so on.
.PP
There are three kinds of manifest filters: quick, grep and substitution.
.PP
A quick filter consists of a block of code surrounded by curly braces,
with a trailing '\f(CW\*(C`q\*(C'\fR' modifier. The Perl Shell turns this into a line-by-line
filter. For the code in the braces, \f(CW$_\fR will contain the line as it was
read from input (including any end-of-line character). The filter block
should
.PP
.Vb 1
\&     ls | { print ++$i, ": $_"; }q
.Ve
.PP
A grep filter consists of a block of code surrounded by curly braces,
with a trailing '\f(CW\*(C`g\*(C'\fR' modifier. The Perl Shell turns this into a line-by-line
filter. Only those lines for which the code in the braces returns a true
value will be printed. For the code in the braces, \f(CW@_\fR will contain the
results of splitting \f(CW$_\fR with the pattern \f(CW\*(C`\es+\*(C'\fR.
.PP
.Vb 1
\&     netstat | { $_[1]>2; }g
.Ve
.PP
A substitution filter consists of a perl-style s/// operator instance.
The Perl Shell will turn this into a line-by-line filter that performs the
substitution on each line, and then prints the line. For example:
.PP
.Vb 1
\&    ls | s/a/b/
.Ve
.PP
A substitution filter is logically equivalent to a block filter containing
the substitution and a statement to print the resulting line. The example
above is equivalent to:
.PP
.Vb 1
\&    ls | { s/a/b/; print; }q
.Ve
.Sh "BUILT-IN \s-1FUNCTIONS\s0"
.IX Subsection "BUILT-IN FUNCTIONS"
A list of built in functions is available from within \f(CW\*(C`psh\*(C'\fR using
the \*(L"help\*(R" command.
.PP
For details about the implementation of built\-ins, please see the
\&\fBpshdevel\fR manpage.
.Sh "\s-1PSH\s0 \s-1FUNCTIONS\s0"
.IX Subsection "PSH FUNCTIONS"
.ie n .IP "&Psh::evl" 4
.el .IP "\f(CW&Psh::evl\fR" 4
.IX Item "&Psh::evl"
This function takes a string, evaluates it as if it were a line of
\&\fBpsh\fR input, and returns the value. Useful in loops like:
.Sp
.Vb 1
\& C<psh$ for $file (glob $pat) { Psh::evl("ls -ld $file"); }>
.Ve
.ie n .IP "&Psh::is_number" 4
.el .IP "\f(CW&Psh::is_number\fR" 4
.IX Item "&Psh::is_number"
Returns true if its first argument is a number. Intended for use in
filter subroutines placed in \f(CW$Psh::echo\fR. For example,
\&\f(CW\*(C`$Psh::echo = \e&Psh::is_number;\*(C'\fR will cause only numeric return
values to be printed.
.ie n .IP """&Psh::Util::print_debug, print_error, print_out, print_warning""" 4
.el .IP "\f(CW&Psh::Util::print_debug, print_error, print_out, print_warning\fR" 4
.IX Item "&Psh::Util::print_debug, print_error, print_out, print_warning"
These four functions are called whenever \fBpsh\fR wants to produce \fB\-d\fR\-mode 
output, error messages, normal output, and warnings,
respectively. They could conceivably be redefined to implement logging 
or similar facilities.
.PP
There are other functions in the Psh:: package, but they are probably
not useful except internally to \fBpsh\fR.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
Due to limitations of the Win32 type of operating system there's no
job control available on those systems.
.PP
The loop inside \fBpsh\fR will clobber \fI$1\fR and other Perl-builtin variables 
because it uses matches to implement some of its special
functions.
.PP
Right now, job control simply assumes that the \s-1POSIX\s0 interface is
fully implemented. There should be a way to turn job control off if
this is not the case.
.PP
The \*(L"exit status\*(R" of programs invoked in the foreground by the
\&\*(L"executable\*(R" strategy (or even the \*(L"bang\*(R" strategy) isn't available
from within \fBpsh\fR.
.PP
Note that since expressions like 'use foo' return undef when sent to
\&\fIeval()\fR, it is not possible to use that return value as indication of
an error. Instead, we use the heuristic that there was no error unless
the special Perl variable '$@' is non\-empty. Note that the side
effects of 'use foo' as a \fBpsh\fR command line appear to be exactly as
expected. 
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
psh needs several optional Perl modules to offer full functionality:
.IP "Term::ReadLine::Gnu or Term::ReadLine::Perl for readline support (command history, special editing chars etc.)." 4
.IX Item "Term::ReadLine::Gnu or Term::ReadLine::Perl for readline support (command history, special editing chars etc.)."
.PD 0
.IP "Term::Size or Term::ReadKey to offer the ability to change the environment variables \s-1LINES\s0 and \s-1COLUMNS\s0 when the terminal window size changes while running as standard shell" 4
.IX Item "Term::Size or Term::ReadKey to offer the ability to change the environment variables LINES and COLUMNS when the terminal window size changes while running as standard shell"
.IP "BSD::Resource is necessary for the ulimit builtin" 4
.IX Item "BSD::Resource is necessary for the ulimit builtin"
.PD
.SH "OTHER PERL SHELLS"
.IX Header "OTHER PERL SHELLS"
.Sh "Larry Walls' Perl Shell"
.IX Subsection "Larry Walls' Perl Shell"
Larry Wall exhibits the simple Perl shell \f(CW\*(C`while (<>) { eval; print $@; }\*(C'\fR on
page 161 of the Camel Book (2nd Edition).
.Sh "lpsh"
.IX Subsection "lpsh"
Lee Eakin <\fIleakin@dfw.nostrum.com\fR> has written the Fancy Poor Man's Perl SHell
(called lpsh for Lee's Perl Shell), a simple Perl shell that he has used for a number of
years now (it is derived from Larry Wall's Perl Shell).  He has added some numeric
conversion functions because he often uses it as a calculator.
.PP
He has placed it on the web at \f(CW\*(C`http://www.dfw.nostrum.com/~leakin/psh\*(C'\fR (for the
code) and \f(CW\*(C`http://www.dfw.nostrum.com/~leakin/psh.README\*(C'\fR for a short explanation
of the code and a reference to the main Perl Shell site.
.Sh "Perl Debugger Shell"
.IX Subsection "Perl Debugger Shell"
Rich Graves <\fIrcgraves@brandeis.edu\fR> posted a comment to the original
psh\-0.001 announcement on \f(CW\*(C`http://freshmeat.net\*(C'\fR, which contained this
gem that leverages the Perl debugger: \f(CW\*(C`perl \-d \-e 1\*(C'\fR;
.Sh "perlsh"
.IX Subsection "perlsh"
Hiroo Hayashi <\fIhiroo.hayashi@computer.org\fR> includes \fBperlsh\fR, a 
``one\-line perl evaluator with line editing function and variable name
completion function'' as an example with his Term::ReadLine::Gnu Perl module.
.Sh "\s-1PSH\s0.pm"
.IX Subsection "PSH.pm"
In an example of convergent evolution, at \f(CW\*(C`http://jenda.krynicky.cz/\*(C'\fR
there is a Perl shell module called \fI\s-1PSH\s0.pm\fR which is quite similar
to this \fBpsh\fR. It is designed to provide a command line that can be called
inside some other program via \f(CW\*(C`PSH::prompt();\*(C'\fR, but a small file
\&\fIpsh.pl\fR is also included that uses \s-1PSH\s0 to provide a standalone
shell. Perhaps some merger of these efforts would be beneficial to all?
.Sh "SoftList"
.IX Subsection "SoftList"
Some versions of the Perl faq mention an interactive Perl shell called
SoftList, which can still be found at
\&\f(CW\*(C`http://www.mit.edu/afs/sipb/contrib/perl/SoftList/\*(C'\fR. It predates
Term::Readline and was apparently last touched in 1993, so it seems to
be obsolescent.
.Sh "timtosh"
.IX Subsection "timtosh"
Tim Newsome, <\fInuisance@cmu.edu\fR>, has developed a shell he calls
\&\fBtimtosh\fR (There Is More Than One SHell). Per his web site
(\f(CW\*(C`http://www.wiw.org/~drz/timtosh\*(C'\fR),
it is a shell written entirely in Perl. The goal is to get a shell which you
can extend in Perl and can do some other niceties related to
Perl (like perl re file matching). As of 1999\-12\-13 (Perl Shell 0.004 release date),
Tim says \fBtimtosh\fR ``is focused quite differently than \fBpsh\fR is, but is currently
still waiting for a rewrite of the command line parsing.
(It has been for almost a year now)''.
.Sh "vbsh"
.IX Subsection "vbsh"
Tom Christiansen and Nathan Torkington's book \fBPerl Cookbook\fR, published by
O'Reilly in 1998 (\s-1ISBN\s0 1\-56592\-243\-3) has \*(L"Example 15\-4. vbsh\*(R" on page 531 for
section 15.11 (Editing Input). It stands for Very Bad SHell.
.Sh "Comparison of perl shells"
.IX Subsection "Comparison of perl shells"
As an aid to comparing/contrasting these different shells, here is a
brief table indicating whether or not each has certain features.
.PP
.Vb 7
\&  Key to features:
\&    PE : Perl evaluation of Perl expressions
\&    SHE: shell-like evaluation of shell-like expressions, including 
\&         'exec'ing executables searched for in PATH
\&    CLE: command-line editing
\&    JC : job control
\&    PL : pipelines
.Ve
.PP
.Vb 4
\&  Key to symbols:
\&    * : feature present
\&    - : feature absent
\&    ? : don't know
.Ve
.PP
.Vb 1
\&  The shells:
.Ve
.PP
.Vb 1
\&    Shell Name         PE    SHE   CLE    JC    PL
.Ve
.PP
.Vb 9
\& psh (this one)         *     *     *     *     *            
\& Larry Wall shell       *     -     -     -     -
\& lpsh                   *     -     *     -     -
\& Perl debugger shell    *     -     *     -     -
\& perlsh                 *     -     *     -     -
\& Krynicky PSH.pm        *     *     ?     -     ?
\& SoftList               *     ?     *     ?     ?
\& timtosh                -     *     *     *     *
\& vbsh                   ?     ?     ?     ?     -
.Ve
.SH "FILES"
.IX Header "FILES"
\&\fIpsh\fR \- The Perl Shell executable script.
.PP
\&\fI.pshrc\fR \- The user's Perl Shell `profile'. May be in \f(CW$HOME\fR or the
current directory; if both are present, both will be read in the order
mentioned.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1999\-2003 Gregor N. Purdy. All rights reserved.
This script is free software. It may be copied or modified according
to the same terms as Perl itself.
.PP
.Vb 1
\& E<lt>F<gregor@focusresearch.com>E<gt>
.Ve
.SH "CREDITS"
.IX Header "CREDITS"
The following people have contributed to the development of \f(CW\*(C`psh\*(C'\fR:
.IP "Prodigious Contributors" 4
.IX Item "Prodigious Contributors"
Markus Peter <\fIwarp@spin.de\fR> added job and signal handling,
globbing, redirection, pipelines, parts of completion code, Win32 port,
i18n code, some bash compatibility builtins and environment variables
and some more minor updates.
.Sp
Glen Whitney <\fIgwhitney@post.harvard.edu\fR> added evaluation
strategies, improved interrupt/job handling, \f(CW&Psh::evl\fR, \f(CW$Psh::echo\fR,
more extensive documentation, and other more minor features.
.Sp
Omer Shenker <\fIoshenker@iname.com\fR> added file locking, Win32
code, login shell handling, various bits of documentation, and other minor
features and updates.
.Sp
Hiroo Hayashi <\fIhiroo.hayashi@computer.org\fR> added the current,
bash compatible support for programmable completions and some small fixes.
We also have to thank him for the existence of the Term::ReadLine::Gnu module.
.IP "ReadLine Support" 4
.IX Item "ReadLine Support"
Code examples showing how to apply the Term::ReadLine package were contributed
by Billy Naylor <\fIbilly.naylor@eu.net\fR> (in his \f(CW\*(C`pash.pl\*(C'\fR program,
which is his own Perl shell).
.IP "Symbol Table Dumping" 4
.IX Item "Symbol Table Dumping"
Billy Naylor <\fIbilly.naylor@eu.net\fR> also had an example of a symbol
table printing function that was used as the starting point for the \f(CW\*(C`psh\*(C'\fR
function \f(CW\*(C`psh::symbols()\*(C'\fR. The \f(CW\*(C`psh\*(C'\fR version adds the ability to specify a
package name, and it also filters out some special variables. The implementation
technique is also different from Billy's.
.IP "Prompt String Variables" 4
.IX Item "Prompt String Variables"
Matthew D. Allen <\fIs2mdalle@titan.vcu.edu\fR> contributed an enhanced
prompt string handling routine that emulates the \f(CW\*(C`bash\*(C'\fR prompt variables. This
was expanded into the form now present.
.IP "Typo Spotting" 4
.IX Item "Typo Spotting"
Allan Kelly <\fIakelly@holyrood.ed.ac.uk\fR> found some problems with the
generated documentation.
