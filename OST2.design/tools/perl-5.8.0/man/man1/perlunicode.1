.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLUNICODE 1"
.TH PERLUNICODE 1 "2002-06-08" "perl v5.8.0" "Perl Programmers Reference Guide"
.SH "NAME"
perlunicode \- Unicode support in Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Important Caveats"
.IX Subsection "Important Caveats"
Unicode support is an extensive requirement. While Perl does not
implement the Unicode standard or the accompanying technical reports
from cover to cover, Perl does support many Unicode features.
.IP "Input and Output Layers" 4
.IX Item "Input and Output Layers"
Perl knows when a filehandle uses Perl's internal Unicode encodings
(\s-1UTF\-8\s0, or UTF-EBCDIC if in \s-1EBCDIC\s0) if the filehandle is opened with
the \*(L":utf8\*(R" layer.  Other encodings can be converted to Perl's
encoding on input or from Perl's encoding on output by use of the
\&\*(L":encoding(...)\*(R"  layer.  See open.
.Sp
To indicate that Perl source itself is using a particular encoding,
see encoding.
.IP "Regular Expressions" 4
.IX Item "Regular Expressions"
The regular expression compiler produces polymorphic opcodes.  That is,
the pattern adapts to the data and automatically switches to the Unicode
character scheme when presented with Unicode data\*(--or instead uses
a traditional byte scheme when presented with byte data.
.ie n .IP """use utf8"" still needed to enable \s-1UTF\-8/UTF\-EBCDIC\s0 in scripts" 4
.el .IP "\f(CWuse utf8\fR still needed to enable \s-1UTF\-8/UTF\-EBCDIC\s0 in scripts" 4
.IX Item "use utf8 still needed to enable UTF-8/UTF-EBCDIC in scripts"
As a compatibility measure, the \f(CW\*(C`use utf8\*(C'\fR pragma must be explicitly
included to enable recognition of \s-1UTF\-8\s0 in the Perl scripts themselves
(in string or regular expression literals, or in identifier names) on
ASCII-based machines or to recognize UTF-EBCDIC on EBCDIC-based
machines.  \fBThese are the only times when an explicit \f(CB\*(C`use utf8\*(C'\fB
is needed.\fR  See utf8.
.Sp
You can also use the \f(CW\*(C`encoding\*(C'\fR pragma to change the default encoding
of the data in your script; see encoding.
.Sh "Byte and Character Semantics"
.IX Subsection "Byte and Character Semantics"
Beginning with version 5.6, Perl uses logically-wide characters to
represent strings internally.
.PP
In future, Perl-level operations will be expected to work with
characters rather than bytes.
.PP
However, as an interim compatibility measure, Perl aims to
provide a safe migration path from byte semantics to character
semantics for programs.  For operations where Perl can unambiguously
decide that the input data are characters, Perl switches to
character semantics.  For operations where this determination cannot
be made without additional information from the user, Perl decides in
favor of compatibility and chooses to use byte semantics.
.PP
This behavior preserves compatibility with earlier versions of Perl,
which allowed byte semantics in Perl operations only if
none of the program's inputs were marked as being as source of Unicode
character data.  Such data may come from filehandles, from calls to
external programs, from information provided by the system (such as \f(CW%ENV\fR),
or from literals and constants in the source text.
.PP
On Windows platforms, if the \f(CW\*(C`\-C\*(C'\fR command line switch is used or the
${^WIDE_SYSTEM_CALLS} global flag is set to \f(CW1\fR, all system calls
will use the corresponding wide-character APIs.  This feature is
available only on Windows to conform to the \s-1API\s0 standard already
established for that platform\*(--and there are very few non-Windows
platforms that have Unicode-aware APIs.
.PP
The \f(CW\*(C`bytes\*(C'\fR pragma will always, regardless of platform, force byte
semantics in a particular lexical scope.  See bytes.
.PP
The \f(CW\*(C`utf8\*(C'\fR pragma is primarily a compatibility device that enables
recognition of \s-1UTF\-\s0(8|EBCDIC) in literals encountered by the parser.
Note that this pragma is only required while Perl defaults to byte
semantics; when character semantics become the default, this pragma
may become a no\-op.  See utf8.
.PP
Unless explicitly stated, Perl operators use character semantics
for Unicode data and byte semantics for non-Unicode data.
The decision to use character semantics is made transparently.  If
input data comes from a Unicode source\*(--for example, if a character
encoding layer is added to a filehandle or a literal Unicode
string constant appears in a program\*(--character semantics apply.
Otherwise, byte semantics are in effect.  The \f(CW\*(C`bytes\*(C'\fR pragma should
be used to force byte semantics on Unicode data.
.PP
If strings operating under byte semantics and strings with Unicode
character data are concatenated, the new string will be upgraded to
\&\fI\s-1ISO\s0 8859\-1 (Latin\-1)\fR, even if the old Unicode string used \s-1EBCDIC\s0.
This translation is done without regard to the system's native 8\-bit
encoding, so to change this for systems with non\-Latin\-1 and 
non-EBCDIC native encodings use the \f(CW\*(C`encoding\*(C'\fR pragma.  See
encoding.
.PP
Under character semantics, many operations that formerly operated on
bytes now operate on characters. A character in Perl is
logically just a number ranging from 0 to 2**31 or so. Larger
characters may encode into longer sequences of bytes internally, but
this internal detail is mostly hidden for Perl code.
See perluniintro for more.
.Sh "Effects of Character Semantics"
.IX Subsection "Effects of Character Semantics"
Character semantics have the following effects:
.IP "\(bu" 4
Strings\*(--including hash keys\*(--and regular expression patterns may
contain characters that have an ordinal value larger than 255.
.Sp
If you use a Unicode editor to edit your program, Unicode characters
may occur directly within the literal strings in one of the various
Unicode encodings (\s-1UTF\-8\s0, \s-1UTF\-EBCDIC\s0, \s-1UCS\-2\s0, etc.), but will be recognized
as such and converted to Perl's internal representation only if the
appropriate encoding is specified.
.Sp
Unicode characters can also be added to a string by using the
\&\f(CW\*(C`\ex{...}\*(C'\fR notation.  The Unicode code for the desired character, in
hexadecimal, should be placed in the braces. For instance, a smiley
face is \f(CW\*(C`\ex{263A}\*(C'\fR.  This encoding scheme only works for characters
with a code of 0x100 or above.
.Sp
Additionally, if you
.Sp
.Vb 1
\&   use charnames ':full';
.Ve
.Sp
you can use the \f(CW\*(C`\eN{...}\*(C'\fR notation and put the official Unicode
character name within the braces, such as \f(CW\*(C`\eN{WHITE SMILING FACE}\*(C'\fR.
.IP "\(bu" 4
If an appropriate encoding is specified, identifiers within the
Perl script may contain Unicode alphanumeric characters, including
ideographs.  Perl does not currently attempt to canonicalize variable
names.
.IP "\(bu" 4
Regular expressions match characters instead of bytes.  \*(L".\*(R" matches
a character instead of a byte.  The \f(CW\*(C`\eC\*(C'\fR pattern is provided to force
a match a single byte\*(--a \f(CW\*(C`char\*(C'\fR in C, hence \f(CW\*(C`\eC\*(C'\fR.
.IP "\(bu" 4
Character classes in regular expressions match characters instead of
bytes and match against the character properties specified in the
Unicode properties database.  \f(CW\*(C`\ew\*(C'\fR can be used to match a Japanese
ideograph, for instance.
.IP "\(bu" 4
Named Unicode properties, scripts, and block ranges may be used like
character classes via the \f(CW\*(C`\ep{}\*(C'\fR \*(L"matches property\*(R" construct and
the  \f(CW\*(C`\eP{}\*(C'\fR negation, \*(L"doesn't match property\*(R".
.Sp
For instance, \f(CW\*(C`\ep{Lu}\*(C'\fR matches any character with the Unicode \*(L"Lu\*(R"
(Letter, uppercase) property, while \f(CW\*(C`\ep{M}\*(C'\fR matches any character
with an \*(L"M\*(R" (mark\*(--accents and such) property.  Brackets are not
required for single letter properties, so \f(CW\*(C`\ep{M}\*(C'\fR is equivalent to
\&\f(CW\*(C`\epM\*(C'\fR. Many predefined properties are available, such as
\&\f(CW\*(C`\ep{Mirrored}\*(C'\fR and \f(CW\*(C`\ep{Tibetan}\*(C'\fR.
.Sp
The official Unicode script and block names have spaces and dashes as
separators, but for convenience you can use dashes, spaces, or
underbars, and case is unimportant. It is recommended, however, that
for consistency you use the following naming: the official Unicode
script, property, or block name (see below for the additional rules
that apply to block names) with whitespace and dashes removed, and the
words \*(L"uppercase\-first\-lowercase\-rest\*(R". \f(CW\*(C`Latin\-1 Supplement\*(C'\fR thus
becomes \f(CW\*(C`Latin1Supplement\*(C'\fR.
.Sp
You can also use negation in both \f(CW\*(C`\ep{}\*(C'\fR and \f(CW\*(C`\eP{}\*(C'\fR by introducing a caret
(^) between the first brace and the property name: \f(CW\*(C`\ep{^Tamil}\*(C'\fR is
equal to \f(CW\*(C`\eP{Tamil}\*(C'\fR.
.Sp
Here are the basic Unicode General Category properties, followed by their
long form.  You can use either; \f(CW\*(C`\ep{Lu}\*(C'\fR and \f(CW\*(C`\ep{LowercaseLetter}\*(C'\fR,
for instance, are identical.
.Sp
.Vb 1
\&    Short       Long
.Ve
.Sp
.Vb 6
\&    L           Letter
\&    Lu          UppercaseLetter
\&    Ll          LowercaseLetter
\&    Lt          TitlecaseLetter
\&    Lm          ModifierLetter
\&    Lo          OtherLetter
.Ve
.Sp
.Vb 4
\&    M           Mark
\&    Mn          NonspacingMark
\&    Mc          SpacingMark
\&    Me          EnclosingMark
.Ve
.Sp
.Vb 4
\&    N           Number
\&    Nd          DecimalNumber
\&    Nl          LetterNumber
\&    No          OtherNumber
.Ve
.Sp
.Vb 10
\&    P           Punctuation
\&    Pc          ConnectorPunctuation
\&    Pd          DashPunctuation
\&    Ps          OpenPunctuation
\&    Pe          ClosePunctuation
\&    Pi          InitialPunctuation
\&                (may behave like Ps or Pe depending on usage)
\&    Pf          FinalPunctuation
\&                (may behave like Ps or Pe depending on usage)
\&    Po          OtherPunctuation
.Ve
.Sp
.Vb 5
\&    S           Symbol
\&    Sm          MathSymbol
\&    Sc          CurrencySymbol
\&    Sk          ModifierSymbol
\&    So          OtherSymbol
.Ve
.Sp
.Vb 4
\&    Z           Separator
\&    Zs          SpaceSeparator
\&    Zl          LineSeparator
\&    Zp          ParagraphSeparator
.Ve
.Sp
.Vb 6
\&    C           Other
\&    Cc          Control
\&    Cf          Format
\&    Cs          Surrogate   (not usable)
\&    Co          PrivateUse
\&    Cn          Unassigned
.Ve
.Sp
Single-letter properties match all characters in any of the
two-letter sub-properties starting with the same letter.
\&\f(CW\*(C`L&\*(C'\fR is a special case, which is an alias for \f(CW\*(C`Ll\*(C'\fR, \f(CW\*(C`Lu\*(C'\fR, and \f(CW\*(C`Lt\*(C'\fR.
.Sp
Because Perl hides the need for the user to understand the internal
representation of Unicode characters, there is no need to implement
the somewhat messy concept of surrogates. \f(CW\*(C`Cs\*(C'\fR is therefore not
supported.
.Sp
Because scripts differ in their directionality\*(--Hebrew is
written right to left, for example\*(--Unicode supplies these properties:
.Sp
.Vb 1
\&    Property    Meaning
.Ve
.Sp
.Vb 19
\&    BidiL       Left-to-Right
\&    BidiLRE     Left-to-Right Embedding
\&    BidiLRO     Left-to-Right Override
\&    BidiR       Right-to-Left
\&    BidiAL      Right-to-Left Arabic
\&    BidiRLE     Right-to-Left Embedding
\&    BidiRLO     Right-to-Left Override
\&    BidiPDF     Pop Directional Format
\&    BidiEN      European Number
\&    BidiES      European Number Separator
\&    BidiET      European Number Terminator
\&    BidiAN      Arabic Number
\&    BidiCS      Common Number Separator
\&    BidiNSM     Non-Spacing Mark
\&    BidiBN      Boundary Neutral
\&    BidiB       Paragraph Separator
\&    BidiS       Segment Separator
\&    BidiWS      Whitespace
\&    BidiON      Other Neutrals
.Ve
.Sp
For example, \f(CW\*(C`\ep{BidiR}\*(C'\fR matches characters that are normally
written right to left.
.Sh "Scripts"
.IX Subsection "Scripts"
The script names which can be used by \f(CW\*(C`\ep{...}\*(C'\fR and \f(CW\*(C`\eP{...}\*(C'\fR,
such as in \f(CW\*(C`\ep{Latin}\*(C'\fR or \f(CW\*(C`\ep{Cyrillic}\*(C'\fR, are as follows:
.PP
.Vb 44
\&    Arabic
\&    Armenian
\&    Bengali
\&    Bopomofo
\&    Buhid
\&    CanadianAboriginal
\&    Cherokee
\&    Cyrillic
\&    Deseret
\&    Devanagari
\&    Ethiopic
\&    Georgian
\&    Gothic
\&    Greek
\&    Gujarati
\&    Gurmukhi
\&    Han
\&    Hangul
\&    Hanunoo
\&    Hebrew
\&    Hiragana
\&    Inherited
\&    Kannada
\&    Katakana
\&    Khmer
\&    Lao
\&    Latin
\&    Malayalam
\&    Mongolian
\&    Myanmar
\&    Ogham
\&    OldItalic
\&    Oriya
\&    Runic
\&    Sinhala
\&    Syriac
\&    Tagalog
\&    Tagbanwa
\&    Tamil
\&    Telugu
\&    Thaana
\&    Thai
\&    Tibetan
\&    Yi
.Ve
.PP
Extended property classes can supplement the basic
properties, defined by the \fIPropList\fR Unicode database:
.PP
.Vb 27
\&    ASCIIHexDigit
\&    BidiControl
\&    Dash
\&    Deprecated
\&    Diacritic
\&    Extender
\&    GraphemeLink
\&    HexDigit
\&    Hyphen
\&    Ideographic
\&    IDSBinaryOperator
\&    IDSTrinaryOperator
\&    JoinControl
\&    LogicalOrderException
\&    NoncharacterCodePoint
\&    OtherAlphabetic
\&    OtherDefaultIgnorableCodePoint
\&    OtherGraphemeExtend
\&    OtherLowercase
\&    OtherMath
\&    OtherUppercase
\&    QuotationMark
\&    Radical
\&    SoftDotted
\&    TerminalPunctuation
\&    UnifiedIdeograph
\&    WhiteSpace
.Ve
.PP
and there are further derived properties:
.PP
.Vb 4
\&    Alphabetic      Lu + Ll + Lt + Lm + Lo + OtherAlphabetic
\&    Lowercase       Ll + OtherLowercase
\&    Uppercase       Lu + OtherUppercase
\&    Math            Sm + OtherMath
.Ve
.PP
.Vb 2
\&    ID_Start        Lu + Ll + Lt + Lm + Lo + Nl
\&    ID_Continue     ID_Start + Mn + Mc + Nd + Pc
.Ve
.PP
.Vb 5
\&    Any             Any character
\&    Assigned        Any non-Cn character (i.e. synonym for \eP{Cn})
\&    Unassigned      Synonym for \ep{Cn}
\&    Common          Any character (or unassigned code point)
\&                    not explicitly assigned to a script
.Ve
.PP
For backward compatibility (with Perl 5.6), all properties mentioned
so far may have \f(CW\*(C`Is\*(C'\fR prepended to their name, so \f(CW\*(C`\eP{IsLu}\*(C'\fR, for
example, is equal to \f(CW\*(C`\eP{Lu}\*(C'\fR.
.Sh "Blocks"
.IX Subsection "Blocks"
In addition to \fBscripts\fR, Unicode also defines \fBblocks\fR of
characters.  The difference between scripts and blocks is that the
concept of scripts is closer to natural languages, while the concept
of blocks is more of an artificial grouping based on groups of 256
Unicode characters. For example, the \f(CW\*(C`Latin\*(C'\fR script contains letters
from many blocks but does not contain all the characters from those
blocks. It does not, for example, contain digits, because digits are
shared across many scripts. Digits and similar groups, like
punctuation, are in a category called \f(CW\*(C`Common\*(C'\fR.
.PP
For more about scripts, see the \s-1UTR\s0 #24:
.PP
.Vb 1
\&   http://www.unicode.org/unicode/reports/tr24/
.Ve
.PP
For more about blocks, see:
.PP
.Vb 1
\&   http://www.unicode.org/Public/UNIDATA/Blocks.txt
.Ve
.PP
Block names are given with the \f(CW\*(C`In\*(C'\fR prefix. For example, the
Katakana block is referenced via \f(CW\*(C`\ep{InKatakana}\*(C'\fR.  The \f(CW\*(C`In\*(C'\fR
prefix may be omitted if there is no naming conflict with a script
or any other property, but it is recommended that \f(CW\*(C`In\*(C'\fR always be used
for block tests to avoid confusion.
.PP
These block names are supported:
.PP
.Vb 110
\&    InAlphabeticPresentationForms
\&    InArabic
\&    InArabicPresentationFormsA
\&    InArabicPresentationFormsB
\&    InArmenian
\&    InArrows
\&    InBasicLatin
\&    InBengali
\&    InBlockElements
\&    InBopomofo
\&    InBopomofoExtended
\&    InBoxDrawing
\&    InBraillePatterns
\&    InBuhid
\&    InByzantineMusicalSymbols
\&    InCJKCompatibility
\&    InCJKCompatibilityForms
\&    InCJKCompatibilityIdeographs
\&    InCJKCompatibilityIdeographsSupplement
\&    InCJKRadicalsSupplement
\&    InCJKSymbolsAndPunctuation
\&    InCJKUnifiedIdeographs
\&    InCJKUnifiedIdeographsExtensionA
\&    InCJKUnifiedIdeographsExtensionB
\&    InCherokee
\&    InCombiningDiacriticalMarks
\&    InCombiningDiacriticalMarksforSymbols
\&    InCombiningHalfMarks
\&    InControlPictures
\&    InCurrencySymbols
\&    InCyrillic
\&    InCyrillicSupplementary
\&    InDeseret
\&    InDevanagari
\&    InDingbats
\&    InEnclosedAlphanumerics
\&    InEnclosedCJKLettersAndMonths
\&    InEthiopic
\&    InGeneralPunctuation
\&    InGeometricShapes
\&    InGeorgian
\&    InGothic
\&    InGreekExtended
\&    InGreekAndCoptic
\&    InGujarati
\&    InGurmukhi
\&    InHalfwidthAndFullwidthForms
\&    InHangulCompatibilityJamo
\&    InHangulJamo
\&    InHangulSyllables
\&    InHanunoo
\&    InHebrew
\&    InHighPrivateUseSurrogates
\&    InHighSurrogates
\&    InHiragana
\&    InIPAExtensions
\&    InIdeographicDescriptionCharacters
\&    InKanbun
\&    InKangxiRadicals
\&    InKannada
\&    InKatakana
\&    InKatakanaPhoneticExtensions
\&    InKhmer
\&    InLao
\&    InLatin1Supplement
\&    InLatinExtendedA
\&    InLatinExtendedAdditional
\&    InLatinExtendedB
\&    InLetterlikeSymbols
\&    InLowSurrogates
\&    InMalayalam
\&    InMathematicalAlphanumericSymbols
\&    InMathematicalOperators
\&    InMiscellaneousMathematicalSymbolsA
\&    InMiscellaneousMathematicalSymbolsB
\&    InMiscellaneousSymbols
\&    InMiscellaneousTechnical
\&    InMongolian
\&    InMusicalSymbols
\&    InMyanmar
\&    InNumberForms
\&    InOgham
\&    InOldItalic
\&    InOpticalCharacterRecognition
\&    InOriya
\&    InPrivateUseArea
\&    InRunic
\&    InSinhala
\&    InSmallFormVariants
\&    InSpacingModifierLetters
\&    InSpecials
\&    InSuperscriptsAndSubscripts
\&    InSupplementalArrowsA
\&    InSupplementalArrowsB
\&    InSupplementalMathematicalOperators
\&    InSupplementaryPrivateUseAreaA
\&    InSupplementaryPrivateUseAreaB
\&    InSyriac
\&    InTagalog
\&    InTagbanwa
\&    InTags
\&    InTamil
\&    InTelugu
\&    InThaana
\&    InThai
\&    InTibetan
\&    InUnifiedCanadianAboriginalSyllabics
\&    InVariationSelectors
\&    InYiRadicals
\&    InYiSyllables
.Ve
.IP "\(bu" 4
The special pattern \f(CW\*(C`\eX\*(C'\fR matches any extended Unicode
sequence\-\-\*(L"a combining character sequence\*(R" in Standardese\*(--where the
first character is a base character and subsequent characters are mark
characters that apply to the base character.  \f(CW\*(C`\eX\*(C'\fR is equivalent to
\&\f(CW\*(C`(?:\ePM\epM*)\*(C'\fR.
.IP "\(bu" 4
The \f(CW\*(C`tr///\*(C'\fR operator translates characters instead of bytes.  Note
that the \f(CW\*(C`tr///CU\*(C'\fR functionality has been removed.  For similar
functionality see pack('U0', ...) and pack('C0', ...).
.IP "\(bu" 4
Case translation operators use the Unicode case translation tables
when character input is provided.  Note that \f(CW\*(C`uc()\*(C'\fR, or \f(CW\*(C`\eU\*(C'\fR in
interpolated strings, translates to uppercase, while \f(CW\*(C`ucfirst\*(C'\fR,
or \f(CW\*(C`\eu\*(C'\fR in interpolated strings, translates to titlecase in languages
that make the distinction.
.IP "\(bu" 4
Most operators that deal with positions or lengths in a string will
automatically switch to using character positions, including
\&\f(CW\*(C`chop()\*(C'\fR, \f(CW\*(C`substr()\*(C'\fR, \f(CW\*(C`pos()\*(C'\fR, \f(CW\*(C`index()\*(C'\fR, \f(CW\*(C`rindex()\*(C'\fR,
\&\f(CW\*(C`sprintf()\*(C'\fR, \f(CW\*(C`write()\*(C'\fR, and \f(CW\*(C`length()\*(C'\fR.  Operators that
specifically do not switch include \f(CW\*(C`vec()\*(C'\fR, \f(CW\*(C`pack()\*(C'\fR, and
\&\f(CW\*(C`unpack()\*(C'\fR.  Operators that really don't care include \f(CW\*(C`chomp()\*(C'\fR,
operators that treats strings as a bucket of bits such as \f(CW\*(C`sort()\*(C'\fR,
and operators dealing with filenames.
.IP "\(bu" 4
The \f(CW\*(C`pack()\*(C'\fR/\f(CW\*(C`unpack()\*(C'\fR letters \f(CW\*(C`c\*(C'\fR and \f(CW\*(C`C\*(C'\fR do \fInot\fR change,
since they are often used for byte-oriented formats.  Again, think
\&\f(CW\*(C`char\*(C'\fR in the C language.
.Sp
There is a new \f(CW\*(C`U\*(C'\fR specifier that converts between Unicode characters
and code points.
.IP "\(bu" 4
The \f(CW\*(C`chr()\*(C'\fR and \f(CW\*(C`ord()\*(C'\fR functions work on characters, similar to
\&\f(CW\*(C`pack("U")\*(C'\fR and \f(CW\*(C`unpack("U")\*(C'\fR, \fInot\fR \f(CW\*(C`pack("C")\*(C'\fR and
\&\f(CW\*(C`unpack("C")\*(C'\fR.  \f(CW\*(C`pack("C")\*(C'\fR and \f(CW\*(C`unpack("C")\*(C'\fR are methods for
emulating byte-oriented \f(CW\*(C`chr()\*(C'\fR and \f(CW\*(C`ord()\*(C'\fR on Unicode strings.
While these methods reveal the internal encoding of Unicode strings,
that is not something one normally needs to care about at all.
.IP "\(bu" 4
The bit string operators, \f(CW\*(C`& | ^ ~\*(C'\fR, can operate on character data.
However, for backward compatibility, such as when using bit string
operations when characters are all less than 256 in ordinal value, one
should not use \f(CW\*(C`~\*(C'\fR (the bit complement) with characters of both
values less than 256 and values greater than 256.  Most importantly,
DeMorgan's laws (\f(CW\*(C`~($x|$y) eq ~$x&~$y\*(C'\fR and \f(CW\*(C`~($x&$y) eq ~$x|~$y\*(C'\fR)
will not hold.  The reason for this mathematical \fIfaux pas\fR is that
the complement cannot return \fBboth\fR the 8\-bit (byte\-wide) bit
complement \fBand\fR the full character-wide bit complement.
.IP "\(bu" 4
\&\fIlc()\fR, \fIuc()\fR, \fIlcfirst()\fR, and \fIucfirst()\fR work for the following cases:
.RS 4
.IP "\(bu" 8
the case mapping is from a single Unicode character to another
single Unicode character, or
.IP "\(bu" 8
the case mapping is from a single Unicode character to more
than one Unicode character.
.RE
.RS 4
.Sp
The following cases do not yet work:
.IP "\(bu" 8
the \*(L"final sigma\*(R" (Greek), and
.IP "\(bu" 8
anything to with locales (Lithuanian, Turkish, Azeri).
.RE
.RS 4
.Sp
See the Unicode Technical Report #21, Case Mappings, for more details.
.RE
.IP "\(bu" 4
And finally, \f(CW\*(C`scalar reverse()\*(C'\fR reverses by character rather than by byte.
.Sh "User-Defined Character Properties"
.IX Subsection "User-Defined Character Properties"
You can define your own character properties by defining subroutines
whose names begin with \*(L"In\*(R" or \*(L"Is\*(R".  The subroutines must be
visible in the package that uses the properties.  The user-defined
properties can be used in the regular expression \f(CW\*(C`\ep\*(C'\fR and \f(CW\*(C`\eP\*(C'\fR
constructs.
.PP
The subroutines must return a specially-formatted string, with one
or more newline-separated lines.  Each line must be one of the following:
.IP "\(bu" 4
Two hexadecimal numbers separated by horizontal whitespace (space or
tabular characters) denoting a range of Unicode code points to include.
.IP "\(bu" 4
Something to include, prefixed by \*(L"+\*(R": a built-in character
property (prefixed by \*(L"utf8::\*(R"), to represent all the characters in that
property; two hexadecimal code points for a range; or a single
hexadecimal code point.
.IP "\(bu" 4
Something to exclude, prefixed by \*(L"\-\*(R": an existing character
property (prefixed by \*(L"utf8::\*(R"), for all the characters in that
property; two hexadecimal code points for a range; or a single
hexadecimal code point.
.IP "\(bu" 4
Something to negate, prefixed \*(L"!\*(R": an existing character
property (prefixed by \*(L"utf8::\*(R") for all the characters except the
characters in the property; two hexadecimal code points for a range;
or a single hexadecimal code point.
.PP
For example, to define a property that covers both the Japanese
syllabaries (hiragana and katakana), you can define
.PP
.Vb 6
\&    sub InKana {
\&        return <<END;
\&    3040\et309F
\&    30A0\et30FF
\&    END
\&    }
.Ve
.PP
Imagine that the here-doc end marker is at the beginning of the line.
Now you can use \f(CW\*(C`\ep{InKana}\*(C'\fR and \f(CW\*(C`\eP{InKana}\*(C'\fR.
.PP
You could also have used the existing block property names:
.PP
.Vb 6
\&    sub InKana {
\&        return <<'END';
\&    +utf8::InHiragana
\&    +utf8::InKatakana
\&    END
\&    }
.Ve
.PP
Suppose you wanted to match only the allocated characters,
not the raw block ranges: in other words, you want to remove
the non\-characters:
.PP
.Vb 7
\&    sub InKana {
\&        return <<'END';
\&    +utf8::InHiragana
\&    +utf8::InKatakana
\&    -utf8::IsCn
\&    END
\&    }
.Ve
.PP
The negation is useful for defining (surprise!) negated classes.
.PP
.Vb 7
\&    sub InNotKana {
\&        return <<'END';
\&    !utf8::InHiragana
\&    -utf8::InKatakana
\&    +utf8::IsCn
\&    END
\&    }
.Ve
.Sh "Character Encodings for Input and Output"
.IX Subsection "Character Encodings for Input and Output"
See Encode.
.Sh "Unicode Regular Expression Support Level"
.IX Subsection "Unicode Regular Expression Support Level"
The following list of Unicode support for regular expressions describes
all the features currently supported.  The references to \*(L"Level N\*(R"
and the section numbers refer to the Unicode Technical Report 18,
\&\*(L"Unicode Regular Expression Guidelines\*(R".
.IP "\(bu" 4
Level 1 \- Basic Unicode Support
.Sp
.Vb 7
\&        2.1 Hex Notation                        - done          [1]
\&            Named Notation                      - done          [2]
\&        2.2 Categories                          - done          [3][4]
\&        2.3 Subtraction                         - MISSING       [5][6]
\&        2.4 Simple Word Boundaries              - done          [7]
\&        2.5 Simple Loose Matches                - done          [8]
\&        2.6 End of Line                         - MISSING       [9][10]
.Ve
.Sp
.Vb 18
\&        [ 1] \ex{...}
\&        [ 2] \eN{...}
\&        [ 3] . \ep{...} \eP{...}
\&        [ 4] now scripts (see UTR#24 Script Names) in addition to blocks
\&        [ 5] have negation
\&        [ 6] can use regular expression look-ahead [a]
\&             or user-defined character properties [b] to emulate subtraction
\&        [ 7] include Letters in word characters
\&        [ 8] note that Perl does Full case-folding in matching, not Simple:
\&             for example U+1F88 is equivalent with U+1F000 U+03B9,
\&             not with 1F80.  This difference matters for certain Greek
\&             capital letters with certain modifiers: the Full case-folding
\&             decomposes the letter, while the Simple case-folding would map
\&             it to a single character.
\&        [ 9] see UTR#13 Unicode Newline Guidelines
\&        [10] should do ^ and $ also on \ex{85}, \ex{2028} and \ex{2029})
\&             (should also affect <>, $., and script line numbers)
\&             (the \ex{85}, \ex{2028} and \ex{2029} do match \es)
.Ve
.Sp
[a] You can mimic class subtraction using lookahead.
For example, what \s-1TR18\s0 might write as
.Sp
.Vb 1
\&    [{Greek}-[{UNASSIGNED}]]
.Ve
.Sp
in Perl can be written as:
.Sp
.Vb 2
\&    (?!\ep{Unassigned})\ep{InGreekAndCoptic}
\&    (?=\ep{Assigned})\ep{InGreekAndCoptic}
.Ve
.Sp
But in this particular example, you probably really want
.Sp
.Vb 1
\&    \ep{GreekAndCoptic}
.Ve
.Sp
which will match assigned characters known to be part of the Greek script.
.Sp
[b] See \*(L"User\-Defined Character Properties\*(R".
.IP "\(bu" 4
Level 2 \- Extended Unicode Support
.Sp
.Vb 5
\&        3.1 Surrogates                          - MISSING
\&        3.2 Canonical Equivalents               - MISSING       [11][12]
\&        3.3 Locale-Independent Graphemes        - MISSING       [13]
\&        3.4 Locale-Independent Words            - MISSING       [14]
\&        3.5 Locale-Independent Loose Matches    - MISSING       [15]
.Ve
.Sp
.Vb 5
\&        [11] see UTR#15 Unicode Normalization
\&        [12] have Unicode::Normalize but not integrated to regexes
\&        [13] have \eX but at this level . should equal that
\&        [14] need three classes, not just \ew and \eW
\&        [15] see UTR#21 Case Mappings
.Ve
.IP "\(bu" 4
Level 3 \- Locale-Sensitive Support
.Sp
.Vb 5
\&        4.1 Locale-Dependent Categories         - MISSING
\&        4.2 Locale-Dependent Graphemes          - MISSING       [16][17]
\&        4.3 Locale-Dependent Words              - MISSING
\&        4.4 Locale-Dependent Loose Matches      - MISSING
\&        4.5 Locale-Dependent Ranges             - MISSING
.Ve
.Sp
.Vb 2
\&        [16] see UTR#10 Unicode Collation Algorithms
\&        [17] have Unicode::Collate but not integrated to regexes
.Ve
.Sh "Unicode Encodings"
.IX Subsection "Unicode Encodings"
Unicode characters are assigned to \fIcode points\fR, which are abstract
numbers.  To use these numbers, various encodings are needed.
.IP "\(bu" 4
\&\s-1UTF\-8\s0
.Sp
\&\s-1UTF\-8\s0 is a variable-length (1 to 6 bytes, current character allocations
require 4 bytes), byte-order independent encoding. For \s-1ASCII\s0 (and we
really do mean 7\-bit \s-1ASCII\s0, not another 8\-bit encoding), \s-1UTF\-8\s0 is
transparent.
.Sp
The following table is from Unicode 3.2.
.Sp
.Vb 1
\& Code Points            1st Byte  2nd Byte  3rd Byte  4th Byte
.Ve
.Sp
.Vb 10
\&   U+0000..U+007F       00..7F
\&   U+0080..U+07FF       C2..DF    80..BF
\&   U+0800..U+0FFF       E0        A0..BF    80..BF
\&   U+1000..U+CFFF       E1..EC    80..BF    80..BF
\&   U+D000..U+D7FF       ED        80..9F    80..BF
\&   U+D800..U+DFFF       ******* ill-formed *******
\&   U+E000..U+FFFF       EE..EF    80..BF    80..BF
\&  U+10000..U+3FFFF      F0        90..BF    80..BF    80..BF
\&  U+40000..U+FFFFF      F1..F3    80..BF    80..BF    80..BF
\& U+100000..U+10FFFF     F4        80..8F    80..BF    80..BF
.Ve
.Sp
Note the \f(CW\*(C`A0..BF\*(C'\fR in \f(CW\*(C`U+0800..U+0FFF\*(C'\fR, the \f(CW\*(C`80..9F\*(C'\fR in
\&\f(CW\*(C`U+D000...U+D7FF\*(C'\fR, the \f(CW\*(C`90..B\*(C'\fRF in \f(CW\*(C`U+10000..U+3FFFF\*(C'\fR, and the
\&\f(CW\*(C`80...8F\*(C'\fR in \f(CW\*(C`U+100000..U+10FFFF\*(C'\fR.  The \*(L"gaps\*(R" are caused by legal
\&\s-1UTF\-8\s0 avoiding non-shortest encodings: it is technically possible to
UTF\-8\-encode a single code point in different ways, but that is
explicitly forbidden, and the shortest possible encoding should always
be used.  So that's what Perl does.
.Sp
Another way to look at it is via bits:
.Sp
.Vb 1
\& Code Points                    1st Byte   2nd Byte  3rd Byte  4th Byte
.Ve
.Sp
.Vb 4
\&                    0aaaaaaa     0aaaaaaa
\&            00000bbbbbaaaaaa     110bbbbb  10aaaaaa
\&            ccccbbbbbbaaaaaa     1110cccc  10bbbbbb  10aaaaaa
\&  00000dddccccccbbbbbbaaaaaa     11110ddd  10cccccc  10bbbbbb  10aaaaaa
.Ve
.Sp
As you can see, the continuation bytes all begin with \f(CW10\fR, and the
leading bits of the start byte tell how many bytes the are in the
encoded character.
.IP "\(bu" 4
UTF-EBCDIC
.Sp
Like \s-1UTF\-8\s0 but EBCDIC\-safe, in the way that \s-1UTF\-8\s0 is ASCII\-safe.
.IP "\(bu" 4
\&\s-1UTF\-16\s0, \s-1UTF\-16BE\s0, \s-1UTF16\-LE\s0, Surrogates, and BOMs (Byte Order Marks)
.Sp
The followings items are mostly for reference and general Unicode
knowledge, Perl doesn't use these constructs internally.
.Sp
\&\s-1UTF\-16\s0 is a 2 or 4 byte encoding.  The Unicode code points
\&\f(CW\*(C`U+0000..U+FFFF\*(C'\fR are stored in a single 16\-bit unit, and the code
points \f(CW\*(C`U+10000..U+10FFFF\*(C'\fR in two 16\-bit units.  The latter case is
using \fIsurrogates\fR, the first 16\-bit unit being the \fIhigh
surrogate\fR, and the second being the \fIlow surrogate\fR.
.Sp
Surrogates are code points set aside to encode the \f(CW\*(C`U+10000..U+10FFFF\*(C'\fR
range of Unicode code points in pairs of 16\-bit units.  The \fIhigh
surrogates\fR are the range \f(CW\*(C`U+D800..U+DBFF\*(C'\fR, and the \fIlow surrogates\fR
are the range \f(CW\*(C`U+DC00..U+DFFF\*(C'\fR.  The surrogate encoding is
.Sp
.Vb 2
\&        $hi = ($uni - 0x10000) / 0x400 + 0xD800;
\&        $lo = ($uni - 0x10000) % 0x400 + 0xDC00;
.Ve
.Sp
and the decoding is
.Sp
.Vb 1
\&        $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);
.Ve
.Sp
If you try to generate surrogates (for example by using \fIchr()\fR), you
will get a warning if warnings are turned on, because those code
points are not valid for a Unicode character.
.Sp
Because of the 16\-bitness, \s-1UTF\-16\s0 is byte-order dependent.  \s-1UTF\-16\s0
itself can be used for in-memory computations, but if storage or
transfer is required either \s-1UTF\-16BE\s0 (big\-endian) or \s-1UTF\-16LE\s0
(little\-endian) encodings must be chosen.
.Sp
This introduces another problem: what if you just know that your data
is \s-1UTF\-16\s0, but you don't know which endianness?  Byte Order Marks, or
BOMs, are a solution to this.  A special character has been reserved
in Unicode to function as a byte order marker: the character with the
code point \f(CW\*(C`U+FEFF\*(C'\fR is the \s-1BOM\s0.
.Sp
The trick is that if you read a \s-1BOM\s0, you will know the byte order,
since if it was written on a big-endian platform, you will read the
bytes \f(CW\*(C`0xFE 0xFF\*(C'\fR, but if it was written on a little-endian platform,
you will read the bytes \f(CW\*(C`0xFF 0xFE\*(C'\fR.  (And if the originating platform
was writing in \s-1UTF\-8\s0, you will read the bytes \f(CW\*(C`0xEF 0xBB 0xBF\*(C'\fR.)
.Sp
The way this trick works is that the character with the code point
\&\f(CW\*(C`U+FFFE\*(C'\fR is guaranteed not to be a valid Unicode character, so the
sequence of bytes \f(CW\*(C`0xFF 0xFE\*(C'\fR is unambiguously \*(L"\s-1BOM\s0, represented in
little-endian format\*(R" and cannot be \f(CW\*(C`U+FFFE\*(C'\fR, represented in big-endian
format".
.IP "\(bu" 4
\&\s-1UTF\-32\s0, \s-1UTF\-32BE\s0, \s-1UTF32\-LE\s0
.Sp
The \s-1UTF\-32\s0 family is pretty much like the \s-1UTF\-16\s0 family, expect that
the units are 32\-bit, and therefore the surrogate scheme is not
needed.  The \s-1BOM\s0 signatures will be \f(CW\*(C`0x00 0x00 0xFE 0xFF\*(C'\fR for \s-1BE\s0 and
\&\f(CW\*(C`0xFF 0xFE 0x00 0x00\*(C'\fR for \s-1LE\s0.
.IP "\(bu" 4
\&\s-1UCS\-2\s0, \s-1UCS\-4\s0
.Sp
Encodings defined by the \s-1ISO\s0 10646 standard.  \s-1UCS\-2\s0 is a 16\-bit
encoding.  Unlike \s-1UTF\-16\s0, \s-1UCS\-2\s0 is not extensible beyond \f(CW\*(C`U+FFFF\*(C'\fR,
because it does not use surrogates.  \s-1UCS\-4\s0 is a 32\-bit encoding,
functionally identical to \s-1UTF\-32\s0.
.IP "\(bu" 4
\&\s-1UTF\-7\s0
.Sp
A seven-bit safe (non\-eight\-bit) encoding, which is useful if the
transport or storage is not eight-bit safe.  Defined by \s-1RFC\s0 2152.
.Sh "Security Implications of Unicode"
.IX Subsection "Security Implications of Unicode"
.IP "\(bu" 4
Malformed \s-1UTF\-8\s0
.Sp
Unfortunately, the specification of \s-1UTF\-8\s0 leaves some room for
interpretation of how many bytes of encoded output one should generate
from one input Unicode character.  Strictly speaking, the shortest
possible sequence of \s-1UTF\-8\s0 bytes should be generated,
because otherwise there is potential for an input buffer overflow at
the receiving end of a \s-1UTF\-8\s0 connection.  Perl always generates the
shortest length \s-1UTF\-8\s0, and with warnings on Perl will warn about
non-shortest length \s-1UTF\-8\s0 along with other malformations, such as the
surrogates, which are not real Unicode code points.
.IP "\(bu" 4
Regular expressions behave slightly differently between byte data and
character (Unicode) data.  For example, the \*(L"word character\*(R" character
class \f(CW\*(C`\ew\*(C'\fR will work differently depending on if data is eight-bit bytes
or Unicode.
.Sp
In the first case, the set of \f(CW\*(C`\ew\*(C'\fR characters is either small\*(--the
default set of alphabetic characters, digits, and the \*(L"_\*(R"\-\-or, if you
are using a locale (see perllocale), the \f(CW\*(C`\ew\*(C'\fR might contain a few
more letters according to your language and country.
.Sp
In the second case, the \f(CW\*(C`\ew\*(C'\fR set of characters is much, much larger.
Most importantly, even in the set of the first 256 characters, it will
probably match different characters: unlike most locales, which are
specific to a language and country pair, Unicode classifies all the
characters that are letters \fIsomewhere\fR as \f(CW\*(C`\ew\*(C'\fR.  For example, your
locale might not think that \s-1LATIN\s0 \s-1SMALL\s0 \s-1LETTER\s0 \s-1ETH\s0 is a letter (unless
you happen to speak Icelandic), but Unicode does.
.Sp
As discussed elsewhere, Perl has one foot (two hooves?) planted in
each of two worlds: the old world of bytes and the new world of
characters, upgrading from bytes to characters when necessary.
If your legacy code does not explicitly use Unicode, no automatic
switch-over to characters should happen.  Characters shouldn't get
downgraded to bytes, either.  It is possible to accidentally mix bytes
and characters, however (see perluniintro), in which case \f(CW\*(C`\ew\*(C'\fR in
regular expressions might start behaving differently.  Review your
code.  Use warnings and the \f(CW\*(C`strict\*(C'\fR pragma.
.Sh "Unicode in Perl on \s-1EBCDIC\s0"
.IX Subsection "Unicode in Perl on EBCDIC"
The way Unicode is handled on \s-1EBCDIC\s0 platforms is still
experimental.  On such platforms, references to \s-1UTF\-8\s0 encoding in this
document and elsewhere should be read as meaning the UTF-EBCDIC
specified in Unicode Technical Report 16, unless \s-1ASCII\s0 vs. \s-1EBCDIC\s0 issues
are specifically discussed. There is no \f(CW\*(C`utfebcdic\*(C'\fR pragma or
\&\*(L":utfebcdic\*(R" layer; rather, \*(L"utf8\*(R" and \*(L":utf8\*(R" are reused to mean
the platform's \*(L"natural\*(R" 8\-bit encoding of Unicode. See perlebcdic
for more discussion of the issues.
.Sh "Locales"
.IX Subsection "Locales"
Usually locale settings and Unicode do not affect each other, but
there are a couple of exceptions:
.IP "\(bu" 4
If your locale environment variables (\s-1LANGUAGE\s0, \s-1LC_ALL\s0, \s-1LC_CTYPE\s0, \s-1LANG\s0)
contain the strings '\s-1UTF\-8\s0' or '\s-1UTF8\s0' (case\-insensitive matching),
the default encodings of your \s-1STDIN\s0, \s-1STDOUT\s0, and \s-1STDERR\s0, and of
\&\fBany subsequent file open\fR, are considered to be \s-1UTF\-8\s0.
.IP "\(bu" 4
Perl tries really hard to work both with Unicode and the old
byte-oriented world. Most often this is nice, but sometimes Perl's
straddling of the proverbial fence causes problems.
.Sh "Using Unicode in \s-1XS\s0"
.IX Subsection "Using Unicode in XS"
If you want to handle Perl Unicode in \s-1XS\s0 extensions, you may find
the following C APIs useful.  See perlapi for details.
.IP "\(bu" 4
\&\f(CW\*(C`DO_UTF8(sv)\*(C'\fR returns true if the \f(CW\*(C`UTF8\*(C'\fR flag is on and the bytes
pragma is not in effect.  \f(CW\*(C`SvUTF8(sv)\*(C'\fR returns true is the \f(CW\*(C`UTF8\*(C'\fR
flag is on; the bytes pragma is ignored.  The \f(CW\*(C`UTF8\*(C'\fR flag being on
does \fBnot\fR mean that there are any characters of code points greater
than 255 (or 127) in the scalar or that there are even any characters
in the scalar.  What the \f(CW\*(C`UTF8\*(C'\fR flag means is that the sequence of
octets in the representation of the scalar is the sequence of \s-1UTF\-8\s0
encoded code points of the characters of a string.  The \f(CW\*(C`UTF8\*(C'\fR flag
being off means that each octet in this representation encodes a
single character with code point 0..255 within the string.  Perl's
Unicode model is not to use \s-1UTF\-8\s0 until it is absolutely necessary.
.IP "\(bu" 4
\&\f(CW\*(C`uvuni_to_utf8(buf, chr\*(C'\fR) writes a Unicode character code point into
a buffer encoding the code point as \s-1UTF\-8\s0, and returns a pointer
pointing after the \s-1UTF\-8\s0 bytes.
.IP "\(bu" 4
\&\f(CW\*(C`utf8_to_uvuni(buf, lenp)\*(C'\fR reads \s-1UTF\-8\s0 encoded bytes from a buffer and
returns the Unicode character code point and, optionally, the length of
the \s-1UTF\-8\s0 byte sequence.
.IP "\(bu" 4
\&\f(CW\*(C`utf8_length(start, end)\*(C'\fR returns the length of the \s-1UTF\-8\s0 encoded buffer
in characters.  \f(CW\*(C`sv_len_utf8(sv)\*(C'\fR returns the length of the \s-1UTF\-8\s0 encoded
scalar.
.IP "\(bu" 4
\&\f(CW\*(C`sv_utf8_upgrade(sv)\*(C'\fR converts the string of the scalar to its \s-1UTF\-8\s0
encoded form.  \f(CW\*(C`sv_utf8_downgrade(sv)\*(C'\fR does the opposite, if
possible.  \f(CW\*(C`sv_utf8_encode(sv)\*(C'\fR is like sv_utf8_upgrade except that
it does not set the \f(CW\*(C`UTF8\*(C'\fR flag.  \f(CW\*(C`sv_utf8_decode()\*(C'\fR does the
opposite of \f(CW\*(C`sv_utf8_encode()\*(C'\fR.  Note that none of these are to be
used as general-purpose encoding or decoding interfaces: \f(CW\*(C`use Encode\*(C'\fR
for that.  \f(CW\*(C`sv_utf8_upgrade()\*(C'\fR is affected by the encoding pragma
but \f(CW\*(C`sv_utf8_downgrade()\*(C'\fR is not (since the encoding pragma is
designed to be a one-way street).
.IP "\(bu" 4
\&\f(CWis_utf8_char(s)\fR returns true if the pointer points to a valid \s-1UTF\-8\s0
character.
.IP "\(bu" 4
\&\f(CW\*(C`is_utf8_string(buf, len)\*(C'\fR returns true if \f(CW\*(C`len\*(C'\fR bytes of the buffer
are valid \s-1UTF\-8\s0.
.IP "\(bu" 4
\&\f(CW\*(C`UTF8SKIP(buf)\*(C'\fR will return the number of bytes in the \s-1UTF\-8\s0 encoded
character in the buffer.  \f(CW\*(C`UNISKIP(chr)\*(C'\fR will return the number of bytes
required to UTF\-8\-encode the Unicode character code point.  \f(CW\*(C`UTF8SKIP()\*(C'\fR
is useful for example for iterating over the characters of a \s-1UTF\-8\s0
encoded buffer; \f(CW\*(C`UNISKIP()\*(C'\fR is useful, for example, in computing
the size required for a \s-1UTF\-8\s0 encoded buffer.
.IP "\(bu" 4
\&\f(CW\*(C`utf8_distance(a, b)\*(C'\fR will tell the distance in characters between the
two pointers pointing to the same \s-1UTF\-8\s0 encoded buffer.
.IP "\(bu" 4
\&\f(CW\*(C`utf8_hop(s, off)\*(C'\fR will return a pointer to an \s-1UTF\-8\s0 encoded buffer
that is \f(CW\*(C`off\*(C'\fR (positive or negative) Unicode characters displaced
from the \s-1UTF\-8\s0 buffer \f(CW\*(C`s\*(C'\fR.  Be careful not to overstep the buffer:
\&\f(CW\*(C`utf8_hop()\*(C'\fR will merrily run off the end or the beginning of the
buffer if told to do so.
.IP "\(bu" 4
\&\f(CW\*(C`pv_uni_display(dsv, spv, len, pvlim, flags)\*(C'\fR and
\&\f(CW\*(C`sv_uni_display(dsv, ssv, pvlim, flags)\*(C'\fR are useful for debugging the
output of Unicode strings and scalars.  By default they are useful
only for debugging\*(--they display \fBall\fR characters as hexadecimal code
points\*(--but with the flags \f(CW\*(C`UNI_DISPLAY_ISPRINT\*(C'\fR,
\&\f(CW\*(C`UNI_DISPLAY_BACKSLASH\*(C'\fR, and \f(CW\*(C`UNI_DISPLAY_QQ\*(C'\fR you can make the
output more readable.
.IP "\(bu" 4
\&\f(CW\*(C`ibcmp_utf8(s1, pe1, u1, l1, u1, s2, pe2, l2, u2)\*(C'\fR can be used to
compare two strings case-insensitively in Unicode.  For case-sensitive
comparisons you can just use \f(CW\*(C`memEQ()\*(C'\fR and \f(CW\*(C`memNE()\*(C'\fR as usual.
.PP
For more information, see perlapi, and \fIutf8.c\fR and \fIutf8.h\fR
in the Perl source code distribution.
.SH "BUGS"
.IX Header "BUGS"
.Sh "Interaction with Locales"
.IX Subsection "Interaction with Locales"
Use of locales with Unicode data may lead to odd results.  Currently,
Perl attempts to attach 8\-bit locale info to characters in the range
0..255, but this technique is demonstrably incorrect for locales that
use characters above that range when mapped into Unicode.  Perl's
Unicode support will also tend to run slower.  Use of locales with
Unicode is discouraged.
.Sh "Interaction with Extensions"
.IX Subsection "Interaction with Extensions"
When Perl exchanges data with an extension, the extension should be
able to understand the \s-1UTF\-8\s0 flag and act accordingly. If the
extension doesn't know about the flag, it's likely that the extension
will return incorrectly-flagged data.
.PP
So if you're working with Unicode data, consult the documentation of
every module you're using if there are any issues with Unicode data
exchange. If the documentation does not talk about Unicode at all,
suspect the worst and probably look at the source to learn how the
module is implemented. Modules written completely in Perl shouldn't
cause problems. Modules that directly or indirectly access code written
in other programming languages are at risk.
.PP
For affected functions, the simple strategy to avoid data corruption is
to always make the encoding of the exchanged data explicit. Choose an
encoding that you know the extension can handle. Convert arguments passed
to the extensions to that encoding and convert results back from that
encoding. Write wrapper functions that do the conversions for you, so
you can later change the functions when the extension catches up.
.PP
To provide an example, let's say the popular Foo::Bar::escape_html
function doesn't deal with Unicode data yet. The wrapper function
would convert the argument to raw \s-1UTF\-8\s0 and convert the result back to
Perl's internal representation like so:
.PP
.Vb 5
\&    sub my_escape_html ($) {
\&      my($what) = shift;
\&      return unless defined $what;
\&      Encode::decode_utf8(Foo::Bar::escape_html(Encode::encode_utf8($what)));
\&    }
.Ve
.PP
Sometimes, when the extension does not convert data but just stores
and retrieves them, you will be in a position to use the otherwise
dangerous \fIEncode::_utf8_on()\fR function. Let's say the popular
\&\f(CW\*(C`Foo::Bar\*(C'\fR extension, written in C, provides a \f(CW\*(C`param\*(C'\fR method that
lets you store and retrieve data according to these prototypes:
.PP
.Vb 2
\&    $self->param($name, $value);            # set a scalar
\&    $value = $self->param($name);           # retrieve a scalar
.Ve
.PP
If it does not yet provide support for any encoding, one could write a
derived class with such a \f(CW\*(C`param\*(C'\fR method:
.PP
.Vb 12
\&    sub param {
\&      my($self,$name,$value) = @_;
\&      utf8::upgrade($name);     # make sure it is UTF-8 encoded
\&      if (defined $value)
\&        utf8::upgrade($value);  # make sure it is UTF-8 encoded
\&        return $self->SUPER::param($name,$value);
\&      } else {
\&        my $ret = $self->SUPER::param($name);
\&        Encode::_utf8_on($ret); # we know, it is UTF-8 encoded
\&        return $ret;
\&      }
\&    }
.Ve
.PP
Some extensions provide filters on data entry/exit points, such as
DB_File::filter_store_key and family. Look out for such filters in
the documentation of your extensions, they can make the transition to
Unicode data much easier.
.Sh "Speed"
.IX Subsection "Speed"
Some functions are slower when working on \s-1UTF\-8\s0 encoded strings than
on byte encoded strings.  All functions that need to hop over
characters such as \fIlength()\fR, \fIsubstr()\fR or \fIindex()\fR can work \fBmuch\fR
faster when the underlying data are byte\-encoded. Witness the
following benchmark:
.PP
.Vb 18
\&  % perl -e '
\&  use Benchmark;
\&  use strict;
\&  our $l = 10000;
\&  our $u = our $b = "x" x $l;
\&  substr($u,0,1) = "\ex{100}";
\&  timethese(-2,{
\&  LENGTH_B => q{ length($b) },
\&  LENGTH_U => q{ length($u) },
\&  SUBSTR_B => q{ substr($b, $l/4, $l/2) },
\&  SUBSTR_U => q{ substr($u, $l/4, $l/2) },
\&  });
\&  '
\&  Benchmark: running LENGTH_B, LENGTH_U, SUBSTR_B, SUBSTR_U for at least 2 CPU seconds...
\&    LENGTH_B:  2 wallclock secs ( 2.36 usr +  0.00 sys =  2.36 CPU) @ 5649983.05/s (n=13333960)
\&    LENGTH_U:  2 wallclock secs ( 2.11 usr +  0.00 sys =  2.11 CPU) @ 12155.45/s (n=25648)
\&    SUBSTR_B:  3 wallclock secs ( 2.16 usr +  0.00 sys =  2.16 CPU) @ 374480.09/s (n=808877)
\&    SUBSTR_U:  2 wallclock secs ( 2.11 usr +  0.00 sys =  2.11 CPU) @ 6791.00/s (n=14329)
.Ve
.PP
The numbers show an incredible slowness on long \s-1UTF\-8\s0 strings.  You
should carefully avoid using these functions in tight loops. If you
want to iterate over characters, the superior coding technique would
split the characters into an array instead of using substr, as the following
benchmark shows:
.PP
.Vb 18
\&  % perl -e '
\&  use Benchmark;
\&  use strict;
\&  our $l = 10000;
\&  our $u = our $b = "x" x $l;
\&  substr($u,0,1) = "\ex{100}";
\&  timethese(-5,{
\&  SPLIT_B => q{ for my $c (split //, $b){}  },
\&  SPLIT_U => q{ for my $c (split //, $u){}  },
\&  SUBSTR_B => q{ for my $i (0..length($b)-1){my $c = substr($b,$i,1);} },
\&  SUBSTR_U => q{ for my $i (0..length($u)-1){my $c = substr($u,$i,1);} },
\&  });
\&  '
\&  Benchmark: running SPLIT_B, SPLIT_U, SUBSTR_B, SUBSTR_U for at least 5 CPU seconds...
\&     SPLIT_B:  6 wallclock secs ( 5.29 usr +  0.00 sys =  5.29 CPU) @ 56.14/s (n=297)
\&     SPLIT_U:  5 wallclock secs ( 5.17 usr +  0.01 sys =  5.18 CPU) @ 55.21/s (n=286)
\&    SUBSTR_B:  5 wallclock secs ( 5.34 usr +  0.00 sys =  5.34 CPU) @ 123.22/s (n=658)
\&    SUBSTR_U:  7 wallclock secs ( 6.20 usr +  0.00 sys =  6.20 CPU) @  0.81/s (n=5)
.Ve
.PP
Even though the algorithm based on \f(CW\*(C`substr()\*(C'\fR is faster than
\&\f(CW\*(C`split()\*(C'\fR for byte-encoded data, it pales in comparison to the speed
of \f(CW\*(C`split()\*(C'\fR when used with \s-1UTF\-8\s0 data.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perluniintro, encoding, Encode, open, utf8, bytes,
perlretut, \*(L"${^WIDE_SYSTEM_CALLS}\*(R" in perlvar
