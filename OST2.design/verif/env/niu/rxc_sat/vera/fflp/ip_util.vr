// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T2 Processor File: ip_util.vr
// Copyright (C) 1995-2007 Sun Microsystems, Inc. All Rights Reserved
// 4150 Network Circle, Santa Clara, California 95054, U.S.A.
//
// * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. 
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; version 2 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
// 
// For the avoidance of doubt, and except that if any non-GPL license 
// choice is available it will apply instead, Sun elects to use only 
// the General Public License version 2 (GPLv2) at this time for any 
// software where a choice of GPL license versions is made 
// available with the language indicating that GPLv2 or any later version 
// may be used, or where a choice of which version of the GPL is applied is 
// otherwise unspecified. 
//
// Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara, 
// CA 95054 USA or visit www.sun.com if you need additional information or 
// have any questions. 
// 
// ========== Copyright Header End ============================================
#include <vera_defines.vrh>
#include "fflp_memory_map.vri"

#include "niu_mem.vrh"
#include "niu_mem.vrh"
#include "niu_rx_descp.vrh"

#include "pcg_defines.vri"
#include "pcg_types.vri"
//#include "pcg_classes.vrh"
#include "pack_db.vrh"
//#include "pack_db_tasks.vrh"
#include "flow_db.vrh"
#include "flow_db_tasks.vrh"
#include "pg_top_pp.vrh"
//#include "pcg_lib.vrh"
#include "pc_top_pp.vrh"

#include "cMesg.vrh"   

#include "mbox_class.vrh"
#include "get_mbox_id.vrh"
#include "xmac_util.vrh"
#include "bmac_util.vrh"
#include "pcs_util.vrh"
#include "xpcs_util.vrh"
#include "ip_ingress_classes.vrh"   // KH
#include "ip_ingress_db.vrh"        // KH

/*
class ip_util {
   //--- Shared variables for all sub-classes
   bit vlan_parity_error = 1'b0;
   static bit mem_mode;  //0 - intmem, 1 - extmem
   static bit ip_ib_path, ip_ht_path;
   integer index;
   static string  in_pkt_type;
   static string  out_pkt_type;
   setup_cam_ram_fcram_class setup_ip_db_cl;   // KH
bit         tuple_type = 0;  // =0(5tuple), =1(4tuple)
bit [11:0]  tcam_disc   = 12'h0;
bit [11:0]  tcam_tsel   = 12'hfff;
bit [11:0]  tcam_ipaddr = 12'h0;

   task new() { 
      if (get_plus_arg (CHECK, "NO_FFLP_DATABASE"))
        {
         be_msg_fflp.print(e_mesg_info, *, "ip_util::new()",
          "Skipping FFLP setup_ip_db_cl.\n");
        }
      else
        {
         be_msg_fflp.print(e_mesg_info, *, "ip_util::new()",
          "NEW setup_ip_db_cl.\n");

         setup_ip_db_cl = new();    // KH
        }
   }
}
*/

//================================================
//====== FFLP CAM, ZBTRAM, related ===============
//================================================


/*
extern hdl_task dump_cam_file(integer dump_file_num);
extern hdl_task dump_asdata(integer dump_file_num);
extern hdl_task force_cam_file(integer force_dump_file_num);
extern hdl_task force_asdata(integer force_dump_file_num);
*/
extern hdl_task force_vlan_tbl_entry (bit [15:0]mem_addr,bit [8:0] mem_ar_data);
//extern hdl_task force_vlan_tbl_entry_nep (bit [11:0]mem_addr,bit [17:0] mem_ar_data);

#ifndef NO_EXT_CAM_RAM
   extern hdl_task init_memory(bit [20:0] addr, bit [143:0] data);
   extern hdl_task force_cam_entry(integer tuple_type, bit [31:0] cam_addr, bit [199:0] cam_key, bit [199:0] cam_lmask);
   extern hdl_task force_asdata_entry(bit [31:0] cam_addr,bit [11:0] as_data_chksum,bit [31:0] as_adata0,bit [31:0] as_adata1,bit [31:0] as_adata2);
#endif 
//class setup_cam_ram_fcram_class extends ip_util {
class setup_cam_ram_fcram_class {

   event     init_master_test_done;
   bit [2:0] zcp_rdc_tbl_prog_mode;
   bit [4:0] zcp_dma_chnl;
   integer   zcp_rdc_tbl_index;
   integer   tcam_entries;
   bit [4:0] rd_zcp_dma_chnl;

   bit neptune_mode = 1'b0;
   bit [1:0] vlan_parity_error = 2'b00;
   static bit mem_mode;  //0 - intmem, 1 - extmem
   static bit ip_ib_path, ip_ht_path;
   integer index;
   static string  in_pkt_type;
   static string  out_pkt_type;
// setup_cam_ram_fcram_class setup_ip_db_cl;   // KH
   bit         tuple_type = 0;  // =0(5tuple), =1(4tuple)
   bit [11:0]  tcam_disc   = 12'h0;
   bit [11:0]  tcam_tsel   = 12'hfff;
   bit [11:0]  tcam_ipaddr = 12'h0;

   bit [11:0]  how_flow_iport   = 12'h0;
   bit [11:0]  how_flow_da_addr = 12'h0;
   bit [11:0]  how_flow_vlan    = 12'h0;
   bit [11:0]  how_flow_ipsrc   = 12'h0;
   bit [11:0]  how_flow_ipdst   = 12'h0;
   bit [11:0]  how_flow_pid     = 12'h0;
   bit [23:0]  how_flow_l40     = 24'h0;
   bit [23:0]  how_flow_l41     = 24'h0;

    integer i;
    integer pkt_cnt;
    bit [2:0]  l2_rdc_tbl_num [256];
    bit [199:0] shadow_cam_key [256];
    bit [199:0] shadow_cam_lmask [256];
    bit [63:0]  shadow_adata [256];

    bit [63:0]  shadow_fflp_how_tcam_key_cls_C;
    bit [63:0]  shadow_fflp_how_tcam_key_cls_D;
    bit [63:0]  shadow_fflp_how_tcam_key_cls_E;
    bit [63:0]  shadow_fflp_how_tcam_key_cls_F;

    bit [39:0]  fflp_reg_addr[8];

    integer random_value32;
    integer random_value5;
    integer random_value6;
    integer random_value7;
    integer random_value8;
    integer random_value10;
    integer random_value11;

    bit [4:0] shadow_zcp_table [256];
    bit       EXT_LOOKUP[8];

    Mesg be_msg_fflp;
    ip_db_cl   ip_db[];          // KH
    setup_ip_db_class setup_ip_db_cl;   // KH

    task new ();
    task setup_cam_ram();
    task setup_fcram();
    task program_fcram();
    function bit [11:0] as_data_chksum_val(bit [31:0] as_adata1, bit [31:0] as_adata2);
    function bit vcam_parity_bit (bit [7:0] data);
    task setup_ffl_registers();
    task program_vlan_table();
    function bit tcam_lookup (integer pkt_num,Cpkt_info packet_info);
    function bit [4:0] program_zcp_rdc_tbl (bit user_program,
                                            integer rdc_tbl_index, 
                                            bit [2:0] prog_mode, 
                                            bit [4:0] dma_chnl);
    function bit [2:0] get_l2_rdc_tbl_num (integer i);
//  function bit verify_vlan_tbl_parity (bit [11:0] hdr_vlan_id,
//                                       bit [17:0] ip_db_vt_vlan,
//                                       bit [17:0] rtl_vt_vlan);
    function bit [199:0] get_cam_lmask (integer cam_index, bit tuple_type, bit [19:0] cam_lmask_fields);
    task program_cam_ram_fcram();
    function bit [3:0] calculate_asdata_parity (integer i, bit [63:0] adata);
    function Cpkt_info construct_flow (integer pkt_num, bit [1:0] tcp_flag, (flow_desc flow_in = null));
local function bit [199:0] generate_pkt_cam_key(bit [2:0] predicted_l2_rdc_tbl_num, 
                                                Cpkt_info packet_info);
local function bit [1:0] verify_vlan_tbl_parity (bit [11:0] hdr_vlan_id,
                                                 bit [17:0] ip_db_vt_vlan,
                                                 bit [17:0] rtl_vt_vlan);
local function bit [2:0] predict_l2_rdc_tbl_num (integer pkt_num, Cpkt_info packet_info);
local function bit [7:0] select_tcam_match_rdc (integer index, integer pkt_num, 
                                                bit [2:0] predicted_l2_rdc_tbl_num, 
                                                bit [63:0] matched_as_data,
                                                Cpkt_info packet_info);
local function bit [3:0] calculate_parity (integer i,integer pkt_num,bit [63:0] matched_as_data);

local function bit [12:0] predict_zcp_dma_chnl_offset (integer pkt_num,
                                                    bit [2:0] mac_port,
                                                    Cpkt_info packet_info);
function bit [383:0] generate_flow_key (integer pkt_num, 
                                      //bit [2:0] predicted_l2_rdc_tbl_num, 
                                      //bit [63:0] matched_as_data, 
                                        Cpkt_info packet_info);
function bit [31:0] calculate_H1 (//integer index,
                                    integer pkt_num,
                                    bit [2:0] predicted_l2_rdc_tbl_num, 
                                  //bit [63:0] matched_as_data, 
                                    Cpkt_info packet_info);

local function bit ecc_err (integer pkt_num,
                            bit [199:0] packet_cam_key, 
                            bit [63:0] matched_as_data,
      	                    Cpkt_info packet_info);

local function bit check_ecc (bit [64:0] tcam_adata, 
			      bit [7:0] syndrome);
task prog_vlan_table(integer index, 
                     bit        parity0,
                     bit        vpr1,
                     bit [2:0]  vlan_tbln1,
                     bit        vpr0,
                     bit [2:0]  vlan_tbln0,
                     (bit        parity1 = 1'b0,
                      bit        vpr3 = 1'b0,
                      bit [2:0]  vlan_tbln3 = 3'h0,
                      bit        vpr2 = 1'b0,
                      bit [2:0]  vlan_tbln2 = 3'h0));
function bit [17:0] get_vlan_entry (integer index);
function bit [7:0] calculate_ecc_syndrome (bit [64:0] din);
task gen_pio_trans(bit [9:0] pio_trans_mode);

function bit [199:0] get_tcam_key(integer index);
function bit [63:0] get_assoc_data(integer index);

}

task setup_cam_ram_fcram_class :: new() {
 void = randomize();
 
   be_msg_fflp = new;
   random_value5 = random();
   random_value6 = random();
   random_value7 = random();
   random_value11 = random();
   random_value32 = random();

   #ifdef NEPTUNE
     neptune_mode = 1'b1;
   #endif

   EXT_LOOKUP[0] = 1'b0;
   EXT_LOOKUP[1] = 1'b0;
   EXT_LOOKUP[2] = 1'b0;
   EXT_LOOKUP[3] = 1'b0;
   EXT_LOOKUP[4] = 1'b0;
   EXT_LOOKUP[5] = 1'b0;
   EXT_LOOKUP[6] = 1'b0;
   EXT_LOOKUP[7] = 1'b0;

// fflp_reg_addr[0] = FFLP_ADDRESS_RANGE + FFLP_CONFIG; 
   fflp_reg_addr[0] = FFLP_ADDRESS_RANGE+FFLP_CAM_KEY_REG0;
   fflp_reg_addr[1] = FFLP_ADDRESS_RANGE+FFLP_CAM_KEY_REG1;
   fflp_reg_addr[2] = FFLP_ADDRESS_RANGE+FFLP_CAM_KEY_REG2;
   fflp_reg_addr[3] = FFLP_ADDRESS_RANGE+FFLP_CAM_KEY_REG3;
   fflp_reg_addr[4] = FFLP_ADDRESS_RANGE+FFLP_CAM_KEY_MASK_REG0;
   fflp_reg_addr[5] = FFLP_ADDRESS_RANGE+FFLP_CAM_KEY_MASK_REG1;
   fflp_reg_addr[6] = FFLP_ADDRESS_RANGE+FFLP_CAM_KEY_MASK_REG2;
   fflp_reg_addr[7] = FFLP_ADDRESS_RANGE+FFLP_CAM_KEY_MASK_REG3;

   
      if (get_plus_arg (CHECK, "NO_FFLP_DATABASE"))
        {
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::new()",
          "Skipping FFLP setup_ip_db_cl.\n");
        }
      else
        {
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::new()",
          "NEW setup_ip_db_cl.\n");

         setup_ip_db_cl = new();    // KH
        }

   if (get_plus_arg (CHECK, "RXMAC_PKTCNT="))
      {
       pkt_cnt = get_plus_arg (NUM, "RXMAC_PKTCNT=");

       if (get_plus_arg (CHECK, "TCAM_PARTIAL_PROG"))
         {
          if (pkt_cnt <= IP_DB_ENTRIES)
            {
             tcam_entries = pkt_cnt;
            }
          else
            {
             tcam_entries = IP_DB_ENTRIES;
            }
         }
       else
         {
          tcam_entries = IP_DB_ENTRIES;
         }
      }
   else
     {
      pkt_cnt = 256;
      tcam_entries = IP_DB_ENTRIES;
     }
}

task setup_cam_ram_fcram_class :: program_cam_ram_fcram()
{
 integer stat;
 bit [39:0]  addr;
 bit [63:0]  wr_data;
 bit [63:0]  rd_data = 64'h0;
 

be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_cam_ram_fcram()",
    "Calling init_mac_reg task to setup MAC Host Info and MAC HTable.\n");
   setup_ip_db_cl.init_mac_reg();

   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_cam_ram_fcram()",
    "Calling prog_prog_class7_4 task to setup programmable classes 7-4.\n");
   setup_ip_db_cl.prog_prog_class7_4();

   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_cam_ram_fcram()",
    "Calling prog_prog_class3_2 task to setup programmable classes 3-2.\n");
   setup_ip_db_cl.prog_prog_class3_2();

// be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_cam_ram_fcram()",
//  "Calling setup_fflp_arp_rarp_class task.\n");
// setup_ip_db_cl.setup_fflp_arp_rarp_class();

  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_cam_ram_fcram()",
   "Calling setup_cam_ram task to setup CAM RAM.\n");
  setup_cam_ram();

  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_cam_ram_fcram()",
   "Calling setup_fcram task to setup FCRAM.\n");
  setup_fcram();

  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  //@@ Perform last wr/rd pio transaction to make sure all   @@
  //@@ the PIOs for init/setup/programming are done before   @@
  //@@ sending packets.                                      @@
  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  addr = FFLP_ADDRESS_RANGE + FFLP_DBG_TRAIN_VCT;
  wr_data = 32'h1234_abcd;
  gen_pio_drv.pio_wr(addr, wr_data);
  while (rd_data[31:0] != 32'h1234_abcd)
    {
     gen_pio_drv.pio_rd(addr, rd_data, stat);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_cam_ram_fcram()",
      "INITIALIZATION OF THE BLOCKS IS DONE FOR FFLP MASTER TEST.\n");
    }

  repeat (200) @(posedge CLOCK);
  trigger (ON,init_master_test_done);

  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_cam_ram_fcram()",
   "READ DATA FROM FFLP_DBG_TRAIN_VCT = %h.\n",rd_data[31:0]);
}

task setup_cam_ram_fcram_class :: setup_cam_ram()
{
 integer i;
 bit         nop = 1'b0;
 bit [31:0]  ip_dst_addr;
 bit [31:0]  ip_src_addr;
 bit [127:0] ipv6_addr;
 bit [127:0] ipv6_dst_addr;
 bit [127:0] ipv6_src_addr;
 bit [15:0]  src_tcp_udp_port;
 bit [15:0]  dst_tcp_udp_port;
 bit [31:0]  spi;
 bit [7:0]   tos;
 bit [4:0]   pkt_class;
 bit [7:0]   pkt_protocol;
 bit [7:0]   pkt_next_hdr;
 bit [31:0]  cam_addr = 32'h0;

 bit         age;
 bit         curw_use;
 bit [6:0]   curw1;
 bit [6:0]   curw2;
 bit [14:0]  backlog;
 bit         skip_bmc;

 bit         drop_pkt;
 bit         zero_backlog_action;
 bit         path;
 bit [1:0]   path_encode;
 bit [1:0]   lmask_sel;
 bit         do_cs;
 bit [7:0]   qp1;
 bit [7:0]   qp0;
 bit         spawn;
 bit         lb_trigger;
 bit         lb_map;
 bit [1:0]   mode;
 bit [15:0]  trans_tbl_index;
 bit [15:0]  lb_grp_ptr_cam_index;
 bit [31:0]  as_adata0;
 bit [31:0]  as_adata1;
 bit [31:0]  as_adata2;
 bit [11:0]  as_data_chksum;

 bit [63:0]  adata;
 bit [199:0] cam_key;
 bit [199:0] cam_lmask;

 bit [31:0]  bmc_badd;
 bit [127:0] bmc_edata = 128'h0;
 bit [127:0] bmc_odata = 128'h0;
 bit [20:0]  ext_mem_addr;
 bit [143:0] ext_mem_data;
 bit compare = 1'b0;

 bit [5:0] dst_addr_prefix_index;

 bit [47:0]  l2_addr;
 bit [2:0]   mac_port;
 bit [7:0]   mac_addr_index;
 bit [7:0]   default_qp;
 bit         mode_bit;
 bit         local_cpu;
 bit         ph_bit;
 bit         m_bit;
 bit [39:0]  addr;
 bit [63:0]  wr_data;

 integer     dump_file_num = 0;
 integer     force_dump_file_num = 0;
 integer     vlan_entry_count = 0;
 integer     kk = 0;

 integer base_addr;
 shadow bit[47:0] mac_addr;
 bit [63:0] rd_data;
 bit [31:0] data;
 bit [15:0] syndrome;
 bit [3:0]  asdata_parity_value;

 bit [11:0] zfid;
 bit        v4_ecc_ck;
 bit        asdata_disc;
 bit [1:0]  tres;
 bit [4:0]  asdata_offset;
 bit [2:0]  asdata_rdctbl;
 bit        zfvld;
 bit        asdata_age;

 bit [199:0] mask_value, cam_value;
 bit [19:0]  cam_lmask_fields;
 bit [39:0] address;

 bit [4:0]  port0_dmc_default_dma;
 bit [4:0]  port1_dmc_default_dma;
 bit [4:0]  port2_dmc_default_dma;
 bit [4:0]  port3_dmc_default_dma;

 bit        user_program = 1'b0;
 bit [31:0]   h1_initial_value_reg = 32'h0;
 bit [31:0]   shtol_h1_poly_reg    = 32'h0;
 bit [32:0]   H1_CRC_32C_POLY_tmp  = 33'h0;

 bit [129:0]  adata_cam_key = 130'h0;
 bit [7:0]    ecc_syndrome_l = 8'h0;
 bit [7:0]    ecc_syndrome_h = 8'h0;

 bit          pkt_ipv4 = 1'b0;

  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  //@ Program TCAM(how to)key Registers (FZC_FFLP+0x20030)(count 12 step 8)
  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   if (get_plus_arg (CHECK, "TCAM_DISC_12HEX="))
     {
      tcam_disc = get_plus_arg( HNUM, "TCAM_DISC_12HEX=");
     } 
   else if (get_plus_arg (CHECK, "HOW_TCAM_ALL_DISCARD"))
     {
      tcam_disc = 12'hfff;
     } 
   else if (get_plus_arg (CHECK, "HOW_TCAM_RANDOM_DISCARD"))
     {
      tcam_disc = random_value5%12'hfff;

 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
  "IP_UTIL INFO: Random TCAM_DISC  bits = %h.\n",tcam_disc);
     } 
   else
     {
      tcam_disc = 12'h0;  // select all no discard
     }

   if (get_plus_arg (CHECK, "TCAM_TSEL_12HEX="))
     {
      tcam_tsel = get_plus_arg( HNUM, "TCAM_TSEL_12HEX=");

 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
   "SETUP_CAM_RAM INFO: RUNTIME ARGS FOR TCAM_TSEL = %h.\n",tcam_tsel);
     } 
   else if (get_plus_arg (CHECK, "HOW_TCAM_RANDOM_NOLOOKUP"))
     {
      tcam_tsel = random_value6%12'hfff;

 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
  "IP_UTIL INFO: Random TCAM_TSEL  bits = %h.\n",tcam_tsel);
     } 
   else if (get_plus_arg (CHECK, "HOW_TCAM_ALL_NOLOOKUP"))
     {
      tcam_tsel = 12'h0;
     } 
   else
     {
      tcam_tsel = 12'hfff;  // select all tcam lookup required
     }

   if (get_plus_arg (CHECK, "TCAM_IPADDR_12HEX="))
     {
      tcam_ipaddr = get_plus_arg( HNUM, "TCAM_IPADDR_12HEX=");
     } 
   else if (get_plus_arg (CHECK, "4TUPLE_IPSRC"))
     {
      tcam_ipaddr = 12'hfff; // Select all ip_src_addr
     } 
   else if (get_plus_arg (CHECK, "4TUPLE_IPDST"))
     {
      tcam_ipaddr = 12'h0; // Select all ip_dst_addr
     } 
   else if (get_plus_arg (CHECK, "4TUPLE_RANDOM_IPDST_IPDST"))
     {
      tcam_ipaddr = random_value7%12'hfff; // Select all random
     } 
   else
     {
      tcam_ipaddr = 12'h0; // Select all ip_dst_addr
     }

   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
     "Performing PIO Transactions to TCAM KEY how to Registers.\n");
   addr      = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_4;
   wr_data   = {60'h0,tcam_disc[0],tcam_tsel[0],1'b0,tcam_ipaddr[0]};
// gen_pio_drv.pio_wr(addr, wr_data);   
   fflp_util.fflp_pio_wrapper(addr, wr_data);   
   addr      = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_5;
   wr_data   = {60'h0,tcam_disc[1],tcam_tsel[1],1'b0,tcam_ipaddr[1]};
// gen_pio_drv.pio_wr(addr, wr_data);
   fflp_util.fflp_pio_wrapper(addr, wr_data);   
   addr      = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_6;
   wr_data   = {60'h0,tcam_disc[2],tcam_tsel[2],1'b0,tcam_ipaddr[2]};
// gen_pio_drv.pio_wr(addr, wr_data);
   fflp_util.fflp_pio_wrapper(addr, wr_data);   
   addr      = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_7;
   wr_data   = {60'h0,tcam_disc[3],tcam_tsel[3],1'b0,tcam_ipaddr[3]};
// gen_pio_drv.pio_wr(addr, wr_data);
   fflp_util.fflp_pio_wrapper(addr, wr_data);   
   addr      = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_8;
   wr_data   = {60'h0,tcam_disc[4],tcam_tsel[4],1'b0,tcam_ipaddr[4]};
// gen_pio_drv.pio_wr(addr, wr_data);
   fflp_util.fflp_pio_wrapper(addr, wr_data);   
   addr      = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_9;
   wr_data   = {60'h0,tcam_disc[5],tcam_tsel[5],1'b0,tcam_ipaddr[5]};
// gen_pio_drv.pio_wr(addr, wr_data);
   fflp_util.fflp_pio_wrapper(addr, wr_data);   
//           gen_pio_drv.pio_rd(addr, rd_data); 
//           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
//            "IP_UTIL INFO: READ VALUE FROM FFLP_HOW_TCAM_KEY_CLS_9 REG IS %h.\n",rd_data);
   addr      = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_A;
   wr_data   = {60'h0,tcam_disc[6],tcam_tsel[6],1'b0,tcam_ipaddr[6]};
// gen_pio_drv.pio_wr(addr, wr_data);
   fflp_util.fflp_pio_wrapper(addr, wr_data);   
   addr      = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_B;
   wr_data   = {60'h0,tcam_disc[7],tcam_tsel[7],1'b0,tcam_ipaddr[7]};
// gen_pio_drv.pio_wr(addr, wr_data);
   fflp_util.fflp_pio_wrapper(addr, wr_data);   
   addr      = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_C;
   wr_data   = {60'h0,tcam_disc[8],tcam_tsel[8],1'b0,tcam_ipaddr[8]};
// gen_pio_drv.pio_wr(addr, wr_data);
   fflp_util.fflp_pio_wrapper(addr, wr_data);   
   addr      = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_D;
   wr_data   = {60'h0,tcam_disc[9],tcam_tsel[9],1'b0,tcam_ipaddr[9]};
// gen_pio_drv.pio_wr(addr, wr_data);
   fflp_util.fflp_pio_wrapper(addr, wr_data);   
   addr      = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_E;
   wr_data   = {60'h0,tcam_disc[10],tcam_tsel[10],1'b0,tcam_ipaddr[10]};
// gen_pio_drv.pio_wr(addr, wr_data);
   fflp_util.fflp_pio_wrapper(addr, wr_data);   
   addr      = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_F;
   wr_data   = {60'h0,tcam_disc[11],tcam_tsel[11],1'b0,tcam_ipaddr[11]};
// gen_pio_drv.pio_wr(addr, wr_data);
   fflp_util.fflp_pio_wrapper(addr, wr_data);   

  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  //@ Program Initial HASH value                                              
  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

   if (get_plus_arg (CHECK, "HASH1_INITIAL_VALUE="))
     {
      h1_initial_value_reg = get_plus_arg( HNUM, "HASH1_INITIAL_VALUE=");

 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
   "IP_UTIL INFO: Writing HASH1_INITIAL_VALUE = %h to FFLP_FLOW_H1POLY reg.\n",h1_initial_value_reg);
     } 
   else if (get_plus_arg (CHECK, "RANDOM_HASH1_INITIAL_VALUE"))
     {
      h1_initial_value_reg = random_value32%32'hffff_ffff;

 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
   "IP_UTIL INFO: Writing RANDOM_HASH1_INITIAL_VALUE = %h to FFLP_FLOW_H1POLY reg.\n",h1_initial_value_reg);
     } 
   else // use default DEFAULT_HASH1_INITIAL_VALUE
     {
      h1_initial_value_reg = DEFAULT_HASH1_INITIAL_VALUE;

 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
   "IP_UTIL INFO: Writing DEFAULT_HASH1_INITIAL_VALUE = %h to FFLP_FLOW_H1POLY reg.\n",h1_initial_value_reg);
     } 

 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
   "IP_UTIL INFO: PROGRAMMING FFLP_FLOW_H1POLY WITH CALCULATED VALUE = %h.\n", h1_initial_value_reg);
   
   wr_data = {32'h0, h1_initial_value_reg};
   addr = FFLP_FLOW_ADDRESS_RANGE + FFLP_FLOW_H1POLY;
   fflp_util.fflp_pio_wrapper(addr, wr_data);
  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  //@ Program FLOW KEY(how to flow)Registers (FZC_FFLP+0x20030)(count 12 step 8)
  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   if (get_plus_arg (CHECK, "HOW_FLOW_IPORT_12HEX="))
     {
      how_flow_iport = get_plus_arg( HNUM, "HOW_FLOW_IPORT_12HEX=");
     } 
   else if (get_plus_arg (CHECK, "HOW_FLOW_RANDOM_IPORT"))
     {
      how_flow_iport = random_value5%12'hfff;

 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
   "IP_UTIL INFO: Random HOW FLOW IPORT bits = %h.\n",how_flow_iport);
     } 
   else
     {
      how_flow_iport = 12'hfff;  // consider all 12 input ports
     }

   if (get_plus_arg (CHECK, "HOW_FLOW_DA_12HEX="))
     {
      how_flow_da_addr = get_plus_arg( HNUM, "HOW_FLOW_DA_12HEX=");
     } 
   else if (get_plus_arg (CHECK, "HOW_FLOW_RANDOM_DA"))
     {
      how_flow_da_addr = random_value5%12'hfff;

 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
   "IP_UTIL INFO: Random HOW FLOW DA ADDR bits = %h.\n",how_flow_da_addr);
     } 
   else
     {
      how_flow_da_addr = 12'hfff;  // consider all L2 DA addresses
     }

   if (get_plus_arg (CHECK, "HOW_FLOW_VLAN_12HEX="))
     {
      how_flow_vlan = get_plus_arg( HNUM, "HOW_FLOW_VLAN_12HEX=");
     } 
   else if (get_plus_arg (CHECK, "HOW_FLOW_RANDOM_VLAN"))
     {
      how_flow_vlan = random_value5%12'hfff;

      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "IP_UTIL INFO: Random HOW FLOW VLAN bits = %h.\n",how_flow_vlan);
     } 
   else
     {
      how_flow_vlan = 12'hfff; // consider all vlan packets
     }

   if (get_plus_arg (CHECK, "HOW_FLOW_IPSRC_12HEX="))
     {
      how_flow_ipsrc = get_plus_arg( HNUM, "HOW_FLOW_IPSRC_12HEX=");
     } 
   else if (get_plus_arg (CHECK, "HOW_FLOW_RANDOM_IPSRC"))
     {
      how_flow_ipsrc = random_value5%12'hfff;

      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "IP_UTIL INFO: Random HOW FLOW IPSRC bits = %h.\n",how_flow_ipsrc);
     } 
   else
     {
      how_flow_ipsrc = 12'hfff; // consider all vlan packets
     }

   if (get_plus_arg (CHECK, "HOW_FLOW_IPDST_12HEX="))
     {
      how_flow_ipdst = get_plus_arg( HNUM, "HOW_FLOW_IPDST_12HEX=");
     } 
   else if (get_plus_arg (CHECK, "HOW_FLOW_RANDOM_IPDST"))
     {
      how_flow_ipdst = random_value5%12'hfff;

      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "IP_UTL INFO: Random HOW FLOW IPDST bits = %h.\n",how_flow_ipdst);
     } 
   else
     {
      how_flow_ipdst = 12'hfff; // consider all vlan packets
     }

   if (get_plus_arg (CHECK, "HOW_FLOW_PID_12HEX="))
     {
      how_flow_pid = get_plus_arg( HNUM, "HOW_FLOW_PID_12HEX=");
     } 
   else if (get_plus_arg (CHECK, "HOW_FLOW_RANDOM_PROTOCOL"))
     {
      how_flow_pid = random_value5%12'hfff;

      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "IP_UTIL INFO: Random HOW FLOW PROTOCOL bits = %h.\n",how_flow_pid);
     } 
   else
     {
      how_flow_pid = 12'hfff; // consider all vlan packets
     }

   if (get_plus_arg (CHECK, "HOW_FLOW_L40_24HEX="))
     {
      how_flow_l40 = get_plus_arg( HNUM, "HOW_FLOW_L40_24HEX=");
     } 
   else if (get_plus_arg (CHECK, "HOW_FLOW_RANDOM_L40"))
     {
      how_flow_l40 = random_value5%24'hff_fff;

      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "IP_UTIL INFO: Random HOW FLOW L4_0 bits = %h.\n",how_flow_l40);
     } 
   else if (get_plus_arg (CHECK, "HOW_FLOW_L40_B1_B2"))
     {
      how_flow_l40 = 24'haa_aaaa;
     } 
   else if (get_plus_arg (CHECK, "HOW_FLOW_L40_B5_B6"))
     {
      how_flow_l40 = 24'hff_ffff;
     } 
   else
     {
      how_flow_l40 = 24'h0a_0a00; // consider bytes 1 & 2 of L4 for L40
     }

   if (get_plus_arg (CHECK, "HOW_FLOW_L41_24HEX="))
     {
      how_flow_l41 = get_plus_arg( HNUM, "HOW_FLOW_L41_24HEX=");
     } 
   else if (get_plus_arg (CHECK, "HOW_FLOW_RANDOM_L41"))
     {
      how_flow_l41 = random_value5%24'hff_fff;

      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "IP_UTIL INFO: Random HOW FLOW L4_1 bits = %h.\n",how_flow_l41);
     } 
   else if (get_plus_arg (CHECK, "HOW_FLOW_L41_B3_B4"))
     {
      how_flow_l41 = 24'haa_aaaa;
     } 
   else if (get_plus_arg (CHECK, "HOW_FLOW_L41_B7_B8"))
     {
      how_flow_l41 = 24'hff_ffff;
     } 
   else
     {
      how_flow_l41 = 24'h0a_0a00; // consider bytes 3 & 4 of L4 for L41
     }

   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
     "Performing PIO Transactions to FLOW KEY how Registers.\n");
   addr      = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_4;
   wr_data   = {54'h0,
                how_flow_iport[0],
                how_flow_da_addr[0],
                how_flow_vlan[0],
                how_flow_ipsrc[0],
                how_flow_ipdst[0],
                how_flow_pid[0],
                how_flow_l40[1:0],
                how_flow_l41[1:0]};
// gen_pio_drv.pio_wr(addr, wr_data);   
   fflp_util.fflp_pio_wrapper(addr, wr_data);   

   addr      = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_5;
   wr_data   = {54'h0,
                how_flow_iport[1],
                how_flow_da_addr[1],
                how_flow_vlan[1],
                how_flow_ipsrc[1],
                how_flow_ipdst[1],
                how_flow_pid[1],
                how_flow_l40[3:2],
                how_flow_l41[3:2]};
// gen_pio_drv.pio_wr(addr, wr_data);   
   fflp_util.fflp_pio_wrapper(addr, wr_data);   

   addr      = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_6;
   wr_data   = {54'h0,
                how_flow_iport[2],
                how_flow_da_addr[2],
                how_flow_vlan[2],
                how_flow_ipsrc[2],
                how_flow_ipdst[2],
                how_flow_pid[2],
                how_flow_l40[5:4],
                how_flow_l41[5:4]};
// gen_pio_drv.pio_wr(addr, wr_data);   
   fflp_util.fflp_pio_wrapper(addr, wr_data);   

   addr      = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_7;
   wr_data   = {54'h0,
                how_flow_iport[3],
                how_flow_da_addr[3],
                how_flow_vlan[3],
                how_flow_ipsrc[3],
                how_flow_ipdst[3],
                how_flow_pid[3],
                how_flow_l40[7:6],
                how_flow_l41[7:6]};
// gen_pio_drv.pio_wr(addr, wr_data);   
   fflp_util.fflp_pio_wrapper(addr, wr_data);   

   addr      = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_8;
   wr_data   = {54'h0,
                how_flow_iport[4],
                how_flow_da_addr[4],
                how_flow_vlan[4],
                how_flow_ipsrc[4],
                how_flow_ipdst[4],
                how_flow_pid[4],
                how_flow_l40[9:8],
                how_flow_l41[9:8]};
// gen_pio_drv.pio_wr(addr, wr_data);   
   fflp_util.fflp_pio_wrapper(addr, wr_data);   

   addr      = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_9;
   wr_data   = {54'h0,
                how_flow_iport[5],
                how_flow_da_addr[5],
                how_flow_vlan[5],
                how_flow_ipsrc[5],
                how_flow_ipdst[5],
                how_flow_pid[5],
                how_flow_l40[11:10],
                how_flow_l41[11:10]};
// gen_pio_drv.pio_wr(addr, wr_data);   
   fflp_util.fflp_pio_wrapper(addr, wr_data);   

   addr      = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_A;
   wr_data   = {54'h0,
                how_flow_iport[6],
                how_flow_da_addr[6],
                how_flow_vlan[6],
                how_flow_ipsrc[6],
                how_flow_ipdst[6],
                how_flow_pid[6],
                how_flow_l40[13:12],
                how_flow_l41[13:12]};
// gen_pio_drv.pio_wr(addr, wr_data);   
   fflp_util.fflp_pio_wrapper(addr, wr_data);   

   addr      = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_B;
   wr_data   = {54'h0,
                how_flow_iport[7],
                how_flow_da_addr[7],
                how_flow_vlan[7],
                how_flow_ipsrc[7],
                how_flow_ipdst[7],
                how_flow_pid[7],
                how_flow_l40[15:14],
                how_flow_l41[15:14]};
// gen_pio_drv.pio_wr(addr, wr_data);   
   fflp_util.fflp_pio_wrapper(addr, wr_data);   

   addr      = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_C;
   wr_data   = {54'h0,
                how_flow_iport[8],
                how_flow_da_addr[8],
                how_flow_vlan[8],
                how_flow_ipsrc[8],
                how_flow_ipdst[8],
                how_flow_pid[8],
                how_flow_l40[17:16],
                how_flow_l41[17:16]};
// gen_pio_drv.pio_wr(addr, wr_data);   
   fflp_util.fflp_pio_wrapper(addr, wr_data);   

   addr      = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_D;
   wr_data   = {54'h0,
                how_flow_iport[9],
                how_flow_da_addr[9],
                how_flow_vlan[9],
                how_flow_ipsrc[9],
                how_flow_ipdst[9],
                how_flow_pid[9],
                how_flow_l40[19:18],
                how_flow_l41[19:18]};
// gen_pio_drv.pio_wr(addr, wr_data);   
   fflp_util.fflp_pio_wrapper(addr, wr_data);   

   addr      = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_E;
   wr_data   = {54'h0,
                how_flow_iport[10],
                how_flow_da_addr[10],
                how_flow_vlan[10],
                how_flow_ipsrc[10],
                how_flow_ipdst[10],
                how_flow_pid[10],
                how_flow_l40[21:20],
                how_flow_l41[21:20]};
// gen_pio_drv.pio_wr(addr, wr_data);   
   fflp_util.fflp_pio_wrapper(addr, wr_data);   

   addr      = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_F;
   wr_data   = {54'h0,
                how_flow_iport[11],
                how_flow_da_addr[11],
                how_flow_vlan[11],
                how_flow_ipsrc[11],
                how_flow_ipdst[11],
                how_flow_pid[11],
                how_flow_l40[23:22],
                how_flow_l41[23:22]};
// gen_pio_drv.pio_wr(addr, wr_data);   
   fflp_util.fflp_pio_wrapper(addr, wr_data);   

  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  //@ Program FLOW PARTITION SELECT REGISTERS     
  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  //@ Program VLAN TABLE (4096 Entries)           
  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
if (get_plus_arg (CHECK, "DONT_PROGRAM_VLAN_TBL"))
  {
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
    "IP_UTIL INFO: Skip programming VLAN Table.\n");
  }
else
  {
   program_vlan_table();   
  }
  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  //@ Program ZCP RDC TABLE
  //@ Tables 0-7 (32 entries per table)
  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@ Program RDMC Deafault DMA Channel per port Registers           @@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   if (get_plus_arg (CHECK, "PORT0_ZCP_DEFAULT_DMA="))
      {
       port0_dmc_default_dma = get_plus_arg (NUM, "PORT0_ZCP_DEFAULT_DMA=");
      }
   else 
      {
       port0_dmc_default_dma = 5'h4;
      }
   if (get_plus_arg (CHECK, "PORT1_ZCP_DEFAULT_DMA="))
      {
       port1_dmc_default_dma = get_plus_arg (NUM, "PORT1_ZCP_DEFAULT_DMA=");
      }
   else 
      {
       port1_dmc_default_dma = 5'h5;
      }
   if (get_plus_arg (CHECK, "PORT2_ZCP_DEFAULT_DMA="))
      {
       port2_dmc_default_dma = get_plus_arg (NUM, "PORT2_ZCP_DEFAULT_DMA=");
      }
   else 
      {
       port2_dmc_default_dma = 5'h6;
      }
   if (get_plus_arg (CHECK, "PORT3_ZCP_DEFAULT_DMA="))
      {
       port3_dmc_default_dma = get_plus_arg (NUM, "PORT3_ZCP_DEFAULT_DMA=");
      }
   else 
      {
       port3_dmc_default_dma = 5'h7;
      }
    address = RDC_DEF_PT0_RDC;
    wr_data = {59'h0,port0_dmc_default_dma};
//  gen_pio_drv.pio_wr(address,wr_data);
    fflp_util.fflp_pio_wrapper(addr, wr_data);   

    address = RDC_DEF_PT1_RDC;
    wr_data = {59'h0,port1_dmc_default_dma};
//  gen_pio_drv.pio_wr(address,wr_data);
    fflp_util.fflp_pio_wrapper(addr, wr_data);   

    address = RDC_DEF_PT2_RDC;
    wr_data = {59'h0,port2_dmc_default_dma};
//  gen_pio_drv.pio_wr(address,wr_data);
    fflp_util.fflp_pio_wrapper(addr, wr_data);   

    address = RDC_DEF_PT3_RDC;
    wr_data = {59'h0,port3_dmc_default_dma};
//  gen_pio_drv.pio_wr(address,wr_data);
    fflp_util.fflp_pio_wrapper(addr, wr_data);   
/*
    gen_pio_drv.pio_rd(RDC_DEF_PT0_RDC, rd_data); 
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
     "IP_UTIL INFO: READ VALUE FOR DEFAULT REG. RDC_DEF_PT0_RDC IS %h.\n",rd_data);
    gen_pio_drv.pio_rd(RDC_DEF_PT1_RDC, rd_data); 
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
     "IP_UTIL INFO: READ VALUE FOR DEFAULT REG. RDC_DEF_PT1_RDC IS %h.\n",rd_data);
    gen_pio_drv.pio_rd(RDC_DEF_PT2_RDC, rd_data); 
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
     "IP_UTIL INFO: READ VALUE FOR DEFAULT REG. RDC_DEF_PT2_RDC IS %h.\n",rd_data);
    gen_pio_drv.pio_rd(RDC_DEF_PT3_RDC, rd_data); 
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
     "IP_UTIL INFO: READ VALUE FOR DEFAULT REG. RDC_DEF_PT3_RDC IS %h.\n",rd_data);
*/
   if (get_plus_arg (CHECK, "USER_PROGRAM_ZCP_RDC_TBL"))
     {
      user_program = 1'b1;
     }
   else
     {
      user_program = 1'b0;    
     }
     
   if (get_plus_arg (CHECK, "ZCP_RDC_TBL_PROG_MODE="))
     {
      zcp_rdc_tbl_prog_mode = get_plus_arg (HNUM, "ZCP_RDC_TBL_PROG_MODE=");
      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
       "IP_UTIL INFO: DETECTED RUN_ARGS FOR ZCP_RDC_TBL_PROG_MODE = %h.\n",zcp_rdc_tbl_prog_mode);
     }
   else
     {
      zcp_rdc_tbl_prog_mode = 3'b101;
      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
       "IP_UTIL INFO: USING DEFAULT VALUE OF ZCP_RDC_TBL_PROG_MODE = %h.\n",zcp_rdc_tbl_prog_mode);
     }
   
   if (get_plus_arg (CHECK, "ZCP_RDC_TBL_INDEX="))
     {
      zcp_rdc_tbl_index = get_plus_arg (NUM, "ZCP_RDC_TBL_INDEX=");
     }
   else
     {
      zcp_rdc_tbl_index = 0;
     }
   
   if (get_plus_arg (CHECK, "ZCP_DMA_CHNL="))
     {
      zcp_dma_chnl = get_plus_arg (HNUM, "ZCP_DMA_CHNL=");
     }
   else
     {
      zcp_dma_chnl = 5'b0000;
     }

   rd_zcp_dma_chnl = program_zcp_rdc_tbl (user_program,zcp_rdc_tbl_index, zcp_rdc_tbl_prog_mode,zcp_dma_chnl);   
 
  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  //@ Initialize CAM (256 Entries)                
  //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
if (get_plus_arg (CHECK, "INIT_CAM_RAM"))
 {
  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
    "Performing PIO Transactions to intialize CAM.\n");
  fflp_util.init_cam_entries();
 }
else
 {
  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
    "Skip Initializing CAM_RAM..\n");
 }


if (get_plus_arg (CHECK, "DONT_PROGRAM_CAM_RAM"))
 {
  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::new()",
   "No CAM Match Mode, Skip Programming CAM_RAM in FFLP.\n");
 }
else
 {  
  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::new()",
   "Programming CAM_RAM in FFLP.\n");
//  for (i=0;i<pkt_cnt;i++)    
//for (i=0;i<IP_DB_ENTRIES;i++)    
for (i=0;i<tcam_entries;i++)    
   {
     //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     //@ Get the data from the ip_db to prepare cam144 key             @
     //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
      "SETTING UP CAM,RAM from the ip_db[%d] database.\n",i);

     nop      = setup_ip_db_cl.ip_db[i].ip_cam.nop;                 // This is setup in ip_ingress_db.vr

     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
      "IP_UTIL INFO: SETUP_IP_CL.IPDB[%d].ip_frame.frame_class = %d.\n",i,setup_ip_db_cl.ip_db[i].ip_frame.frame_class);

     if (setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_TCP        ||
         setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_UDP        ||
         setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_IP_SEC_AH  ||
         setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_IP_SEC_ESP ||
         setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_ARP        ||
         setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_RARP       ||
         setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_TCP_FRAG   ||
         setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_UDP_FRAG)
         
       {
        tuple_type = 0; // 5tuple
       }
     else
       {
        tuple_type = 1; // 4tuple
       }

//   if (get_plus_arg (CHECK, "PROMISCUOUS_MODE"))
//     {
//      mac_addr_index = 8'h00;
//      ph_bit         = 1'b0;
//     }
//   else
//     {
//      mac_addr_index   = ip_db[i].ip_mac.mac_addr_index;
//      ph_bit           = ip_db[i].ip_mac.ph_bit;
//     }

  if (get_plus_arg (CHECK, "NO_CAM_MATCH"))
    {
     mac_port         = setup_ip_db_cl.ip_db[i].ip_mac.mac_port;
     ip_dst_addr      = setup_ip_db_cl.ip_db[i].ip_dst_node.ip_addr * (i+2);
     ip_src_addr      = setup_ip_db_cl.ip_db[i].ip_src_node.ip_addr * (i+2);
     ipv6_dst_addr    = setup_ip_db_cl.ip_db[i].ip_dst_node.ipv6_addr * (i+2);
     ipv6_src_addr    = setup_ip_db_cl.ip_db[i].ip_src_node.ipv6_addr * (i+2);
     src_tcp_udp_port = setup_ip_db_cl.ip_db[i].ip_tup.src_tcp_udp_port * (i+2);
     dst_tcp_udp_port = setup_ip_db_cl.ip_db[i].ip_tup.dst_tcp_udp_port * (i+2);
     tos              = setup_ip_db_cl.ip_db[i].ip_src_node.tos * (i+2);
     spi              = setup_ip_db_cl.ip_db[i].ip_src_node.spi * (i+2);
    }
  else 
    {
     mac_port         = setup_ip_db_cl.ip_db[i].ip_mac.mac_port;
     ip_dst_addr      = setup_ip_db_cl.ip_db[i].ip_dst_node.ip_addr;
     ip_src_addr      = setup_ip_db_cl.ip_db[i].ip_src_node.ip_addr;
     ipv6_dst_addr    = setup_ip_db_cl.ip_db[i].ip_dst_node.ipv6_addr;
     ipv6_src_addr    = setup_ip_db_cl.ip_db[i].ip_src_node.ipv6_addr;
     src_tcp_udp_port = setup_ip_db_cl.ip_db[i].ip_tup.src_tcp_udp_port;
     dst_tcp_udp_port = setup_ip_db_cl.ip_db[i].ip_tup.dst_tcp_udp_port;
     tos              = setup_ip_db_cl.ip_db[i].ip_src_node.tos;
     spi              = setup_ip_db_cl.ip_db[i].ip_src_node.spi;
    }
 
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "FOR IP_DB[%d], MAC_ADDR_INDEX = %h.\n",i,mac_addr_index);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "FOR IP_DB[%d], MAC_PORT = %h.\n",i,mac_port);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "FOR IP_DB[%d], PH_BIT = %h.\n",i,ph_bit);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "FOR IP_DB[%d], IP_DST_ADDR = %h.\n",i,ip_dst_addr);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "FOR IP_DB[%d], IP_SRC_ADDR = %h.\n",i,ip_src_addr);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "FOR IP_DB[%d], SRC_TCP_UDP_PORT = %h.\n",i,src_tcp_udp_port);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "FOR IP_DB[%d], DST_TCP_UDP_PORT = %h.\n",i,dst_tcp_udp_port);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "FOR IP_DB[%d], SPI = %h.\n",i,spi);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "FOR IP_DB[%d], FRAME_TYPE = %h.\n",i,setup_ip_db_cl.ip_db[i].ip_frame.frame_type);

     //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     //@@ Getculate the final L2_RDC_TBL_NUM @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     l2_rdc_tbl_num[i] = get_l2_rdc_tbl_num(i); 

     //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     //@@ Generate the CAM Keys for 256 CAM Entries @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     if ((setup_ip_db_cl.ip_db[i].ip_frame.frame_type =?= 5'bx0x1x) && 
         (tuple_type === 1'b0))  // 5tuple type
       {
        case (setup_ip_db_cl.ip_db[i].ip_frame.frame_class)
         {
          CL_TCP:{
                  pkt_ipv4 = 1'b1;
                  if (setup_ip_db_cl.ip_db[i].prog_class7_4_matched)
                    {
                     pkt_class = setup_ip_db_cl.ip_db[i].pkt_class;
                    }
                  else
                    {
                     pkt_class = CLASS_8;
                     setup_ip_db_cl.ip_db[i].pkt_class = CLASS_8;
                    }
                  pkt_protocol = PROTOCOL_TCP;
                 }  
          CL_TCP_FRAG:{
                  pkt_ipv4 = 1'b1;
                  if (setup_ip_db_cl.ip_db[i].prog_class7_4_matched)
                    {
                     pkt_class = setup_ip_db_cl.ip_db[i].pkt_class;
                    }
                  else
                    {
//NEW                pkt_class = CLASS_0;
//NEW                setup_ip_db_cl.ip_db[i].pkt_class = CLASS_0;
                     pkt_class = CLASS_8;
                     setup_ip_db_cl.ip_db[i].pkt_class = CLASS_8;
                    }
                  pkt_protocol = PROTOCOL_TCP;
                 }  
          CL_UDP:{
                  pkt_ipv4 = 1'b1;
                  if (setup_ip_db_cl.ip_db[i].prog_class7_4_matched)
                    {
                     pkt_class = setup_ip_db_cl.ip_db[i].pkt_class;
                    }
                  else
                    {
                     pkt_class = CLASS_9;
                     setup_ip_db_cl.ip_db[i].pkt_class = CLASS_9;
                    }
                  pkt_protocol = PROTOCOL_UDP;
                 }  
          CL_UDP_FRAG:{
                  pkt_ipv4 = 1'b1;
                  if (setup_ip_db_cl.ip_db[i].prog_class7_4_matched)
                    {
                     pkt_class = setup_ip_db_cl.ip_db[i].pkt_class;
                    }
                  else
                    {
//NEW                pkt_class = CLASS_0;
//NEW                setup_ip_db_cl.ip_db[i].pkt_class = CLASS_0;
                     pkt_class = CLASS_9;
                     setup_ip_db_cl.ip_db[i].pkt_class = CLASS_9;
                    }
                  pkt_protocol = PROTOCOL_UDP;
                 }  
          CL_IP_SEC_AH:
                 {
                  pkt_ipv4 = 1'b1;
                  pkt_class = CLASS_10;
                  pkt_protocol = PROTOCOL_IPSEC_AH;
                  src_tcp_udp_port = spi[31:16];
                  dst_tcp_udp_port = spi[15:0];
                  setup_ip_db_cl.ip_db[i].pkt_class = CLASS_10;
                 }  
          CL_IP_SEC_ESP:
                 {
                  pkt_ipv4 = 1'b1;
                  pkt_class = CLASS_10;
                  pkt_protocol = PROTOCOL_IPSEC_ESP;
                  src_tcp_udp_port = spi[31:16];
                  dst_tcp_udp_port = spi[15:0];
                  setup_ip_db_cl.ip_db[i].pkt_class = CLASS_10;
                 }  
/*
          CL_SCTP_IP_V4:
                 {
                  pkt_ipv4 = 1'b1;
                  pkt_class    = CLASS_11;
                  pkt_protocol = PROTOCOL_SCTP;
                  setup_ip_db_cl.ip_db[i].pkt_class = CLASS_11;
                 }  
*/
          CL_ARP:
                 {
                  pkt_ipv4 = 1'b0;
                  if (setup_ip_db_cl.ip_db[i].prog_class3_2_matched)
                    {
                     pkt_class = setup_ip_db_cl.ip_db[i].pkt_class;
                    }
                  else
                    {
                     pkt_class = CLASS_16;
                     setup_ip_db_cl.ip_db[i].pkt_class = CLASS_16;
                    }
//                pkt_class    = CLASS_16;
                  pkt_protocol = 8'h0;
                  src_tcp_udp_port = 16'h0;
                  dst_tcp_udp_port = 16'h0;
                  ip_src_addr = 32'h0;
                  ip_dst_addr = 32'h0;
                 }  
          CL_RARP:
                 {
                  pkt_ipv4 = 1'b0;
                  if (setup_ip_db_cl.ip_db[i].prog_class3_2_matched)
                    {
                     pkt_class = setup_ip_db_cl.ip_db[i].pkt_class;
                    }
                  else
                    {
                     pkt_class = CLASS_17;
                     setup_ip_db_cl.ip_db[i].pkt_class = CLASS_17;
                    }
//                pkt_class    = CLASS_17;
                  pkt_protocol = 8'h0;
                  src_tcp_udp_port = 16'h0;
                  dst_tcp_udp_port = 16'h0;
                  ip_src_addr = 32'h0;
                  ip_dst_addr = 32'h0;
                 }  
          default:
                 {
                  be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
                    "FOR IP_DB[%d], Unknown 5tuple frame_class %d detected.\n",i,setup_ip_db_cl.ip_db[i].ip_frame.frame_class);
                 }  
         }
        cam_key = {pkt_class,
                   3'b000,
                   {2'b00,l2_rdc_tbl_num[i]},
                   nop,
                   74'h0,
                   tos,
                   pkt_protocol,
                   src_tcp_udp_port,
                   dst_tcp_udp_port,
                   ip_src_addr,
                   ip_dst_addr};

        if (get_plus_arg(CHECK, "MASK_TCAM_FIELDS="))
          {
           if ((setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_ARP)	||
               (setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_RARP))
             {
              cam_lmask = CAM_COMP_ONLY_CLS_CODE;
              be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
                "FOR IP_DB[%d],A4 CAM_LMASK = %h.\n",i,cam_lmask);
             }
           else
             {
              cam_lmask_fields = get_plus_arg(HNUM, "MASK_TCAM_FIELDS=");
              cam_lmask = get_cam_lmask (i,tuple_type, cam_lmask_fields);
              be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
                "FOR IP_DB[%d],B4 CAM_LMASK = %h.\n",i,cam_lmask);
             }
          }
        else
          {
           if ((setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_ARP)	||
               (setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_RARP))
             {
              cam_lmask = CAM_COMP_ONLY_CLS_CODE;
              be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
                "FOR IP_DB[%d],C4 CAM_LMASK = %h.\n",i,cam_lmask);
             }
           else
             {
              cam_lmask = CAM_NO_LMASK;
              be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
                "FOR IP_DB[%d],D4 CAM_LMASK = %h.\n",i,cam_lmask);
             }
          }
     
        if (setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_TCP_FRAG       ||
            setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_UDP_FRAG       ||
            setup_ip_db_cl.ip_db[i].ip_frame.frame_class === CL_IP_FRAG)
          {
           cam_lmask = CAM_LMASK_FRAGMENT_PKTS;
           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
             "FOR IP_DB[%d],E4 CAM_LMASK = %h.\n",i,cam_lmask);
          }
        else
          {
           // no change
          }

        be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
          "FOR IP_DB[%d], WROTE 5TUPLE CAM KEY pkt_class = %h.\n",i,pkt_class);
        be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
          "FOR IP_DB[%d], WROTE 5TUPLE CAM KEY l2_rdc_tbl_num = %h.\n",i,l2_rdc_tbl_num[i]);
        be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
          "FOR IP_DB[%d], WROTE 5TUPLE CAM KEY nop = %h.\n",i,nop);
        be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
          "FOR IP_DB[%d], WROTE 5TUPLE CAM KEY tos = %h.\n",i,tos);
        be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
          "FOR IP_DB[%d], WROTE 5TUPLE CAM KEY pkt_protocol = %h.\n",i,pkt_protocol);
        be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
          "FOR IP_DB[%d], WROTE 5TUPLE CAM KEY src_tcp_udp_port = %h.\n",i,src_tcp_udp_port);
        be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
          "FOR IP_DB[%d], WROTE 5TUPLE CAM KEY dst_tcp_udp_port = %h.\n",i,dst_tcp_udp_port);
        be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
          "FOR IP_DB[%d], WROTE 5TUPLE CAM KEY ip_src_addr = %h.\n",i,ip_src_addr);
        be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
          "FOR IP_DB[%d], WROTE 5TUPLE CAM KEY ip_dst_addr = %h.\n",i,ip_dst_addr);

        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
          "FOR IP_DB[%d], WRINTING 5TUPLE CAM KEY = %h, CAM LMASK = %h.\n",i,cam_key,cam_lmask);
       }
     else if ((setup_ip_db_cl.ip_db[i].ip_frame.frame_type =?= 5'bx1x1x) && 
         (tuple_type === 1'b1))  // 4tuple type
       {
        case (setup_ip_db_cl.ip_db[i].ip_frame.frame_class)
         {
          CL_TCP_IP_V6:{
                  if (setup_ip_db_cl.ip_db[i].prog_class7_4_matched)
                    {
                     pkt_class = setup_ip_db_cl.ip_db[i].pkt_class;
                    }
                  else
                    {
                     pkt_class = CLASS_12;
                     setup_ip_db_cl.ip_db[i].pkt_class = CLASS_12;
                    }
                  pkt_next_hdr = PROTOCOL_TCP;
                  //@@@@ READ SHADOW OF addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_C;
                  shadow_fflp_how_tcam_key_cls_C = fflp_util.fflp_how_tcam_key_cls_C;
                  setup_ip_db_cl.ip_db[0].ip_cam.shadow_fflp_how_tcam_key_cls_C = fflp_util.fflp_how_tcam_key_cls_C;
                  if (shadow_fflp_how_tcam_key_cls_C[0] === 1'b0)
                    {
                     ipv6_addr = ipv6_dst_addr;                      }
                  else
                    {
                     ipv6_addr = ipv6_src_addr;                      }
                 }  
          CL_UDP_IP_V6:{
                  if (setup_ip_db_cl.ip_db[i].prog_class7_4_matched)
                    {
                     pkt_class = setup_ip_db_cl.ip_db[i].pkt_class;
                    }
                  else
                    {
                     pkt_class = CLASS_13;
                     setup_ip_db_cl.ip_db[i].pkt_class = CLASS_13;
                    }
                  pkt_next_hdr = PROTOCOL_UDP;
                  //@@@@ READ SHADOW OF addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_D;
                  shadow_fflp_how_tcam_key_cls_D = fflp_util.fflp_how_tcam_key_cls_D;
                  setup_ip_db_cl.ip_db[0].ip_cam.shadow_fflp_how_tcam_key_cls_D = fflp_util.fflp_how_tcam_key_cls_D;
                  if (shadow_fflp_how_tcam_key_cls_D[0] === 1'b0)
                    {
                     ipv6_addr = ipv6_dst_addr;                      }
                  else
                    {
                     ipv6_addr = ipv6_src_addr;                      }
                 }  
          CL_IP_V6_SEC_AH:
                 {
                  pkt_class = CLASS_14;
                  setup_ip_db_cl.ip_db[i].pkt_class = CLASS_14;
                  pkt_next_hdr = PROTOCOL_IPSEC_AH;
                  src_tcp_udp_port = spi[31:16];
                  dst_tcp_udp_port = spi[15:0];
                  //@@@@ READ SHADOW OF addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_E;
                  shadow_fflp_how_tcam_key_cls_E = fflp_util.fflp_how_tcam_key_cls_E;
                  setup_ip_db_cl.ip_db[0].ip_cam.shadow_fflp_how_tcam_key_cls_E = fflp_util.fflp_how_tcam_key_cls_E;
                  if (shadow_fflp_how_tcam_key_cls_E[0] === 1'b0)
                    {
                     ipv6_addr = ipv6_dst_addr;                      }
                  else
                    {
                     ipv6_addr = ipv6_src_addr;                      }
                 }  
          CL_IP_V6_SEC_ESP:
                 {
                  pkt_class = CLASS_14;
                  setup_ip_db_cl.ip_db[i].pkt_class = CLASS_14;
                  pkt_next_hdr = PROTOCOL_IPSEC_ESP;
                  src_tcp_udp_port = spi[31:16];
                  dst_tcp_udp_port = spi[15:0];
                  //@@@@ READ SHADOW OF addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_E;
                  shadow_fflp_how_tcam_key_cls_E = fflp_util.fflp_how_tcam_key_cls_E;
                  setup_ip_db_cl.ip_db[0].ip_cam.shadow_fflp_how_tcam_key_cls_E = fflp_util.fflp_how_tcam_key_cls_E;
                  if (shadow_fflp_how_tcam_key_cls_E[0] === 1'b0)
                    {
                     ipv6_addr = ipv6_dst_addr;                      }
                  else
                    {
                     ipv6_addr = ipv6_src_addr;                      }
                 }  
/*
          CL_SCTP_IP_V6:
                 {
                  pkt_class    = CLASS_15;
                  setup_ip_db_cl.ip_db[i].pkt_class = CLASS_15;
                  pkt_next_hdr = PROTOCOL_SCTP;
                  //@@@@ READ SHADOW OF addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_F;
                  shadow_fflp_how_tcam_key_cls_F = fflp_util.fflp_how_tcam_key_cls_F;
                  setup_ip_db_cl.ip_db[0].ip_cam.shadow_fflp_how_tcam_key_cls_F = fflp_util.fflp_how_tcam_key_cls_F;
                  if (shadow_fflp_how_tcam_key_cls_F[0] === 1'b0)
                    {
                     ipv6_addr = ipv6_dst_addr;                      }
                  else
                    {
                     ipv6_addr = ipv6_src_addr;                      }
                 }  
*/
          default:
                 {
                  be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
                    "FOR IP_DB[%d], Unknown 4tuple frame_class %d detected.\n",i,setup_ip_db_cl.ip_db[i].ip_frame.frame_class);
                 }  
         }
        cam_key = {pkt_class,
                   3'b000,
                   {2'b00,l2_rdc_tbl_num[i]},
                   nop,
                   10'h0,
                   tos,
                   pkt_next_hdr,
                   src_tcp_udp_port,
                   dst_tcp_udp_port,
                   ipv6_addr};


        if (get_plus_arg(CHECK, "MASK_TCAM_FIELDS="))
          {
           cam_lmask_fields = get_plus_arg(HNUM, "MASK_TCAM_FIELDS=");

           cam_lmask = get_cam_lmask (i, tuple_type, cam_lmask_fields);
           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
             "FOR IP_DB[%d],A6 CAM_LMASK = %h.\n",i,cam_lmask);
          }
        else
          {
           cam_lmask = CAM_NO_LMASK;
           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
             "FOR IP_DB[%d],B6 CAM_LMASK = %h.\n",i,cam_lmask);
          }
     
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
          "FOR IP_DB[%d], WRITING 4TUPLE CAM KEY = %h, CAM LMASK = %h.\n",i,cam_key,cam_lmask);
       }

   //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   //@ Generate the AS_DATA for the 256 CAM Entries                    @
   //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   syndrome           = setup_ip_db_cl.ip_db[i].ip_asdata.syndrome;  
   zfid               = setup_ip_db_cl.ip_db[i].ip_asdata.zfid;
   v4_ecc_ck          = setup_ip_db_cl.ip_db[i].ip_asdata.v4_ecc_ck;
   asdata_disc        = setup_ip_db_cl.ip_db[i].ip_asdata.disc;
   tres               = setup_ip_db_cl.ip_db[i].ip_asdata.tres;
   asdata_rdctbl      = setup_ip_db_cl.ip_db[i].ip_asdata.rdctbl;
   asdata_offset      = setup_ip_db_cl.ip_db[i].ip_asdata.offset;
   zfvld              = setup_ip_db_cl.ip_db[i].ip_asdata.zfvld;
   asdata_age         = setup_ip_db_cl.ip_db[i].ip_asdata.age;

   adata = {22'h0,syndrome,zfid,v4_ecc_ck,asdata_disc,tres,asdata_rdctbl,asdata_offset,zfvld,asdata_age};
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
     "IP_UTIL INFO: FOR TCAM INDEX %d AS_DATA = %h.\n",i,adata);

   if ((v4_ecc_ck) && (setup_ip_db_cl.ip_db[i].ip_frame.frame_type =?= 5'bx0x1x) && (pkt_ipv4))
     {
      // if IPV4 5-tuple, Calculate ECC for tcam & as_data and insert it in syndrome[15:0]
      // if IPV6 then parity is cosidered even if v4_ecc_ck=1
      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "Calculating ECC for TCAM/ASDATA for TCAM index = %d.\n",i);
      adata_cam_key = {adata[25:1],1'b0,cam_key[103:0]};
      ecc_syndrome_l = calculate_ecc_syndrome (adata_cam_key[64:0]); 
      ecc_syndrome_h = calculate_ecc_syndrome (adata_cam_key[129:65]); 
      adata = {22'h0,ecc_syndrome_h,ecc_syndrome_l,zfid,v4_ecc_ck,asdata_disc,tres,asdata_rdctbl,asdata_offset,zfvld,asdata_age};
      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "ADATA AFTER Calculating ECC syndrome is %h for TCAM index = %d.\n",adata,i);
     }
   else  // Calculate Parity for as_data and insert it in syndrome[3:0]
     {
      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "Calculating PARITY for ASDATA for TCAM index = %d.\n",i);
      asdata_parity_value = calculate_asdata_parity (i,adata);
      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "Calculated PARITY for ASDATA is %h for TCAM index = %d.\n",asdata_parity_value,i);
      adata = {22'h0,syndrome[15:4],asdata_parity_value,zfid,v4_ecc_ck,asdata_disc,tres,asdata_rdctbl,asdata_offset,zfvld,asdata_age}; 
     }
   if ( get_plus_arg(CHECK, "DO_PIO_TRANS") )
     {
      if (pkt_class === 0)
        {
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
           "FOR PKT_CLASS = %d, No CAM key insertion is done, since no TCAM search is required.\n");
        }
      else
        {
         be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
           "Performing PIO Transactions to CAM_RAM.\n");
         be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
           "IP_UTIL: TUPLE_TYPE = %h, CAM_ADDR = %h, CAM_KEY = %h, AS_DATA = %h, CAM_LMASK = %h.\n",
            tuple_type, cam_addr, cam_key, adata,cam_lmask);
         fflp_util.pio_wr_tcam_key(cam_addr, cam_key, cam_lmask);
         fflp_util.pio_wr_tcam_asdata(cam_addr, adata);
   
         //@@@@@@@ Store the cam_key, cam_lmask & adata in shadow space @@@@@@@@@
         setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key [i]   = cam_key;
         setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_lmask [i] = cam_lmask;
         setup_ip_db_cl.ip_db[0].ip_cam.shadow_adata [i]     = adata;
   
         be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
           "IP_UTIL INFO: FOR i = %d, SHADOW_ADATA = %h.\n",i,setup_ip_db_cl.ip_db[0].ip_cam.shadow_adata [i]);
 
         cam_addr = cam_addr + 1;
        }
     }
   else
     {
      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
        "Performing Backdoor Operation to CAM_RAM.\n");
     }

  }// for (i=0;i<pkt_cnt;i++)
 }

repeat (100) @(posedge CLOCK);
}

function bit [199:0] setup_cam_ram_fcram_class :: get_tcam_key(integer index) {
 
  get_tcam_key = setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key [index];

}

function bit [63:0] setup_cam_ram_fcram_class :: get_assoc_data(integer index) {

  get_assoc_data = setup_ip_db_cl.ip_db[0].ip_cam.shadow_adata [index];

}

task setup_cam_ram_fcram_class :: gen_pio_trans(bit [9:0] pio_trans_mode)
{
//@@ pio_trans_mode 00_0000_0000 NOP
//@@ pio_trans_mode 00_0000_0000 NOP
 integer i;
 integer num_of_pio_iter = 0;
 bit [39:0] addr;
 bit [63:0] rd_data;
 bit [63:0] wr_data;
 bit [199:0] cam_lmask;
 bit [199:0] cam_key;
 bit [199:0] rd_shadow_cam_key;
 bit [199:0] rd_tcam_lmask;
 bit [199:0] rd_tcam_key;
 bit [31:0]  cam_addr = 32'h0;
 bit [63:0]  adata = 64'h0;

 num_of_pio_iter = pio_trans_mode[7:5];

 case (pio_trans_mode[4:0])
  {
   5'b00000: // idle, no pio activity
    {
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::gen_pio_trans()",
      "IP_UTIL INFO: WARNING: No PIO transaction is performed.\n");
    }
   5'b00001: // FFLP PIO Register RD 
    {
     for (i=0;i<num_of_pio_iter;i++)
      {
       random_value10 = random();
       addr = fflp_reg_addr[random_value10%8];
       gen_pio_drv.pio_rd(addr, rd_data); 
      }
    }
   5'b00010: // FFLP PIO Register WR 
    {
     for (i=0;i<num_of_pio_iter;i++)
      {
       random_value10 = random();
       addr = fflp_reg_addr[random_value10%8];
       wr_data = 64'h5555_5555_5555_5555;
       gen_pio_drv.pio_wr(addr, wr_data); 
      }
    }
   5'b00011: // FFLP PIO Register RD/WR 
    {
    }
   5'b00100: // Reserved
    {
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::gen_pio_trans()",
      "IP_UTIL INFO: WARNING: No PIO transaction is performed.\n");
    }
   5'b01001: // FFLP CAM_RAM RD
    {
     if (!neptune_mode)
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::gen_pio_trans()",
         "IP_UTIL INFO: STARTING TO DO PIO CAM READ TRANSACTION.\n");
        for (i=0;i<num_of_pio_iter;i++)
         {
          cam_addr = random_value11%tcam_entries;
   
          be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::gen_pio_trans()",
           "IP_UTIL INFO: DOING PIO CAM READ TRANSACTION FOR CAM_INDEX = %d.\n",cam_addr);
   
          //@@@@@@@@  Read PIO @@@@@@@@@@
          rd_tcam_key = fflp_util.pio_rd_tcam_key(cam_addr, rd_tcam_lmask);
          //@@@@@@@ Read the cam_key from shadow space to be compared against the PIO rd value @@@@@@
          rd_shadow_cam_key = setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key [cam_addr];
          if (rd_tcam_key != rd_shadow_cam_key)
            {
             be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::gen_pio_trans()",
              "IP_UTIL: PIO read TCAM Key = %h, SHADOW read TCAM Key = %h.\n",
                rd_tcam_key,rd_shadow_cam_key);
            }
         }
       }
    }
   5'b01010: // FFLP CAM_RAM WR
    {
     for (i=0;i<num_of_pio_iter;i++)
      {
       cam_key = 200'h0000_1111_2222_3333_4444_5555_6666_7777_8888_9999_aaaa_bbbb_cc;
       cam_lmask = 200'hffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ff;
//     adata = {22'h0,42'h111_2222_3333};
       cam_addr = random_value11%128;
       fflp_util.pio_wr_tcam_key(cam_addr, cam_key, cam_lmask);
//     fflp_util.pio_wr_tcam_asdata(cam_addr, adata);

       //@@@@@@@ Store the cam_key, cam_lmask & adata in shadow space @@@@@@@@@
       setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key [cam_addr]   = cam_key;
       setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_lmask [cam_addr] = cam_lmask;
//     setup_ip_db_cl.ip_db[0].ip_cam.shadow_adata [cam_addr]     = adata;
      }
    }
   5'b01011: // FFLP CAM_RAM WR/RD
    {
     if (!neptune_mode)
       {
        for (i=0;i<num_of_pio_iter;i++)
         {
          //@@@@@@@@ Write PIO @@@@@@@@@@
          cam_key = 200'h0000_1111_2222_3333_4444_5555_6666_7777_8888_9999_aaaa_bbbb_cc;
          cam_lmask = 200'hffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ff;
//        adata = {22'h0,42'h111_2222_3333};
          cam_addr = random_value11%128;
          fflp_util.pio_wr_tcam_key(cam_addr, cam_key, cam_lmask);
//        fflp_util.pio_wr_tcam_asdata(cam_addr, adata);

          //@@@@@@@ Store the cam_key, cam_lmask & adata in shadow space @@@@@@@@@
          setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key [cam_addr]   = cam_key;
          setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_lmask [cam_addr] = cam_lmask;
//        setup_ip_db_cl.ip_db[0].ip_cam.shadow_adata [cam_addr]     = adata;
          //@@@@@@@@  Read PIO @@@@@@@@@@
          rd_tcam_key = fflp_util.pio_rd_tcam_key(cam_addr, rd_tcam_lmask);
          //@@@@@@@ Read the cam_key from shadow space to be compared against the PIO rd value @@@@@@
          rd_shadow_cam_key = setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key [cam_addr];
          if (rd_tcam_key != rd_shadow_cam_key)
            {
             be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::gen_pio_trans()",
              "IP_UTIL: PIO read TCAM Key = %h, SHADOW read TCAM Key = %h.\n",
                rd_tcam_key,rd_shadow_cam_key);
            }
         }
      }
    }
   5'b01100: // FFLP CAM CMP
    {
     for (i=0;i<num_of_pio_iter;i++)
      {
       //@@@@@@@@ CMP PIO CMD @@@@@@@@@@
       cam_key = setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key[random_value11%tcam_entries];
//     cam_key = 200'h0000_1111_2222_3333_4444_5555_6666_7777_8888_9999_aaaa_bbbb_cc;
       fflp_util.pio_cmp_tcam_key(cam_key);

       //@@@@@@@ Store the cam_key, cam_lmask & adata in shadow space @@@@@@@@@
//     setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key [cam_addr]   = cam_key;
//     setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_lmask [cam_addr] = cam_lmask;
       //@@@@@@@@  Read PIO @@@@@@@@@@
      }
    }
   5'b01101: // FFLP CAM CMP/RD
    {
     if (!neptune_mode)
       {
        for (i=0;i<num_of_pio_iter;i++)
         {
          //@@@@@@@@ CMP PIO CMD @@@@@@@@@@
          cam_key = setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key[random_value11%tcam_entries];
          fflp_util.pio_cmp_tcam_key(cam_key);
          cam_addr = random_value11%tcam_entries;
          //@@@@@@@@  Read PIO @@@@@@@@@@
          rd_tcam_key = fflp_util.pio_rd_tcam_key(cam_addr, rd_tcam_lmask);
         }
       }
    }
   5'b01110: // FFLP CAM CMP/WR
    {
     for (i=0;i<num_of_pio_iter;i++)
      {
       //@@@@@@@@ Write PIO @@@@@@@@@@
       cam_key = 200'h0000_1111_2222_3333_4444_5555_6666_7777_8888_9999_aaaa_bbbb_cc;
       cam_lmask = 200'hffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ff;
       cam_addr = random_value11%128;
       fflp_util.pio_wr_tcam_key(cam_addr, cam_key, cam_lmask);

       //@@@@@@@ Store the cam_key, cam_lmask & adata in shadow space @@@@@@@@@
       setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key [cam_addr]   = cam_key;
       setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_lmask [cam_addr] = cam_lmask;
       //@@@@@@@@ CMP PIO CMD @@@@@@@@@@
       cam_key = setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key[random_value11%tcam_entries];
       fflp_util.pio_cmp_tcam_key(cam_key);
      }
    }
   5'b01111: // FFLP CAM RD/WR/CMP
    {
     if (!neptune_mode)
       {
        for (i=0;i<num_of_pio_iter;i++)
         {
          //@@@@@@@@ CMP PIO CMD @@@@@@@@@@
          cam_key = setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key[random_value11%tcam_entries];
          fflp_util.pio_cmp_tcam_key(cam_key);
          //@@@@@@@@ Write PIO @@@@@@@@@@
          cam_key = 200'h0000_1111_2222_3333_4444_5555_6666_7777_8888_9999_aaaa_bbbb_cc;
          cam_lmask = 200'hffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ff;
          adata = {22'h0,42'h111_2222_3333};
          cam_addr = random_value11%128;
          fflp_util.pio_wr_tcam_key(cam_addr, cam_key, cam_lmask);
          fflp_util.pio_wr_tcam_asdata(cam_addr, adata);

          //@@@@@@@ Store the cam_key, cam_lmask & adata in shadow space @@@@@@@@@
          setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key [cam_addr]   = cam_key;
          setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_lmask [cam_addr] = cam_lmask;
          setup_ip_db_cl.ip_db[0].ip_cam.shadow_adata [cam_addr]     = adata;
          //@@@@@@@@  Read PIO @@@@@@@@@@
          rd_tcam_key = fflp_util.pio_rd_tcam_key(cam_addr, rd_tcam_lmask);
         }
       }
    }
   5'b10000: // Reserved
    {
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::gen_pio_trans()",
      "IP_UTIL INFO: WARNING: No PIO transaction is performed.\n");
    }
   5'b10001: // FCRAM Entry RD
    {
    }
   5'b10010: // FCRAM Entry WR
    {
    }
   5'b10011: // FCRAM Entry RD/WR
    {
    }
   5'b11000: // Reserved
    {
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::gen_pio_trans()",
      "IP_UTIL INFO: WARNING: No PIO transaction is performed.\n");
    }
   5'b11001: // FFLP CAM_RAM & FRCRAM RD
    {
    }
   5'b11010: // FFLP CAM_RAM & FRCRAM WR
    {
    }
   5'b11011: // FFLP CAM_RAM & FRCRAM RD/WR
    {
    }
   5'b11101: // FFLP CAM_RAM CMP/RD & FRCRAM RD
    {
    }
   5'b11110: // FFLP CAM_RAM CMP/WR & FRCRAM WR
    {
    }
   5'b11111: // FFLP CAM_RAM CMP/WR/RD & FRCRAM WR/RD
    {
    }
  }
}
function bit [3:0] setup_cam_ram_fcram_class :: calculate_asdata_parity (integer i, bit [63:0] adata)
 {
  integer j;
  integer B0_even_parity_cnt = 0;
  integer B1_even_parity_cnt = 0;
  integer B2_even_parity_cnt = 0;
  integer B3_even_parity_cnt = 0;

  for (j=1;j<8;j++)
   {
    if (adata[j] === 1'b1) 
      {
       B0_even_parity_cnt = B0_even_parity_cnt + 1;
      }
   }
  
  for (j=8;j<16;j++)
   {
    if (adata[j] === 1'b1)
      {
       B1_even_parity_cnt = B1_even_parity_cnt + 1;
      }
   } 

  for (j=16;j<24;j++)
   {
    if (adata[j] === 1'b1)
      {
       B2_even_parity_cnt = B2_even_parity_cnt + 1;
      }
   }

  for (j=24;j<26;j++)
   {
    if (adata[j] === 1'b1)
      {
       B3_even_parity_cnt = B3_even_parity_cnt + 1;
      }
   }

  if (B0_even_parity_cnt === 0 ||
      B0_even_parity_cnt === 2 ||
      B0_even_parity_cnt === 4 ||
      B0_even_parity_cnt === 6 || 
      B0_even_parity_cnt === 8)
    {
     calculate_asdata_parity[0] = 1'b0;
     if ( get_plus_arg(CHECK, "FFLP_DEBUG") )
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_asdata_parity()",
         "IP_UTIL INFO: FOR TCAM_INDEX = %d, EVEN PARITY DETECTED FOR B0 OF AS_DATA = %h.\n",i,adata);
       }
    }
  else if (B0_even_parity_cnt === 1 ||
           B0_even_parity_cnt === 3 ||
           B0_even_parity_cnt === 5 ||
           B0_even_parity_cnt === 7)
    {
     calculate_asdata_parity[0] = 1'b1;
     if ( get_plus_arg(CHECK, "FFLP_DEBUG") )
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_asdata_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, ODD PARITY DETECTED FOR B0 OF AS_DATA = %h.\n",i,adata);
       }
    }
  else
    {
     be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_asdata_parity()",
     "IP_UTIL INFO: FOR TCAM_INDEX = %d, B0_even_parity_cnt = %d is not expected.\n",i,B0_even_parity_cnt);
    }

  if (B1_even_parity_cnt === 0 ||
      B1_even_parity_cnt === 2 ||
      B1_even_parity_cnt === 4 ||
      B1_even_parity_cnt === 6 ||
      B1_even_parity_cnt === 8)
    {
     calculate_asdata_parity[1] = 1'b0;
     if ( get_plus_arg(CHECK, "FFLP_DEBUG") )
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_asdata_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, EVEN PARITY DETECTED FOR B1 OF AS_DATA = %h.\n",i,adata);
       }
    }
  else if (B1_even_parity_cnt === 1 ||
           B1_even_parity_cnt === 3 ||
           B1_even_parity_cnt === 5 ||
           B1_even_parity_cnt === 7)
    {
     calculate_asdata_parity[1] = 1'b1;
     if ( get_plus_arg(CHECK, "FFLP_DEBUG") )
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_asdata_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, ODD PARITY DETECTED FOR B1 OF AS_DATA = %h.\n",i,adata);
       }
    }
  else
    {
     be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_asdata_parity()",
     "IP_UTIL INFO: FOR TCAM_INDEX = %d, B1_even_parity_cnt = %d is not expected.\n",i,B1_even_parity_cnt);
    }

  if (B2_even_parity_cnt === 0 ||
      B2_even_parity_cnt === 2 ||
      B2_even_parity_cnt === 4 ||
      B2_even_parity_cnt === 6 ||
      B2_even_parity_cnt === 8)
    {
     calculate_asdata_parity[2] = 1'b0;
     if ( get_plus_arg(CHECK, "FFLP_DEBUG") )
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_asdata_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, E EVEN PARITY DETECTED FOR B2 OF AS_DATA = %h.\n",i,adata);
       }
    }
  else if (B2_even_parity_cnt === 1 ||
           B2_even_parity_cnt === 3 ||
           B2_even_parity_cnt === 5 ||
           B2_even_parity_cnt === 7)
    {
     calculate_asdata_parity[2] = 1'b1;
     if ( get_plus_arg(CHECK, "FFLP_DEBUG") )
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_asdata_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, O ODD PARITY DETECTED FOR B2 OF AS_DATA = %h.\n",i,adata);
       }
    }
  else
    {
     be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_asdata_parity()",
     "IP_UTIL INFO: FOR TCAM_INDEX = %d, B2_even_parity_cnt = %d is not expected.\n",i,B2_even_parity_cnt);
    }

  if (B3_even_parity_cnt === 0 ||
      B3_even_parity_cnt === 2)
    {
     calculate_asdata_parity[3] = 1'b0;
     if ( get_plus_arg(CHECK, "FFLP_DEBUG") )
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_asdata_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, EVEN PARITY DETECTED FOR B3 OF AS_DATA = %h.\n",i,adata);
       }
    }
  else if (B3_even_parity_cnt === 1)
    {
     calculate_asdata_parity[3] = 1'b1;
     if ( get_plus_arg(CHECK, "FFLP_DEBUG") )
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_asdata_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, ODD PARITY DETECTED FOR B3 OF AS_DATA = %h.\n",i,adata);
       }
    }
  else
    {
     be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_asdata_parity()",
     "IP_UTIL INFO: FOR TCAM_INDEX = %d, B3_even_parity_cnt = %d is not expected.\n",
     i,B3_even_parity_cnt);
    }
  if ( get_plus_arg(CHECK, "FFLP_DEBUG") )
    {
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_asdata_parity()",
     "IP_UTIL INFO: FOR TCAM_INDEX = %d, CALCULTED PARITY IS %h.\n",i,calculate_asdata_parity);
    }
 }

function bit setup_cam_ram_fcram_class :: vcam_parity_bit (bit [7:0] data)
 {
  integer bit_count = 0;

  if (data[0]) {bit_count = bit_count + 1;}
  if (data[1]) {bit_count = bit_count + 1;}
  if (data[2]) {bit_count = bit_count + 1;}
  if (data[3]) {bit_count = bit_count + 1;}
  if (data[4]) {bit_count = bit_count + 1;}
  if (data[5]) {bit_count = bit_count + 1;}
  if (data[6]) {bit_count = bit_count + 1;}
  if (data[7]) {bit_count = bit_count + 1;}

  if (bit_count == 1 || bit_count == 3 || bit_count == 5 || bit_count == 7)
    {
     vcam_parity_bit = 1'b1;
    }
  else 
    {
     vcam_parity_bit = 1'b0;
    }
 }
function bit [11:0] setup_cam_ram_fcram_class :: as_data_chksum_val(bit [31:0] as_adata1, bit [31:0] as_adata2)
 {
  bit [12:0] asdata_sum1   = 0;
  bit [12:0] asdata_sum2   = 0;
  bit [12:0] asdata_sum3   = 0;
  bit [12:0] asdata_sum4   = 0;
  bit [12:0] asdata_sum5   = 0;

  bit [11:0] asdata_sum1_c = 0;
  bit [11:0] asdata_sum2_c = 0;
  bit [11:0] asdata_sum3_c = 0;
  bit [11:0] asdata_sum4_c = 0;
  bit [11:0] asdata_sum5_c = 0;

  bit [35:0] adata1_tmp = 0;

 if (as_adata1[29] === 1'b0)  //@@@@@@ if mapped=0, insert 0 for qp_num0 & qp_num1 @@@@@@
   {
    adata1_tmp    = as_adata1 & 36'hff800_07ff;
    as_adata1     = adata1_tmp;
   }

#ifndef NO_EXT_CAM_RAM
  asdata_sum1   =       as_adata1[23:12]  + as_adata1[11:0];  
  asdata_sum2   =       as_adata2[15:4]   + {as_adata2[3:0],as_adata1[31:24]};
  asdata_sum3   = {8'b0,as_adata2[31:28]} +  as_adata2[27:16];

  asdata_sum1_c = asdata_sum1[11:0] + asdata_sum1[12];
  asdata_sum2_c = asdata_sum2[11:0] + asdata_sum2[12];
  asdata_sum3_c = asdata_sum3[11:0] + asdata_sum3[12];

  asdata_sum4   = asdata_sum1_c + asdata_sum2_c;
  asdata_sum4_c = asdata_sum4[11:0] + asdata_sum4[12];

  asdata_sum5   = asdata_sum3_c + asdata_sum4_c;
  asdata_sum5_c = asdata_sum5[11:0] + asdata_sum5[12];

#endif
  as_data_chksum_val = asdata_sum5_c;
 }

function bit [2:0] setup_cam_ram_fcram_class :: get_l2_rdc_tbl_num (integer i)
 {
  bit [2:0] matched_vlan_rdctblnum = 3'b000;
  bit       matched_vlan_vpr       = 1'b0;
  bit [2:0] matched_mac_rdctblnum = 3'b000;
  bit       matched_mac_mpr       = 1'b0;
  bit [4:0] packet_frame_type = 5'h0;
  bit [2:0] packet_mac_port = 3'b000;
  bit [11:0] packet_tci = 12'h0;
  bit        vlan_parity0    = 1'bx; 
  bit        vlan_parity1    = 1'bx; 
  bit [2:0]  vlan_rdctblnum0 = 3'b000; 
  bit        vlan_vpr0 = 1'b0;
  bit [2:0]  vlan_rdctblnum1 = 3'b000; 
  bit        vlan_vpr1 = 1'b0;
  bit [2:0]  vlan_rdctblnum2 = 3'b000; 
  bit        vlan_vpr2 = 1'b0;
  bit [2:0]  vlan_rdctblnum3 = 3'b000; 
  bit        vlan_vpr3 = 1'b0;
  bit [39:0] addr;
  bit [63:0] rd_data;
  bit [17:0] ip_db_vt_vlan;

  if (setup_ip_db_cl.ip_db[i].ip_mac.mac_port === 3'b000 &&
      setup_ip_db_cl.ip_db[i].ip_mac.mac_speed === 2'b11)
    {
     //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
     //@@@@@@ Predict the mac_rdc_tbl_num & mpr @@@@@@@@ 
     //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
     if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[0])
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address0 in MAC0 matched for i = %d.\n",i);
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[0];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[0];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address0 in MAC0 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[1])
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address1 in MAC0 matched for i = %d.\n",i);
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[1];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[1];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address1 in MAC0 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[2])
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address2 in MAC0 matched for i = %d.\n",i);
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[2];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[2];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address2 in MAC0 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[3])
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address3 in MAC0 matched for i = %d.\n",i);
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[3];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[3];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address3 in MAC0 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[4])
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address4 in MAC0 matched for i = %d.\n",i);
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[4];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[4];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address4 in MAC0 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[5])
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address5 in MAC0 matched for i = %d.\n",i);
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[5];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[5];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address5 in MAC0 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[6])
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address6 in MAC0 matched for i = %d.\n",i);
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[6];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[6];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address6 in MAC0 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[7])
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address7 in MAC0 matched for i = %d.\n",i);
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[7];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[7];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address7 in MAC0 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[8])
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address8 in MAC1 matched for i = %d.\n",i);
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[8];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[8];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address8 in MAC0 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[9])
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address9 in MAC1 matched for i = %d.\n",i);
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[9];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[9];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[10])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[10];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[10];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[11])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[11];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[11];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[12])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[12];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[12];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[13])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[13];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[13];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[14])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[14];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[14];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[15])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[15];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[15];
       }
     else
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address did not match with any of the MAC0 16 DA Addresses.\n");
       }
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
       "FOR IP_DB[%d] PORT0:10000, MATCHED_MAC_RDCTBLNUM = %h, MATCHED_MAC_MPR = %h.\n",
        i,matched_mac_rdctblnum,matched_mac_mpr);
    }
  else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_port === 3'b000 &&
           setup_ip_db_cl.ip_db[i].ip_mac.mac_speed === 2'b10)
    {
     //@@@@@@ Get the mac_rdc_tbl_num & mpr @@@@@@@@@@@@ 
     if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[0])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[0];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[0];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[1])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[1];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[1];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[2])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[2];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[2];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[3])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[3];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[3];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[4])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[4];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[4];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[5])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[5];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[5];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[6])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[6];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[6];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[7])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[7];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[7];
       }
     else
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address did not match with any of the MAC0 8 DA Addresses.\n");
       }
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
       "FOR IP_DB[%d] PORT0:1000, MATCHED_MAC_RDCTBLNUM = %h, MATCHED_MAC_MPR = %h.\n",
        i,matched_mac_rdctblnum,matched_mac_mpr);
    }
  else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_port === 3'b001 &&
           setup_ip_db_cl.ip_db[i].ip_mac.mac_speed === 2'b11)
    {
     if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[16])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[16];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[16];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address16 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[17])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[17];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[17];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address17 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[18])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[18];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[18];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address18 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[19])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[19];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[19];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address19 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[20])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[20];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[20];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address20 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[21])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[21];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[21];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address21 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[22])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[22];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[22];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address22 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[23])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[23];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[23];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address23 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[24])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[24];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[24];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address24 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[25])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[25];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[25];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address25 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[26])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[26];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[26];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address26 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[27])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[27];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[27];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address27 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[28])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[28];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[28];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address28 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[29])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[29];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[29];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address29 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[30])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[30];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[30];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address30 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[31])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[31];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[31];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "For DA Address31 in MAC1 match for i = %d MAC_RDC = %h.\n",i,matched_mac_rdctblnum);
       }
     else
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address did not match with any of the MAC1 16 DA Addresses.\n");
       }
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
       "FOR IP_DB[%d] PORT1:10000, MATCHED_MAC_RDCTBLNUM = %h, MATCHED_MAC_MPR = %h.\n",
        i,matched_mac_rdctblnum,matched_mac_mpr);
    }
  else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_port === 3'b001 &&
           setup_ip_db_cl.ip_db[i].ip_mac.mac_speed === 2'b10)
    {
     if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[16])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[16];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[16];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[17])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[17];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[17];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[18])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[18];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[18];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[19])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[19];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[19];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[20])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[20];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[20];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[21])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[21];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[21];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[22])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[22];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[22];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[23])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[23];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[23];
       }
     else
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address did not match with any of the MAC1 8 DA Addresses.\n");
       }
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
       "FOR IP_DB[%d] PORT1:1000, MATCHED_MAC_RDCTBLNUM = %h, MATCHED_MAC_MPR = %h.\n",
        i,matched_mac_rdctblnum,matched_mac_mpr);
    }
  else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_port === 3'b010)
    {
     if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[32])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[32];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[32];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[33])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[33];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[33];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[34])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[34];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[34];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[35])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[35];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[35];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[36])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[36];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[36];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[37])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[37];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[37];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[38])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[38];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[38];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[39])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[39];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[39];
       }
     else
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address did not match with any of the MAC2 8 DA Addresses.\n");
       }
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
       "FOR IP_DB[%d] PORT2:1000, MATCHED_MAC_RDCTBLNUM = %h, MATCHED_MAC_MPR = %h.\n",
        i,matched_mac_rdctblnum,matched_mac_mpr);
    }
  else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_port === 3'b100)
    {
     if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[40])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[40];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[40];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[41])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[41];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[41];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[42])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[42];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[42];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[43])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[43];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[43];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[44])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[44];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[44];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[45])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[45];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[45];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[46])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[46];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[46];
       }
     else if (setup_ip_db_cl.ip_db[i].ip_mac.mac_da === setup_ip_db_cl.pkt_mac_da[47])
       {
        matched_mac_rdctblnum        = setup_ip_db_cl.pkt_mac_rdctblnum[47];
        matched_mac_mpr              = setup_ip_db_cl.pkt_mac_mpr[47];
       }
     else
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
         "DA Address did not match with any of the MAC3 8 DA Addresses.\n");
       }
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
       "FOR IP_DB[%d] PORT3:1000, MATCHED_MAC_RDCTBLNUM = %h, MATCHED_MAC_MPR = %h.\n",
        i,matched_mac_rdctblnum,matched_mac_mpr);
    }
  else
    {
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
     "FOR IP_DB[%d], Detected unsupported Port %h.\n",i,setup_ip_db_cl.ip_db[i].ip_mac.mac_port);
    }
     //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
     //@@@@@@ Predict the vlan rdc_tbl_num & mpr @@@@@@@ 
     //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
  packet_frame_type = setup_ip_db_cl.ip_db[i].ip_frame.frame_type;
  packet_mac_port   = setup_ip_db_cl.ip_db[i].ip_mac.mac_port;
  if (packet_frame_type[2])
    {
     packet_tci = setup_ip_db_cl.ip_db[i].ip_src_node.tci;

     //@@@@@@ Get the vlan tables value from ip_db Vlan Table @@@@@@
     vlan_parity0    = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.parity0;
     vlan_parity1    = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.parity1;
     vlan_rdctblnum0 = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.rdctblnum0; 
     vlan_vpr0       = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.vpr0;
     vlan_rdctblnum1 = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.rdctblnum1; 
     vlan_vpr1       = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.vpr1;
     vlan_rdctblnum2 = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.rdctblnum2; 
     vlan_vpr2       = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.vpr2;
     vlan_rdctblnum3 = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.rdctblnum3; 
     vlan_vpr3       = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.vpr3;

     ip_db_vt_vlan   = {vlan_parity1,vlan_parity0,
                        vlan_vpr3,vlan_rdctblnum3,vlan_vpr2,vlan_rdctblnum2,
                        vlan_vpr1,vlan_rdctblnum1,vlan_vpr0,vlan_rdctblnum0};

     //@@@@@@ Get the vlan tables value from RTL Vlan Table @@@@@@
     addr = {FFLP_VLAN_TBL_ADDRESS_RANGE + 8*packet_tci[11:0]};
//   gen_pio_drv.pio_rd(addr, rd_data); 
     rd_data = {46'h0,ip_db_vt_vlan};  // Get from ip_db instead pio_rd

     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
     "FOR VLAN ID %h, READ RTL_VLAN_ENTRY = %h AT ADDERSS = %h.\n",packet_tci[11:0],rd_data[17:0],addr);

     vlan_parity_error = verify_vlan_tbl_parity (packet_tci[11:0], ip_db_vt_vlan, rd_data[17:0]);

     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
     "FOR VLAN ID %h, RTL_VLAN_ENTRY = %h.\n",packet_tci[11:0],rd_data[17:0]);

     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
     "FOR IP_DB[%d], PACKET_FRAME_TYPE = %h, PACKET_MAC_PORT = %d.\n",i,packet_frame_type,packet_mac_port);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
     "FOR IP_DB[%d], vlan_rdctblnum0 = %h, vlan_vpr0 = %h.\n",i,vlan_rdctblnum0,vlan_vpr0);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
     "FOR IP_DB[%d], vlan_rdctblnum1 = %h, vlan_vpr1 = %h.\n",i,vlan_rdctblnum1,vlan_vpr1);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
     "FOR VLAN ID %h, vlan_parity_error = %h.\n",i,vlan_parity_error);

   if (vlan_parity_error == 2'b00) // no vlan parity error
    {
     case (packet_mac_port)
         {
          3'b000: {
                matched_vlan_rdctblnum = vlan_rdctblnum0;
                matched_vlan_vpr       = vlan_vpr0;
                be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
                "FOR IP_DB[%d], packet_mac_port = %h, matched_vlan_rdctblnum = %h, matched_vlan_vpr = %h.\n",
                 i,packet_mac_port,matched_vlan_rdctblnum,matched_vlan_vpr);
               }
          3'b001: {
                matched_vlan_rdctblnum = vlan_rdctblnum1; 
                matched_vlan_vpr       = vlan_vpr1;
                be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
                "FOR IP_DB[%d], packet_mac_port = %h, matched_vlan_rdctblnum = %h, matched_vlan_vpr = %h.\n",
                 i,packet_mac_port,matched_vlan_rdctblnum,matched_vlan_vpr);
               }
          3'b010: {
                matched_vlan_rdctblnum = vlan_rdctblnum2; 
                matched_vlan_vpr       = vlan_vpr2;
                be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
                "FOR IP_DB[%d], packet_mac_port = %h, matched_vlan_rdctblnum = %h, matched_vlan_vpr = %h.\n",
                 i,packet_mac_port,matched_vlan_rdctblnum,matched_vlan_vpr);
               }
          3'b100: {
                matched_vlan_rdctblnum = vlan_rdctblnum3; 
                matched_vlan_vpr       = vlan_vpr3;
                be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
                "FOR IP_DB[%d], packet_mac_port = %h, matched_vlan_rdctblnum = %h, matched_vlan_vpr = %h.\n",
                 i,packet_mac_port,matched_vlan_rdctblnum,matched_vlan_vpr);
               }
          default: {
                
               }
         } 

     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
        "FOR IP_DB[%d], MATCHED_MAC_MPR = %h, MATCHED_VLAN_MPR = %h.\n",i,matched_mac_mpr,matched_vlan_vpr);

     case ({matched_mac_mpr,matched_vlan_vpr}) 
         {
          {1'b0,1'b0}: {get_l2_rdc_tbl_num = matched_mac_rdctblnum;
               be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
                "MAC RDCTBLNUM %h was predicted as L2RDCTBLNUM for packet %d.\n",get_l2_rdc_tbl_num,i);
              }
          {1'b0,1'b1}: {get_l2_rdc_tbl_num = matched_vlan_rdctblnum;
               be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
                "VLAN RDCTBLNUM %h was predicted as L2RDCTBLNUM for packet %d.\n",get_l2_rdc_tbl_num,i);
              }
          {1'b1,1'b0}: {get_l2_rdc_tbl_num = matched_mac_rdctblnum;
               be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
                "MAC RDCTBLNUM %h was predicted as L2RDCTBLNUM for packet %d.\n",get_l2_rdc_tbl_num,i);
              }
          {1'b1,1'b1}: {get_l2_rdc_tbl_num = matched_vlan_rdctblnum;
               be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
                "VLAN RDCTBLNUM %h was predicted as L2RDCTBLNUM for packet %d.\n",get_l2_rdc_tbl_num,i);
              }
         }
    } // if (!vlan_parity_error)
   else
    {
     be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
                "IP_UTIL[%d]: FOR VLAN ID %h, VLAN PARITY mis-compare reported.\n",i,packet_tci[11:0]);
     get_l2_rdc_tbl_num = matched_mac_rdctblnum;
    }
   } // if (packet_frame_type[2])
  else // Not a VLAN packet
    {
     get_l2_rdc_tbl_num = matched_mac_rdctblnum;
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::get_l2_rdc_tbl_num()",
       "IP_UTIL INFO: NO TAG GET_L2_RDC_TBL_NUM = %h for pkt = %d.\n",get_l2_rdc_tbl_num,i);
    }
  
 }

task setup_cam_ram_fcram_class :: prog_vlan_table(integer index, 
                                                  bit        parity0,
                                                  bit        vpr1,
                                                  bit [2:0]  vlan_tbln1,
                                                  bit        vpr0,
                                                  bit [2:0]  vlan_tbln0,
                                                  (bit        parity1 = 1'b0,
                                                   bit        vpr3 = 1'b0,
                                                   bit [2:0]  vlan_tbln3 = 3'h0,
                                                   bit        vpr2 = 1'b0,
                                                   bit [2:0]  vlan_tbln2 = 3'h0))
{ 
  bit [39:0]  addr;
  bit [63:0]  wr_data;

  bit [15:0]  mem_addr;
  bit [17:0]   mem_wr_data;
//bit [17:0]  mem_wr_data_nep;

     if (neptune_mode)
       {
        if ( get_plus_arg(CHECK, "DO_PIO_VLAN_TRANS") )
          {
           addr = FFLP_VLAN_TBL_ADDRESS_RANGE + (index*8);
           wr_data   = {46'h0,
                        parity1,
                        parity0,
                        vpr3,
                        vlan_tbln3,
                        vpr2,
                        vlan_tbln2,
                        vpr1,
                        vlan_tbln1,
                        vpr0,
                        vlan_tbln0};

           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::prog_vlan_table()",
             "NEPTUNE_MODE: VLAN TABLE INDEX %d, AT ADDRESS = %h, WRITING VLAN ENTRY VALUE = %h.\n",index,addr,wr_data);

           gen_pio_drv.pio_wr(addr, wr_data);
          }
        else // Force the VLAN Table Entry
          {
           mem_addr = index;
           mem_wr_data = {parity1,
                          vpr3,
                          vlan_tbln3,
                          vpr2,
                          vlan_tbln2,
                          parity0,
                          vpr1,
                          vlan_tbln1,
                          vpr0,
                          vlan_tbln0};  
//         force_vlan_tbl_entry_nep(mem_addr[11:0], mem_wr_data);
           force_vlan_tbl_entry    ({4'h0,mem_addr[11:0]}, mem_wr_data);

           be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::prog_vlan_table()",
             "NEPTUNE_MODE: AT VLAN TABLE INDEX %d, MEM_ADDR = %h, FORCED VLAN ENTRY VALUE = %h.\n",
               index,mem_addr,mem_wr_data);
          }

        //######################################
        // Shadow update for the vlan entry
        //######################################
        setup_ip_db_cl.ip_db_vt_parity0[index]     = parity0;    
        setup_ip_db_cl.ip_db_vt_parity1[index]     = parity1;    
        setup_ip_db_cl.ip_db_vt_vpr0[index]        = vpr0;      
        setup_ip_db_cl.ip_db_vt_rdctblnum0[index]  = vlan_tbln0;
        setup_ip_db_cl.ip_db_vt_vpr1[index]        = vpr1;     
        setup_ip_db_cl.ip_db_vt_rdctblnum1[index]  = vlan_tbln1;
        setup_ip_db_cl.ip_db_vt_vpr2[index]        = vpr2;     
        setup_ip_db_cl.ip_db_vt_rdctblnum2[index]  = vlan_tbln2;
        setup_ip_db_cl.ip_db_vt_vpr3[index]        = vpr3;     
        setup_ip_db_cl.ip_db_vt_rdctblnum3[index]  = vlan_tbln3;
       }
     else
       {
        if ( get_plus_arg(CHECK, "DO_PIO_VLAN_TRANS") )
          {
           addr = FFLP_VLAN_TBL_ADDRESS_RANGE + (index*8);
           wr_data   = {46'h0,
                        parity0,
                        8'h0,
                        vpr1,
                        vlan_tbln1,
                        vpr0,
                        vlan_tbln0};

           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::prog_vlan_table()",
             "VLAN TABLE INDEX %d, AT ADDRESS = %h, WRITING VLAN ENTRY VALUE = %h.\n",index,addr,wr_data);

           gen_pio_drv.pio_wr(addr, wr_data);
          }
        else // Force the VLAN Table Entry
          {
           mem_addr = index;
           mem_wr_data = {9'h0,parity0,vpr1,vlan_tbln1,vpr0,vlan_tbln0};
           force_vlan_tbl_entry(mem_addr, mem_wr_data);

           be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::prog_vlan_table()",
             "AT VLAN TABLE INDEX %d, AT MEM_ADDR = %h, FORCED VLAN ENTRY VALUE = %h.\n",index,mem_addr,mem_wr_data);
          }

        //######################################
        // Shadow update for the vlan entry
        //######################################
        setup_ip_db_cl.ip_db_vt_parity0[index]     = parity0;    
        setup_ip_db_cl.ip_db_vt_vpr0[index]        = vpr0;      
        setup_ip_db_cl.ip_db_vt_rdctblnum0[index]  = vlan_tbln0;
        setup_ip_db_cl.ip_db_vt_vpr1[index]        = vpr1;     
        setup_ip_db_cl.ip_db_vt_rdctblnum1[index]  = vlan_tbln1;
       }
 }

function bit [17:0] setup_cam_ram_fcram_class :: get_vlan_entry (integer index)
 {
#ifdef NEPTUNE
  get_vlan_entry = {setup_ip_db_cl.ip_db_vt_parity1[index],
		    setup_ip_db_cl.ip_db_vt_parity0[index],
                    setup_ip_db_cl.ip_db_vt_vpr3[index],
                    setup_ip_db_cl.ip_db_vt_rdctblnum3[index],
                    setup_ip_db_cl.ip_db_vt_vpr2[index],
                    setup_ip_db_cl.ip_db_vt_rdctblnum2[index],
                    setup_ip_db_cl.ip_db_vt_vpr1[index],
                    setup_ip_db_cl.ip_db_vt_rdctblnum1[index],
                    setup_ip_db_cl.ip_db_vt_vpr0[index],
                    setup_ip_db_cl.ip_db_vt_rdctblnum0[index]};
#else
  get_vlan_entry = {9'h0,
                    setup_ip_db_cl.ip_db_vt_parity0[index],
                    setup_ip_db_cl.ip_db_vt_vpr1[index],
                    setup_ip_db_cl.ip_db_vt_rdctblnum1[index],
                    setup_ip_db_cl.ip_db_vt_vpr0[index],
                    setup_ip_db_cl.ip_db_vt_rdctblnum0[index]};
#endif
 }

task setup_cam_ram_fcram_class :: program_vlan_table()
 {
  bit [39:0]  addr;
  bit [63:0]  wr_data;
  bit [63:0]  rd_data;
  bit         vpr3 = 1'b0;
  bit         vpr2 = 1'b0;
  bit         vpr1 = 1'b0;
  bit         vpr0 = 1'b0;
  bit         parity1 = 1'b0;
  bit         parity0 = 1'b0;
  bit [2:0]   vlan_tbln3 = 3'h0;
  bit [2:0]   vlan_tbln2 = 3'h0;
  bit [2:0]   vlan_tbln1 = 3'h0;
  bit [2:0]   vlan_tbln0 = 3'h0;

  bit [15:0]  mem_addr;
  bit [17:0]   mem_wr_data;
//  bit [17:0]  mem_wr_data_nep;
  
if (neptune_mode)
  {
   for (i=0;i<4096;i++)
          {
           parity1    = setup_ip_db_cl.ip_db[i].ip_vlan.parity1;
           parity0    = setup_ip_db_cl.ip_db[i].ip_vlan.parity0;
           vpr3       = setup_ip_db_cl.ip_db[i].ip_vlan.vpr3;
           vpr2       = setup_ip_db_cl.ip_db[i].ip_vlan.vpr2;
           vpr1       = setup_ip_db_cl.ip_db[i].ip_vlan.vpr1;
           vpr0       = setup_ip_db_cl.ip_db[i].ip_vlan.vpr0;
           vlan_tbln3 = setup_ip_db_cl.ip_db[i].ip_vlan.rdctblnum3;
           vlan_tbln2 = setup_ip_db_cl.ip_db[i].ip_vlan.rdctblnum2;
           vlan_tbln1 = setup_ip_db_cl.ip_db[i].ip_vlan.rdctblnum1;
           vlan_tbln0 = setup_ip_db_cl.ip_db[i].ip_vlan.rdctblnum0;
           addr = FFLP_VLAN_TBL_ADDRESS_RANGE + (i*8);
 
           wr_data   = {46'h0,
                        parity1,
                        parity0,
                        vpr3,
                        vlan_tbln3,
                        vpr2,
                        vlan_tbln2,
                        vpr1,
                        vlan_tbln1,
                        vpr0,
                        vlan_tbln0};
 
           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_vlan_table()",
             "NEPTUNE_MODE: VLAN TABLE INDEX %d, AT ADDRESS = %h, WRITING VLAN ENTRY VALUE = %h.\n",i,addr,wr_data);
 
           if ( get_plus_arg(CHECK, "DO_PIO_TRANS_VLAN") )
             {
              gen_pio_drv.pio_wr(addr, wr_data);
//            fflp_util.fflp_pio_wrapper(addr, wr_data);   NO SUPPORT YET
             }
           else // Force the VLAN Table Entry
             {
              mem_addr = addr[15:0]/8;
              mem_wr_data = {parity1,
                             vpr3,
                             vlan_tbln3,
                             vpr2,
                             vlan_tbln2,
                             parity0,
                             vpr1,
                             vlan_tbln1,
                             vpr0,
                             vlan_tbln0};
//            force_vlan_tbl_entry_nep(mem_addr[11:0], mem_wr_data);
              force_vlan_tbl_entry    ({4'h0,mem_addr[11:0]}, mem_wr_data);
 
              be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::program_vlan_table()",
               "NEPTUNE_MODE: AT VLAN TABLE INDEX %d, AT ADDRESS = %h, MEM_ADDR = %h, FORCED VLAN ENTRY VALUE = %h.\n",
                  i,addr,mem_addr,mem_wr_data);
             }
          }
  }
else
  {
   for (i=0;i<4096;i++)
          {
           parity0    = setup_ip_db_cl.ip_db[i].ip_vlan.parity0;
           vpr1       = setup_ip_db_cl.ip_db[i].ip_vlan.vpr1;
           vpr0       = setup_ip_db_cl.ip_db[i].ip_vlan.vpr0;
           vlan_tbln1 = setup_ip_db_cl.ip_db[i].ip_vlan.rdctblnum1;
           vlan_tbln0 = setup_ip_db_cl.ip_db[i].ip_vlan.rdctblnum0;
           addr = FFLP_VLAN_TBL_ADDRESS_RANGE + (i*8);
 
           wr_data   = {46'h0,
                        parity0,
                        8'h0,
                        vpr1,
                        vlan_tbln1,
                        vpr0,
                        vlan_tbln0};
 
           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_vlan_table()",
             "VLAN TABLE INDEX %d, AT ADDRESS = %h, WRITING VLAN ENTRY VALUE = %h.\n",i,addr,wr_data);
 
           if ( get_plus_arg(CHECK, "DO_PIO_TRANS_VLAN") )
             {
              gen_pio_drv.pio_wr(addr, wr_data);
//            fflp_util.fflp_pio_wrapper(addr, wr_data);   NO SUPPORT YET
             }
           else // Force the VLAN Table Entry
             {
              mem_addr = addr[15:0]/8;
              mem_wr_data = {9'h0,parity0,vpr1,vlan_tbln1,vpr0,vlan_tbln0};
              force_vlan_tbl_entry(mem_addr, mem_wr_data);
 
              be_msg_fflp.print(e_mesg_debug2, *, "setup_cam_ram_fcram_class::program_vlan_table()",
               "AT VLAN TABLE INDEX %d, AT ADDRESS = %h, MEM_ADDR = %h, FORCED VLAN ENTRY VALUE = %h.\n",i,addr,mem_addr,mem_wr_data);
             }
          }
  }
//The following is the pio_rd in case needed for debug
/*
  for (i=0;i<4096;i++)
         {
          parity1    = setup_ip_db_cl.ip_db[i].ip_vlan.parity1;
          parity0    = setup_ip_db_cl.ip_db[i].ip_vlan.parity0;
          vpr1       = setup_ip_db_cl.ip_db[i].ip_vlan.vpr1;
          vpr0       = setup_ip_db_cl.ip_db[i].ip_vlan.vpr0;
          vlan_tbln3 = setup_ip_db_cl.ip_db[i].ip_vlan.rdctblnum3;
          vlan_tbln2 = setup_ip_db_cl.ip_db[i].ip_vlan.rdctblnum2;
          vlan_tbln1 = setup_ip_db_cl.ip_db[i].ip_vlan.rdctblnum1;
          vlan_tbln0 = setup_ip_db_cl.ip_db[i].ip_vlan.rdctblnum0;
          addr = FFLP_VLAN_TBL_ADDRESS_RANGE + (i*8);

          gen_pio_drv.pio_rd(addr, rd_data);
          be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_vlan_table()",
            "AT VLAN TABLE INDEX %d, AT ADDRESS = %h, READ VLAN ENTRY VALUE = %h.\n",i,addr,rd_data);

          if ({parity1,parity0,vpr3,vlan_tbln3,vpr2,vlan_tbln2,vpr1,vlan_tbln1,vpr0,vlan_tbln0} !== rd_data[17:0])
            {
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_vlan_table()",
            "AT VLAN TABLE INDEX %d, AT ADDRESS = %h, READ VLAN ENTRY VALUE = %h, EXPECTED = %h.\n",
             i,addr,{rd_data[16],rd_data[7:0]},{parity1,parity0,vpr3,vlan_tbln3,vpr2,vlan_tbln2,vpr1,vlan_tbln1,vpr0,vlan_tbln0});
            }
          else
            {
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_vlan_table()",
            "AT VLAN TABLE INDEX %d, AT ADDRESS = %h, READ VLAN ENTRY VALUE MATCHED.\n",i,addr);
            }
         }
*/
 }

function bit [1:0] setup_cam_ram_fcram_class :: verify_vlan_tbl_parity (bit [11:0] hdr_vlan_id,
                                                                  bit [17:0] ip_db_vt_vlan,
                                                                  bit [17:0] rtl_vt_vlan)
 {
  bit rtl_vt_vlan_parity1 = 1'bx;
  bit rtl_vt_vlan_parity0 = 1'bx;
  integer vt_parity_cnt  = 0;
  integer vt_parity_cnt1 = 0;

      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::verify_vlan_tbl_parity\n",
       "IP_UTIL: HDR_VLAN_ID is %h, IP_DB_VT_VLAN is %h, RTL VLAN is %h.\n",
        hdr_vlan_id,ip_db_vt_vlan,rtl_vt_vlan);
     //@@@@@@@@@@@@@ Calculate VLAN Table Parity on the @@@@@@@@@@@@
     //@@@@@@@@@@@@@ VLAN Entry read from VLAN Table    @@@@@@@@@@@@
     //@@@@@@@@@@@@@ for VLAN RDC0/VPR0 & RDC1/VPR1     @@@@@@@@@@@@
          if (rtl_vt_vlan[0] === 1'b1)
            {
             vt_parity_cnt = vt_parity_cnt + 1;
            }
          if (rtl_vt_vlan[1] === 1'b1)
            {
             vt_parity_cnt = vt_parity_cnt + 1;
            }
          if (rtl_vt_vlan[2] === 1'b1)
            {
             vt_parity_cnt = vt_parity_cnt + 1;
            }
          if (rtl_vt_vlan[3] === 1'b1)
            {
             vt_parity_cnt = vt_parity_cnt + 1;
            }
          if (rtl_vt_vlan[4] === 1'b1)
            {
             vt_parity_cnt = vt_parity_cnt + 1;
            }
          if (rtl_vt_vlan[5] === 1'b1)
            {
             vt_parity_cnt = vt_parity_cnt + 1;
            }
          if (rtl_vt_vlan[6] === 1'b1)
            {
             vt_parity_cnt = vt_parity_cnt + 1;
            }
          if (rtl_vt_vlan[7] === 1'b1)
            {
             vt_parity_cnt = vt_parity_cnt + 1;
            }

          if (vt_parity_cnt === 1 || vt_parity_cnt === 3 || vt_parity_cnt === 5 || vt_parity_cnt === 7)
            {
             rtl_vt_vlan_parity0   = 1'b1;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::verify_vlan_tbl_parity\n",
              "IP_UTIL: RTL VLAN PARITY0 is %h (ODD) for VLAN ID = %h.\n",rtl_vt_vlan_parity0,hdr_vlan_id);
            }
          else
            {
             rtl_vt_vlan_parity0   = 1'b0;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::verify_vlan_tbl_parity\n",
              "IP_UTIL: RTL VLAN PARITY0 is %h (EVEN) for VLAN ID = %h.\n",rtl_vt_vlan_parity0,hdr_vlan_id);
            }

     //@@@@@@@@@@@@@ Compare Calculated Parity0 with @@@@@@@@@@@@
     //@@@@@@@@@@@@@ the parity0 in VLAN Table Entry @@@@@@@@@@@@
          if (rtl_vt_vlan[16] === rtl_vt_vlan_parity0)
            {
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::verify_vlan_tbl_parity\n",
              "IP_UTIL: RTL VLAN PARITY0 %h is correct for vlan id = %h.\n",rtl_vt_vlan[16],hdr_vlan_id);
             verify_vlan_tbl_parity[0] = 1'b0;
            }
          else
            {
             be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::verify_vlan_tbl_parity\n",
              "IP_UTIL: RTL VLAN PARITY0 %h is not correct for vlan id = %h.\n",rtl_vt_vlan[16],hdr_vlan_id);
             verify_vlan_tbl_parity[0] = 1'b1;
            }

     //@@@@@@@@@@@@@ Compare Parity0 from the VLAN Table entry @@@@@@@@@@@
     //@@@@@@@@@@@@@ with the one in ip_db VLAN Table Entry  @@@@@@@@@@@@
          if (rtl_vt_vlan[16] === ip_db_vt_vlan[16])
            {
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::verify_vlan_tbl_parity\n",
              "IP_UTIL: FOR VLAN ID %h, RTL VLAN PARITY0 %h matched IP_DB VLAN PARITY0 %h.\n",
               hdr_vlan_id,rtl_vt_vlan[16],ip_db_vt_vlan[16]);
             verify_vlan_tbl_parity[0] = 1'b0;
            }
          else
            {
             be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::verify_vlan_tbl_parity\n",
              "IP_UTIL: FOR VLAN ID %h, RTL VLAN PARITY0 %h did not matched IP_DB VLAN PARITY0 %h.\n",
               hdr_vlan_id,rtl_vt_vlan[16],ip_db_vt_vlan[16]);
             verify_vlan_tbl_parity[0] = 1'b1;
            }
    if (neptune_mode)
     {
     //@@@@@@@@@@@@@ Calculate VLAN Table Parity on the @@@@@@@@@@@@
     //@@@@@@@@@@@@@ VLAN Entry read from VLAN Table    @@@@@@@@@@@@
     //@@@@@@@@@@@@@ for VLAN RDC2/VPR2 & RDC3/VPR3     @@@@@@@@@@@@
          if (rtl_vt_vlan[8] === 1'b1)
            {
             vt_parity_cnt1 = vt_parity_cnt1 + 1;
            }
          if (rtl_vt_vlan[9] === 1'b1)
            {
             vt_parity_cnt1 = vt_parity_cnt1 + 1;
            }
          if (rtl_vt_vlan[10] === 1'b1)
            {
             vt_parity_cnt1 = vt_parity_cnt1 + 1;
            }
          if (rtl_vt_vlan[11] === 1'b1)
            {
             vt_parity_cnt1 = vt_parity_cnt1 + 1;
            }
          if (rtl_vt_vlan[12] === 1'b1)
            {
             vt_parity_cnt1 = vt_parity_cnt1 + 1;
            }
          if (rtl_vt_vlan[13] === 1'b1)
            {
             vt_parity_cnt1 = vt_parity_cnt1 + 1;
            }
          if (rtl_vt_vlan[14] === 1'b1)
            {
             vt_parity_cnt1 = vt_parity_cnt1 + 1;
            }
          if (rtl_vt_vlan[15] === 1'b1)
            {
             vt_parity_cnt1 = vt_parity_cnt1 + 1;
            }

          if (vt_parity_cnt1 === 1 || vt_parity_cnt1 === 3 || vt_parity_cnt1 === 5 || vt_parity_cnt1 === 7)
            {
             rtl_vt_vlan_parity1   = 1'b1;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::verify_vlan_tbl_parity\n",
              "IP_UTIL: RTL VLAN PARITY1 is %h (ODD) for VLAN ID = %h.\n",rtl_vt_vlan_parity1,hdr_vlan_id);
            }
          else
            {
             rtl_vt_vlan_parity1   = 1'b0;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::verify_vlan_tbl_parity\n",
              "IP_UTIL: RTL VLAN PARITY1 is %h (EVEN) for VLAN ID = %h.\n",rtl_vt_vlan_parity1,hdr_vlan_id);
            }

     //@@@@@@@@@@@@@ Compare Calculated Parity1 with @@@@@@@@@@@@
     //@@@@@@@@@@@@@ the parity1 in VLAN Table Entry @@@@@@@@@@@@
          if (rtl_vt_vlan[17] === rtl_vt_vlan_parity1)
            {
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::verify_vlan_tbl_parity\n",
              "IP_UTIL: RTL VLAN PARITY1 %h is correct for vlan id = %h.\n",rtl_vt_vlan[17],hdr_vlan_id);
             verify_vlan_tbl_parity[1] = 1'b0;
            }
          else
            {
             be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::verify_vlan_tbl_parity\n",
              "IP_UTIL: RTL VLAN PARITY1 %h is not correct for vlan id = %h.\n",rtl_vt_vlan[17],hdr_vlan_id);
             verify_vlan_tbl_parity[1] = 1'b1;
            }

     //@@@@@@@@@@@@@ Compare Parity1 from the VLAN Table entry @@@@@@@@@@@
     //@@@@@@@@@@@@@ with the one in ip_db VLAN Table Entry  @@@@@@@@@@@@
          if (rtl_vt_vlan[17] === ip_db_vt_vlan[17])
            {
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::verify_vlan_tbl_parity\n",
              "IP_UTIL: FOR VLAN ID %h, RTL VLAN PARITY1 %h matched IP_DB VLAN PARITY1 %h.\n",
               hdr_vlan_id,rtl_vt_vlan[17],ip_db_vt_vlan[17]);
             verify_vlan_tbl_parity[1] = 1'b0;
            }
          else
            {
             be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::verify_vlan_tbl_parity\n",
              "IP_UTIL: FOR VLAN ID %h, RTL VLAN PARITY1 %h did not matched IP_DB VLAN PARITY1 %h.\n",
               hdr_vlan_id,rtl_vt_vlan[17],ip_db_vt_vlan[17]);
             verify_vlan_tbl_parity[1] = 1'b1;
            }
     }
    else
     {
      verify_vlan_tbl_parity[1] = 1'b0;
     }
 }

task setup_cam_ram_fcram_class :: setup_fcram()
{

 bit [39:0]  addr;
 bit [63:0]  wr_data;
 integer     i;

  for (i=0;i<8;i++)
    {
     addr      = (FFLP_FLOW_ADDRESS_RANGE + FFLP_FLOW_PARTITION_SEL) + (i*8);
     wr_data   = {47'h0,EXT_LOOKUP[i],16'h0};
//   gen_pio_drv.pio_wr(addr, wr_data);   
     fflp_util.fflp_pio_wrapper(addr, wr_data);   
    }

  if (get_plus_arg (CHECK, "PROGRAM_FCRAM"))
    {
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::new()",
      "Calling setup_fcram task to setup FCRAM.\n");
     program_fcram();
    }
  else
    {
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::new()",
      "No FCRAM Mode, Skip Calling setup_fcram task to setup FCRAM.\n");
    }
}

function bit [199:0] setup_cam_ram_fcram_class :: get_cam_lmask (integer cam_index,
                                                                 bit tuple_type,
                                                                 bit [19:0] cam_lmask_fields)
 {
  integer     mask_field = 0;

           if (cam_index === cam_lmask_fields[19:12])
             {
              if (cam_lmask_fields[10])   // Random cam_lmask
                {
                 mask_field = random_value7%8;
                 case (mask_field)
                  {
                   0:
                     {
                      get_cam_lmask = CAM_LMASK_CLS_CODE;
                      
                     }
                   1:
                     {
                      get_cam_lmask = CAM_LMASK_L2RDC;   
                      
                     }
                   2:
                     {
                      get_cam_lmask = CAM_LMASK_NOPORT;  
                      
                     }
                   3:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_TOS;
                     
                     }
                   4:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID;
                      
                     }
                   5:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI;
                      
                     }
                   6:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   7:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   default:
                     {
                      get_cam_lmask = CAM_NO_LMASK;
                     }
                  } 
                }  // if (cam_lmask_fields[10])
              else // Assigned cam_lmask
                {
                 case (cam_lmask_fields[7:0])
                  {
                   8'h00:
                     {
                      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
                        "FOR IP_DB[%d], No MAsking is done for CAM_LMASK.\n",i);
                      get_cam_lmask = CAM_NO_LMASK;
                     }
                   8'h01:
                     {
                      get_cam_lmask = CAM_LMASK_CLS_CODE;
                     }
                   8'h02:
                     {
                      get_cam_lmask = CAM_LMASK_L2RDC;   
                     }
                   8'h03:
                     {
                      get_cam_lmask = CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                     }
                   8'h04:
                     {
                      get_cam_lmask = CAM_LMASK_NOPORT;  
                     }
                   8'h05:
                     {
                      get_cam_lmask = CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                     }
                   8'h06:
                     {
                      get_cam_lmask = CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                     }
                   8'h07:
                     {
                      get_cam_lmask = CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                     }
                   8'h08:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_TOS;
                     }
                   8'h09:
                     {
                      get_cam_lmask = CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                     }
                   8'h0a:
                     {
                      get_cam_lmask = CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                     }
                   8'h0b:
                     {
                      get_cam_lmask = CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                     }
                   8'h0c:
                     {
                      get_cam_lmask = CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h0d:
                     {
                      get_cam_lmask = CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h0e:
                     {
                      get_cam_lmask = CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h0f:
                     {
                      get_cam_lmask = CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h10:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID;
                     }
                   8'h11:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE;
                     }
                   8'h12:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L2RDC;   
                     }
                   8'h13:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                     }
                   8'h14:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_NOPORT;  
                     }
                   8'h15:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                     }
                   8'h16:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                     }
                   8'h17:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                     }
                   8'h18:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_TOS;
                     }
                   8'h19:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                     }
                   8'h1a:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                     }
                   8'h1b:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                     }
                   8'h1c:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h1d:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h1e:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h1f:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h20:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI;
                     }
                   8'h21:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI &  CAM_LMASK_CLS_CODE;
                     }
                   8'h22:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_L2RDC;   
                     }
                   8'h23:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                     }
                   8'h24:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_NOPORT;  
                     }
                   8'h25:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                     }
                   8'h26:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                     }
                   8'h27:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                     }
                   8'h28:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_L4PT_TOS;
                     }
                   8'h29:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                     }
                   8'h2a:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                     }
                   8'h2b:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                     }
                   8'h2c:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h2d:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h2e:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h2f:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h30:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI;
                     }
                   8'h31:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI &  CAM_LMASK_CLS_CODE;
                     }
                   8'h32:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_L2RDC;   
                     }
                   8'h33:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                     }
                   8'h34:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_NOPORT;  
                     }
                   8'h35:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                     }
                   8'h36:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                     }
                   8'h37:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                     }
                   8'h38:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_L4PT_TOS;
                     }
                   8'h39:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                     }
                   8'h3a:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                     }
                   8'h3b:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                     }
                   8'h3c:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h3d:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h3e:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h3f:
                     {
                      get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                     }
                   8'h40:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h41:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h42:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h43:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h44:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h45:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h46:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h47:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h48:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h49:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h4a:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h4b:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h4c:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h4d:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h4e:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h4f:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h50:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h51:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h52:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_L2RDC;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h53:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;
                         be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
                           "FOR IP_DB[%d], RUNTIME ARG for MASK_TCAM_FIELDS= %h is not correct.\n",i,cam_lmask_fields);
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h54:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_NOPORT;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h55:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;
                         be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
                           "FOR IP_DB[%d], RUNTIME ARG for MASK_TCAM_FIELDS= %h is not correct.\n",i,cam_lmask_fields);
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h56:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h57:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h58:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h59:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h5a:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h5b:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h5c:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h5d:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h5e:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h5f:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_PID & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h60:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h61:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h62:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h63:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h64:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h65:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h66:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h67:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h68:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h69:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h6a:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h6b:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h6c:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h6d:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h6e:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h6f:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h70:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h71:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h72:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h73:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h74:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h75:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h76:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h77:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h78:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h79:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h7a:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h7b:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h7c:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h7d:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h7e:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h7f:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h80:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h81:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h82:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h83:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h84:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h85:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h86:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h87:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h88:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h89:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h8a:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h8b:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h8c:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h8d:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h8e:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h8f:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h90:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h91:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h92:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h93:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h94:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h95:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h96:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h97:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h98:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h99:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h9a:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h9b:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h9c:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h9d:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h9e:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'h9f:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'ha0:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'ha1:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'ha2:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'ha3:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'ha4:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'ha5:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'ha6:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'ha7:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'ha8:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'ha9:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'haa:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hab:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hac:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'had:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hae:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'haf:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hb0:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hb1:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hb2:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hb3:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hb4:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hb5:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hb6:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hb7:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hb8:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hb9:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hba:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hbb:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hbc:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hbd:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hbe:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hbf:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hc0:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hc1:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hc2:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hc3:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hc4:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hc5:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hc6:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hc7:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hc8:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hc9:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hca:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hcb:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hcc:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hcd:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hce:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hcf:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hd0:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hd1:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hd2:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hd3:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hd4:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hd5:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hd6:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hd7:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hd8:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hd9:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hda:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hdb:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hdc:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hdd:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hde:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hdf:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'he0:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'he1:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'he2:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'he3:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'he4:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'he5:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'he6:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'he7:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'he8:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'he9:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hea:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'heb:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hec:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hed:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hee:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hef:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hf0:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hf1:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hf2:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hf3:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC;   
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hf4:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hf5:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hf6:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hf7:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT;  
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hf8:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L4PT_TOS;
                         be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
                           "FOR IP_DB[%d], RUNTIME ARG for MASK_TCAM_FIELDS= %h is not correct.\n",i,cam_lmask_fields);
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hf9:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hfa:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hfb:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hfc:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                         be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::setup_cam_ram()",
                           "FOR IP_DB[%d], RUNTIME ARG for MASK_TCAM_FIELDS= %h is not correct.\n",i,cam_lmask_fields);
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hfd:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hfe:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                   8'hff:
                     {
                      if (tuple_type === 1'b0)  // 5tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV4_SRC_ADDR & CAM_LMASK_IPV4_DST_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else if (tuple_type === 1'b1)  // 4tuple
                        {
                         get_cam_lmask = CAM_LMASK_L4PT_PID & CAM_LMASK_L4PT_SPI & CAM_LMASK_IPV6_ADDR & CAM_LMASK_CLS_CODE & CAM_LMASK_L2RDC & CAM_LMASK_NOPORT & CAM_LMASK_L4PT_TOS;
                        }
                      else
                        {
                         get_cam_lmask = CAM_NO_LMASK;
                        }
                     }
                  }   // case (cam_lmask_fields[7:0])
                }  // else //  Assigned cam_lmask
             }  // if (cam_index === cam_lmask_fields[19:12])   <--- if the cam key is targeted for masking

 }

function Cpkt_info setup_cam_ram_fcram_class :: construct_flow (integer pkt_num, bit [1:0] tcp_flag, (flow_desc flow_in = null))
{
 
  bit [2:0] mac_port = 3'bxxx;
  integer   mac_prt;
  flow_desc flow;
  bit [12:0] predicted_zcp_dma_chnl_offset;

  Cpkt_info pkt_info;


  mac_port = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_mac.mac_port;
    if      (mac_port == 3'b000)
       {    
        mac_prt = 0;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
         "IP_PKT_GEN: Packet transmitted to MAC Port %h.\n",mac_port);
       } 
    else if (mac_port == 3'b001)
       { 
        mac_prt = 1;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
         "IP_PKT_GEN: Packet transmitted to MAC Port %h.\n",mac_port);
       } 
    else if (mac_port == 3'b010)
       { 
        mac_prt = 2;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
         "IP_PKT_GEN: Packet transmitted to MAC Port %h.\n",mac_port);
       } 
    else if (mac_port == 3'b100)
       { 
        mac_prt = 3;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
         "IP_PKT_GEN: Packet transmitted to MAC Port %h.\n",mac_port);
       }
    else
      {
       be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::construct_flow()",
         "IP_PKT_GEN: Unknown MAC Port %h.\n",mac_port);
      }
    if (get_plus_arg (CHECK, "FFLP_TEST"))
      flow = new;
    else
      flow = flow_in;
    
      pkt_info = new;
//STARTKHOSROW
/*
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@ Definition of run arg CAM_HIT_MODE = {DO PIO,NO CAM MATCH,CAM MATCH HIT TYPE} (Hex)         @@
//@@ "X" = run arg NUM_OF_SPECIFIC_CAM_HITS (integer)                                            @@
//@@ run arg SPECIFIC_CAM_ENTRY_HIT (integer)                                                    @@
//@@ NOTE: For N2 NUM_OF_CAM_ENTRIES = 128                                                       @@
//@@       For NEPTUNE NUM_OF_CAM_ENTRIES = 256                                                  @@
//@@  +========================================================================================+ @@
//@@  |     |        | NO CAM    | CAM MATCH |                                                 | @@
//@@  |CASE | DO PIO | MATCH     | HIT TYPE  | DESCRIPTION                                     | @@
//@@  +======================================================================================= | @@
//@@  | A1  |  0     |    0      |    000    | Packets hit no cam match.                       | @@ 
//@@  | A2  |  0     |    0      |    001    | Packets hit cam entries 0-127 in sequence order.| @@ 
//@@  | A3  |  0     |    0      |    010    | Packets hit cam entries 127-0 in sequence order.| @@ 
//@@  | A4  |  0     |    0      |    011    | Packets hit a specific cam entry   by run_arg.  | @@ 
//@@  | A5  |  0     |    0      |    100    | "X" Packets in a row hit a specific cam entrry  | @@ 
//@@  |     |        |           |           | then hit a random cam entry.                    | @@ 
//@@  | A6  |  0     |    0      |    101    | Reserved.                                       | @@ 
//@@  | A7  |  0     |    0      |    110    | Reserved.                                       | @@ 
//@@  | A8  |  0     |    0      |    111    | Packets hit random entry in the cam.            | @@ 
//@@  |-----|--------|-----------|-----------|-------------------------------------------------| @@
//@@  | B1  |  0     |    1      |    000    | Same as case A1.                                | @@ 
//@@  | B2  |  1     |    0      |    000    | Packets hit no cam match with PIO in the middle.| @@ 
//@@  | B3  |  1     |    1      |    000    | Same as case B2.                                | @@ 
//@@  |-----|--------|-----------|-----------|-------------------------------------------------| @@
//@@  | C1  |  0     |    1      |    001    | Packets hit cam entries 0-127 in sequence order | @@ 
//@@  |     |        |           |           | ,transmit a no cam match packet after every 5   | @@ 
//@@  |     |        |           |           | or less (random) cam match packet.              | @@ 
//@@  | C2  |  1     |    0      |    001    | Packets hit cam entries 0-127 in sequence order | @@ 
//@@  |     |        |           |           | and issue a pio transaction after sending 5     | @@ 
//@@  |     |        |           |           | or less (random) cam match packet.              | @@ 
//@@  | C3  |  1     |    1      |    001    | Packets hit cam entries 0-127 in sequence order | @@ 
//@@  |     |        |           |           | ,transmit a no cam match packet and issue a pio | @@
//@@  |     |        |           |           | transaction after sending 5 or less (random)    | @@ 
//@@  |     |        |           |           | cam match packet.                               | @@ 
//@@  |-----|--------|-----------|-----------|-------------------------------------------------| @@
//@@  | D1  |  0     |    1      |    010    | Packets hit cam entries 127-0 in sequence order | @@ 
//@@  |     |        |           |           | ,transmit a no cam match packet after every 5   | @@ 
//@@  |     |        |           |           | or less (random) cam match packet.              | @@ 
//@@  | D2  |  1     |    0      |    010    | Packets hit cam entries 127-0 in sequence order | @@ 
//@@  |     |        |           |           | and issue a pio transaction after sending 5     | @@ 
//@@  |     |        |           |           | or less (random) cam match packet.              | @@ 
//@@  | D3  |  1     |    1      |    010    | Packets hit cam entries 127-0 in sequence order | @@ 
//@@  |     |        |           |           | ,transmit a no cam match packet and issue a pio | @@ 
//@@  |     |        |           |           | transaction after sending 5 or less (random)    | @@ 
//@@  |     |        |           |           | cam match packet.                               | @@ 
//@@  |-----|--------|-----------|-----------|-------------------------------------------------| @@
//@@  | E1  |  0     |    1      |    011    | Packets hit a specific cam entry                | @@ 
//@@  |     |        |           |           | ,transmit a no cam match packet after every 5   | @@ 
//@@  |     |        |           |           | or less (random) cam match packet.              | @@ 
//@@  | E2  |  1     |    0      |    011    | Packets hit a specific cam entry                | @@ 
//@@  |     |        |           |           | and issue a pio transaction after sending 5     | @@ 
//@@  |     |        |           |           | or less (random) cam match packet.              | @@ 
//@@  | E3  |  1     |    1      |    011    | Packets hit a specific cam entry                | @@ 
//@@  |     |        |           |           | ,transmit a no cam match packet and issue a pio | @@ 
//@@  |     |        |           |           | transaction after sending 5 or less (random)    | @@ 
//@@  |     |        |           |           | cam match packet.                               | @@ 
//@@  |-----|--------|-----------|-----------|-------------------------------------------------| @@
//@@  | F1  |  0     |    1      |    100    | "X" Packets in a row hit a specific cam entry   | @@ 
//@@  |     |        |           |           | ,then hit a random cam entry                    | @@ 
//@@  |     |        |           |           | ,transmit a no cam match packet after every 5   | @@ 
//@@  |     |        |           |           | or less (random) cam match packet.              | @@ 
//@@  | F2  |  1     |    0      |    100    | "X" Packets in a row hit a specific cam entry   | @@ 
//@@  |     |        |           |           | ,then hit a random cam entry                    | @@ 
//@@  |     |        |           |           | and issue a pio transaction after sending 5     | @@ 
//@@  |     |        |           |           | or less (random) cam match packet.              | @@ 
//@@  | F3  |  1     |    1      |    100    | "X" Packets in a row hit a specific cam entry   | @@ 
//@@  |     |        |           |           | ,then hit a random cam entry                    | @@ 
//@@  |     |        |           |           | ,transmit a no cam match packet and issue a pio | @@ 
//@@  |     |        |           |           | transaction after sending 5 or less (random)    | @@ 
//@@  |     |        |           |           | cam match packet.                               | @@ 
//@@  |-----|--------|-----------|-----------|-------------------------------------------------| @@
//@@  | G1  |  0     |    1      |    101    | Reserved.                                       | @@ 
//@@  | G2  |  1     |    0      |    101    | Reserved.                                       | @@ 
//@@  | G3  |  1     |    1      |    101    | Reserved.                                       | @@ 
//@@  |-----|--------|-----------|-----------|-------------------------------------------------| @@
//@@  | H1  |  0     |    1      |    110    | Reserved.                                       | @@ 
//@@  | H2  |  1     |    0      |    110    | Reserved.                                       | @@ 
//@@  | H3  |  1     |    1      |    110    | Reserved.                                       | @@ 
//@@  |-----|--------|-----------|-----------|-------------------------------------------------| @@
//@@  | I1  |  0     |    1      |    111    | Packets hit random entry in the cam             | @@ 
//@@  |     |        |           |           | ,transmit a no cam match packet after every 5   | @@ 
//@@  |     |        |           |           | or less (random) cam match packet.              | @@ 
//@@  | I2  |  1     |    0      |    111    | Packets hit random entry in the cam             | @@ 
//@@  |     |        |           |           | and issue a pio transaction after sending 5     | @@ 
//@@  |     |        |           |           | or less (random) cam match packet.              | @@ 
//@@  | I3  |  1     |    1      |    111    | Packets hit random entry in the cam             | @@ 
//@@  |     |        |           |           | ,transmit a no cam match packet and issue a pio | @@ 
//@@  |     |        |           |           | transaction after sending 5 or less (random)    | @@ 
//@@  |     |        |           |           | cam match packet.                               | @@ 
//@@  *----------------------------------------------------------------------------------------* @@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
if (get_plus_arg (CHECK, "CAM_HIT_MODE="))
  {
   cam_hit_mode = get_plus_arg (HNUM, "CAM_HIT_MODE=");
  
   case (cam_hit_mode)
    {   
     flow.frame.frame_type         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_frame.frame_type;
     flow.frame.frame_class        = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_frame.frame_class;
     flow.frame.tunnel_type        = 0;
     flow.frame.type               = -1;
//   flow.frame.tpid               = 0;
     flow.frame.class_mask         = NONE;
     flow.frame.class_funct        = CLF_SRC;
     flow.frame.data_type          = DAT_SEQ | DAT_LEN_EXACT;
     flow.frame.data_seed          = 0;

     flow.dst_node.l2_addr         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_dst_node.l2_addr;
     flow.dst_node.tci             = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_dst_node.tci;
    

     flow.src_node.l2_addr         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.l2_addr;
     flow.src_node.tci             = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.tci;
     flow.dst_node.ip_addr         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_dst_node.ip_addr;
     flow.dst_node.ipv6_addr       = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_dst_node.ipv6_addr;

     flow.src_node.ip_addr         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.ip_addr;
     flow.src_node.ipv6_addr       = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.ipv6_addr;
     flow.src_node.spi             = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.spi;
     flow.src_node.tos             = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.tos;

     flow.tup.src_tcp_udp_port     = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tup.src_tcp_udp_port;
     flow.tup.dst_tcp_udp_port     = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tup.dst_tcp_udp_port;

    flow.rx_param.rcv_isn         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_rx_param.rcv_isn;
    flow.rx_param.last_ackno      = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_rx_param.last_ackno;
    flow.rx_param.timeout         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_rx_param.timeout;
    flow.rx_param.rmt_window_size = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_rx_param.rmt_window_size;

    flow.tx_param.adv_isn         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tx_param.adv_isn;
    flow.tx_param.last_seqno      = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tx_param.last_seqno;
    flow.tx_param.retr_timeout    = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tx_param.retr_timeout;
    flow.tx_param.adv_window_size = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tx_param.adv_window_size;

    flow.fl_state.tcp_flags       = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_fl_state.tcp_flags;
    flow.fl_state.tcp_st          = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_fl_state.tcp_st;

    flow.fl_state.tcp_flags       = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_fl_state.tcp_flags;
    flow.fl_state.tcp_st          = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_fl_state.tcp_st;

    flow.flow_no                  = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_flow_no;
*/
//ENDKHOSROW
if (get_plus_arg (CHECK, "FFLP_TEST")) {
    flow.frame.frame_type         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_frame.frame_type;
    flow.frame.frame_class        = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_frame.frame_class;
    flow.frame.tunnel_type        = 0;
    flow.frame.type               = -1;
//  flow.frame.tpid               = 0;
    flow.frame.class_mask         = NONE;
    flow.frame.class_funct        = CLF_SRC;
    flow.frame.data_type          = DAT_SEQ | DAT_LEN_EXACT;
    flow.frame.data_seed          = 0;
    flow.frame.header_length      = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_frame.header_length;

    flow.dst_node.l2_addr         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_dst_node.l2_addr;
    flow.dst_node.tci             = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_dst_node.tci;
    

    flow.src_node.l2_addr         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.l2_addr;

    if (setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_frame.frame_type[0] === 1'b1)
      {
       pkt_info.llcsnap = 1'b1;
      }
    else // Not a LLC_SNAP Packet
      {
       pkt_info.llcsnap = 1'b0;
      }

    if (setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_frame.frame_type[1] === 1'b1)
      {
       pkt_info.badip = 1'b0;
      }
    else // Not an ip packet 
      {
       pkt_info.badip = 1'b1;
      }

    if (setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_frame.frame_type[2] === 1'b1)
      {
       flow.src_node.tci             = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.tci;
       pkt_info.vlan = 1'b1;
      }
    else // Not tagged packet
      {
       flow.src_node.tci             = 15'h0;
       pkt_info.vlan = 1'b0;
      }

    if (setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_frame.frame_type[3] === 1'b1)
      {
       pkt_info.ip_version = 1'b1;
      }
    else // IPV4
      {
       pkt_info.ip_version = 1'b0;
      }
//  if (get_plus_arg (CHECK, "NO_CAM_MATCH"))
//    {
//     flow.dst_node.ip_addr         = (setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_dst_node.ip_addr) * (pkt_num+2);
//     flow.dst_node.ipv6_addr       = (setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_dst_node.ipv6_addr) * (pkt_num+2);

//     flow.src_node.ip_addr         = (setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.ip_addr) * (pkt_num+2);
//     flow.src_node.ipv6_addr       = (setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.ipv6_addr) * (pkt_num+2);
//     flow.src_node.spi             = (setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.spi) * (pkt_num+2);
//     flow.src_node.tos             = (setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.tos) * (pkt_num+2);

//     flow.tup.src_tcp_udp_port     = (setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tup.src_tcp_udp_port) * (pkt_num+2);
//     flow.tup.dst_tcp_udp_port     = (setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tup.dst_tcp_udp_port) * (pkt_num+2);
//    }
//  else 
//    {
       flow.dst_node.ip_addr         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_dst_node.ip_addr;
       flow.dst_node.ipv6_addr       = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_dst_node.ipv6_addr;

       flow.src_node.ip_addr         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.ip_addr;
       flow.src_node.ipv6_addr       = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.ipv6_addr;
       flow.src_node.spi             = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.spi;
       flow.src_node.tos             = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.tos;

       flow.tup.src_tcp_udp_port     = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tup.src_tcp_udp_port;
       flow.tup.dst_tcp_udp_port     = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tup.dst_tcp_udp_port;
//    }

    flow.rx_param.rcv_isn         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_rx_param.rcv_isn;
    flow.rx_param.last_ackno      = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_rx_param.last_ackno;
    flow.rx_param.timeout         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_rx_param.timeout;
    flow.rx_param.rmt_window_size = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_rx_param.rmt_window_size;

    flow.tx_param.adv_isn         = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tx_param.adv_isn;
    flow.tx_param.last_seqno      = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tx_param.last_seqno;
    flow.tx_param.retr_timeout    = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tx_param.retr_timeout;
    flow.tx_param.adv_window_size = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tx_param.adv_window_size;

    if (tcp_flag === TCP_SYN)
      {
       flow.fl_state.tcp_flags       = 6'b000010;
      }
    else if (tcp_flag === TCP_FLAG)
      {
       flow.fl_state.tcp_flags       = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_fl_state.tcp_flags;
      }
    else if (tcp_flag === TCP_FIN)
      {
       flow.fl_state.tcp_flags       = 6'b000001;
      }
    else
      {
       flow.fl_state.tcp_flags       = 6'b000010;
      }

    pkt_info.solicited_event_bit = |flow.fl_state.tcp_flags;
 
    flow.fl_state.tcp_st          = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_fl_state.tcp_st;

    flow.flow_no                  = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_flow_no;
}
//DEBUG MESSAGE
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_frame.frame_type = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_frame.frame_type);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_frame.frame_class = %d\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_frame.frame_class);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_dst_node.l2_addr = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_dst_node.l2_addr);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_dst_node.tci = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_dst_node.tci);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_dst_node.ip_addr = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_dst_node.ip_addr);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_dst_node.ipv6_addr = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_dst_node.ipv6_addr);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_src_node.l2_addr = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.l2_addr);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_src_node.tci = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.tci);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_src_node.ip_addr = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.ip_addr);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_src_node.ipv6_addr = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.ipv6_addr);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_src_node.spi = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_src_node.spi);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_tup.src_tcp_udp_port = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tup.src_tcp_udp_port);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_tup.dst_tcp_udp_port = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tup.dst_tcp_udp_port);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_rx_param.rcv_isn = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_rx_param.rcv_isn);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_rx_param.last_ackno = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_rx_param.last_ackno);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_rx_param.timeout = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_rx_param.timeout);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_rx_param.rmt_window_size = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_rx_param.rmt_window_size);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_tx_param.adv_isn = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tx_param.adv_isn);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_tx_param.last_seqno = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tx_param.last_seqno);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_tx_param.retr_timeout = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tx_param.retr_timeout);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_tx_param.adv_window_size = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_tx_param.adv_window_size);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_fl_state.tcp_flags = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_fl_state.tcp_flags);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_fl_state.tcp_st = %h\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_fl_state.tcp_st);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
      "SETUP_IP_DB_CLASS setup_ip_db_cl.ip_db[%d].ip_flow_no = %d\n",pkt_num,setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].ip_flow_no);
  
 //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 //@@@@@@@   Predict DMA Channel to be handed to Cpkt_info  @@@@@@@
 //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 //Description of the code
 //MAC RDC
 //================================================
 //In ip_ingress_db.vr
 //
 //setup_ip_db_cl.ip_db[j].ip_mac.mac_port             = 3'b000;
 //setup_ip_db_cl.ip_db[j].ip_mac.mac_speed            = 2'b11;
 //setup_ip_db_cl.ip_db[j].ip_mac.mac_da               = pkt_mac_da[j%16];
 //setup_ip_db_cl.ip_db[j].ip_mac.mac_rdctblnum        = pkt_mac_rdctblnum[j%16];
 //setup_ip_db_cl.ip_db[j].ip_mac.mac_mpr              = pkt_mac_mpr[j%16];
 //VLAN RDC
 //================================================
 //
 //1. From ip_util.vr approach
 // if (packet_frame_type[2])  1. search in VLAN Table to find the hit
 //                            2. Verify the parity for the hit entry
 //                            3. if not parity error choose the VLAN RDC TBL NUM
 //                               if parity just choose the MAC RDC TBL NUM
 //setup_ip_db_cl.setup_ip_db_cl.ip_db[4096].ip_vlan.parity0;
 //setup_ip_db_cl.setup_ip_db_cl.ip_db[4096].ip_vlan.rdctblnum0;
 //setup_ip_db_cl.setup_ip_db_cl.ip_db[4096].ip_vlan.vpr0;
 //setup_ip_db_cl.setup_ip_db_cl.ip_db[4096].ip_vlan.rdctblnum1;
 //setup_ip_db_cl.setup_ip_db_cl.ip_db[4096].ip_vlan.vpr1;
 //
 //call the function below when the vlan
 //entry is a hit to qualify the entry.
 //
 //  vlan_parity_error = verify_vlan_tbl_parity (packet_tci[11:0], ip_db_vt_vlan, rd_data[17:0]);
 //
 //2. From ip_ingress_db.vr approach
 //setup_ip_db_cl.ip_db_vt_parity0[4096];
 //setup_ip_db_cl.ip_db_vt_vpr0[4096];
 //setup_ip_db_cl.ip_db_vt_rdctblnum0[4096];
 //setup_ip_db_cl.ip_db_vt_vpr1[4096];
 //setup_ip_db_cl.ip_db_vt_rdctblnum1[4096];
 //
 //call/generate similar function such as the one in ip_util.vr when the vlan
 //entry is a hit to qualify the entry.
 //
 //  vlan_parity_error = verify_vlan_tbl_parity (packet_tci[11:0], ip_db_vt_vlan, rd_data[17:0]);
 //
 //CAM RDC
 //================================================
 //bit [199:0] shadow_cam_key [256];
 //bit [199:0] shadow_cam_lmask [256];
 //bit [63:0]  shadow_adata [256];
 //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

pkt_info.prog_class7_4_match = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].prog_class7_4_matched;
pkt_info.prog_class3_2_match = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].prog_class3_2_matched;
pkt_info.packet_class     = setup_ip_db_cl.ip_db[pkt_num%IP_DB_ENTRIES].pkt_class;

be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
  "SETUP_IP_DB_CLASS INFO: FOR PKT_NUM = %d, PKT_INFO.PACKET_CLASS = %d.\n",pkt_num,pkt_info.packet_class);
be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
  "SETUP_IP_DB_CLASS INFO: FOR PKT_NUM = %d, FLOW.FRAME.FRAME_CLASS = %d.\n",pkt_num,flow.frame.frame_class);

//case (pkt_info.packet_class)
case (flow.frame.frame_class)
    {
     CL_TCP:{
             pkt_info.protocol = PROTOCOL_TCP;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
               "SETUP_IP_DB_CLASS INFO:0 FOR PKT_NUM = %d, PKT_INFO.PROTOCOL = %h.\n",pkt_num,pkt_info.protocol);
             pkt_info.L4_protocol = 2'b01;
             pkt_info.tcp_seq_num = flow.tx_param.last_seqno;
            }  
     CL_UDP:{
             pkt_info.protocol = PROTOCOL_UDP;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
               "SETUP_IP_DB_CLASS INFO:1 FOR PKT_NUM = %d, PKT_INFO.PROTOCOL = %h.\n",pkt_num,pkt_info.protocol);
             pkt_info.L4_protocol = 2'b10;
             pkt_info.tcp_seq_num = 32'h0;
            }  
     CL_TCP_FRAG:{
             pkt_info.protocol = PROTOCOL_TCP;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
               "SETUP_IP_DB_CLASS INFO:0 FOR PKT_NUM = %d, PKT_INFO.PROTOCOL = %h.\n",pkt_num,pkt_info.protocol);
             pkt_info.L4_protocol = 2'b01;
             pkt_info.tcp_seq_num = flow.tx_param.last_seqno;
            }  
     CL_UDP_FRAG:{
             pkt_info.protocol = PROTOCOL_UDP;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
               "SETUP_IP_DB_CLASS INFO:1 FOR PKT_NUM = %d, PKT_INFO.PROTOCOL = %h.\n",pkt_num,pkt_info.protocol);
             pkt_info.L4_protocol = 2'b10;
             pkt_info.tcp_seq_num = 32'h0;
            }  
     CL_IP_SEC_AH:
            {
             pkt_info.protocol = PROTOCOL_IPSEC_AH;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
               "SETUP_IP_DB_CLASS INFO:2 FOR PKT_NUM = %d, PKT_INFO.PROTOCOL = %h.\n",pkt_num,pkt_info.protocol);
             pkt_info.L4_protocol = 2'b00;
             pkt_info.tcp_seq_num = 32'h0;
            }  
     CL_IP_SEC_ESP:
            {
             pkt_info.protocol = PROTOCOL_IPSEC_ESP;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
               "SETUP_IP_DB_CLASS INFO:3 FOR PKT_NUM = %d, PKT_INFO.PROTOCOL = %h.\n",pkt_num,pkt_info.protocol);
             pkt_info.L4_protocol = 2'b00;
             pkt_info.tcp_seq_num = 32'h0;
            }  
//   CL_SCTP_IP_V4:
//          {
//           pkt_info.protocol = PROTOCOL_SCTP;
//           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
//             "SETUP_IP_DB_CLASS INFO:4 FOR PKT_NUM = %d, PKT_INFO.PROTOCOL = %h.\n",pkt_num,pkt_info.protocol);
//           pkt_info.L4_protocol = 2'b11;
//           pkt_info.tcp_seq_num = 32'h0;
//          }  
     CL_TCP_IP_V6:{
             pkt_info.protocol = PROTOCOL_TCP;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
               "SETUP_IP_DB_CLASS INFO:5 FOR PKT_NUM = %d, PKT_INFO.PROTOCOL = %h.\n",pkt_num,pkt_info.protocol);
             pkt_info.L4_protocol = 2'b01;
             pkt_info.tcp_seq_num = flow.tx_param.last_seqno;
            }
     CL_UDP_IP_V6:{
             pkt_info.protocol = PROTOCOL_UDP;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
               "SETUP_IP_DB_CLASS INFO:6 FOR PKT_NUM = %d, PKT_INFO.PROTOCOL = %h.\n",pkt_num,pkt_info.protocol);
             pkt_info.L4_protocol = 2'b10;
             pkt_info.tcp_seq_num = 32'h0;
            }
     CL_IP_V6_SEC_AH:{
             pkt_info.protocol = PROTOCOL_IPSEC_AH;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
               "SETUP_IP_DB_CLASS INFO:7 FOR PKT_NUM = %d, PKT_INFO.PROTOCOL = %h.\n",pkt_num,pkt_info.protocol);
             pkt_info.L4_protocol = 2'b00;
             pkt_info.tcp_seq_num = 32'h0;
            }
     CL_IP_V6_SEC_ESP:{
             pkt_info.protocol = PROTOCOL_IPSEC_ESP;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
               "SETUP_IP_DB_CLASS INFO:8 FOR PKT_NUM = %d, PKT_INFO.PROTOCOL = %h.\n",pkt_num,pkt_info.protocol);
             pkt_info.L4_protocol = 2'b00;
             pkt_info.tcp_seq_num = 32'h0;
            }
//   CL_SCTP_IP_V6:{
//           pkt_info.protocol = PROTOCOL_SCTP;
//           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
//             "SETUP_IP_DB_CLASS INFO:9 FOR PKT_NUM = %d, PKT_INFO.PROTOCOL = %h.\n",pkt_num,pkt_info.protocol);
//           pkt_info.L4_protocol = 2'b11;
//           pkt_info.tcp_seq_num = 32'h0;
//          }
     CL_ARP:
            {
             pkt_info.protocol = 8'h0;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
               "SETUP_IP_DB_CLASS INFO:10 FOR PKT_NUM = %d, PKT_INFO.PROTOCOL = %h.\n",pkt_num,pkt_info.protocol);
             pkt_info.L4_protocol = 2'b00;
             pkt_info.tcp_seq_num = 32'h0;
            }  
     CL_RARP:
            {
             pkt_info.protocol = 8'h0;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
               "SETUP_IP_DB_CLASS INFO:11 FOR PKT_NUM = %d, PKT_INFO.PROTOCOL = %h.\n",pkt_num,pkt_info.protocol);
             pkt_info.L4_protocol = 2'b00;
             pkt_info.tcp_seq_num = 32'h0;
            }  
     default:
            {
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
              "FOR PKT_NUM = %d, Unknown frame_class %d detected.\n",pkt_num,pkt_info.packet_class);
             pkt_info.L4_protocol = 2'b00;
             pkt_info.tcp_seq_num = 32'h0;
            }  
    }

 pkt_info.mac_prt = mac_prt;
 pkt_info.pkt_num = pkt_num;
// pkt_info.flow = new flow;
 pkt_info.flow = flow.object_copy();

 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
   "IP_UTIL INFO: FOR PKT_NUM = %d COPIED IPSRC_ADDR TO PKT_INFO = %h.\n",pkt_num,pkt_info.flow.src_node.ip_addr);

 predicted_zcp_dma_chnl_offset = predict_zcp_dma_chnl_offset (pkt_num, mac_port, pkt_info);

 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
   "IP_UTIL INFO: FOR PKT_NUM = %d PREDICTED_ZCP_DMA_CHNL_OFFSET = %h.\n",pkt_num,predicted_zcp_dma_chnl_offset);

 pkt_info.dma_num             = predicted_zcp_dma_chnl_offset[4:0];
 pkt_info.zcp_dma_chnl        = predicted_zcp_dma_chnl_offset[4:0];
 pkt_info.zcp_rdc_tbl_num     = predicted_zcp_dma_chnl_offset[7:5];
 pkt_info.zcp_rdc_tbl_offset  = predicted_zcp_dma_chnl_offset[12:8];

// construct_flow = new pkt_info;
   construct_flow = pkt_info.object_copy();

 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
   "IP_UTIL INFO: FOR PKT_NUM = %d PREDICTED_ZCP_DMA_CHNL = %h.\n",pkt_num, construct_flow.zcp_dma_chnl);
 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
   "IP_UTIL INFO: FOR PKT_NUM = %d PREDICTED_ZCP_RDC_TBL_NUM = %h.\n",pkt_num, construct_flow.zcp_rdc_tbl_num);
 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
   "IP_UTIL INFO: FOR PKT_NUM = %d PREDICTED_ZCP_RDC_TBL_OFFSET = %h.\n",pkt_num, construct_flow.zcp_rdc_tbl_offset);
 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::construct_flow()",
   "IP_UTIL INFO: FOR PKT_NUM = %d CONSTRUCT_FLOW.FLOW.DST_NODE.IP_ADDR = %h.\n",pkt_num, construct_flow.flow.dst_node.ip_addr);

}

function bit [12:0] setup_cam_ram_fcram_class :: predict_zcp_dma_chnl_offset (integer pkt_num, 
                                                                 bit [2:0] mac_port, 
                                                                 Cpkt_info packet_info)
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@ Fields in [12:0]predict_zcp_dma_chnl_offset are as follows:                                                  @@
//@@ predict_zcp_dma_chnl_offset[4:0]  dma_chnl retrieved from ZCP RDC TBL                                        @@
//@@ predict_zcp_dma_chnl_offset[7:5]  RDC_TBL_NUM given by FFLP and used by ZCP (predict_rdc_tbl_offset[2:0])    @@
//@@ predict_zcp_dma_chnl_offset[12:8] RDC_TBL_OFFSET given by FFLP and used by ZCP (predict_rdc_tbl_offset[7:3]) @@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
{
 integer i;
 integer packet_frame_class;
 bit         chksum_err = 1'b0;   
 bit         crc_err    = 1'b0;   
 bit [2:0]   mac_rdctblnum;
 bit         mac_mpr;
 bit         vlan_tbl_match = 1'b0;
 bit [4:0]   packet_frame_type;
 bit [4:0]   default_dma_channel;
 bit [15:0]  packet_src_tci;
 bit [199:0] packet_cam_key;
 bit [63:0]  matched_as_data;
 bit         tcam_match = 1'b0;
 bit         do_tcam_lookup = 1'b0;
 bit         end_of_tcam = 1'b0;
 bit         ecc_failure_detected = 1'b0;
 bit [3:0]   parity_failure_detected = 4'b0000;
 bit [2:0]   predicted_l2_rdc_tbl_num;
 bit [39:0]  rd_addr;
 bit [63:0]  rd_data;
 bit [7:0]   predict_rdc_tbl_offset;

 bit [383:0] generated_flow_key = 384'h0;
 bit [31:0] calculated_H1 = 32'h0;

 integer     zcp_rdc_tbl_shadow_index;

//iport          = packet_info.mac_prt; 

be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
   "IP_UTIL INFO: FOR PKT_NUM %d PACKETT_INFO V4 IPSRC_ADDR = %h..\n",pkt_num,packet_info.flow.src_node.ip_addr);

  packet_frame_class = packet_info.flow.frame.frame_class;

 //@@@@ Find out the L2 rdc_tbl_num based on MAC @@@@
 predicted_l2_rdc_tbl_num = predict_l2_rdc_tbl_num (pkt_num, packet_info);

 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
  "IP_UTIL INFO: FOR PKT_NUM = %d, PREDICTED_L2_RDC_TBL_NUM = %h.\n",pkt_num,predicted_l2_rdc_tbl_num);

 //@@@@ Generate cam_key from the generated packet @@@@
 packet_cam_key = generate_pkt_cam_key(predicted_l2_rdc_tbl_num,packet_info);

do_tcam_lookup = tcam_lookup (pkt_num,packet_info);

be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
 "IP_UTIL INFO: FOR PKT_NUM = %d, DO_TCAM_LOOKUP = %h.\n",pkt_num,do_tcam_lookup);

if (do_tcam_lookup)
 {
 //@@@@ Find out if there is cam match @@@@@@@@@@@@@@@@
 i=0;
 while (!tcam_match && !end_of_tcam)
   {
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
     "IP_UTIL INFO: AT INDEX %d, IP_DB[0].IP_CAM.SHADOW_CAM_KEY[%d] = %h.\n",i,i,setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key [i]);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
     "IP_UTIL INFO: FOR INDEX %d, PACKET_CAM_KEY = %h SHADOW_CAM_LMASK[%d] = %h.\n",
      i,packet_cam_key,i, setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_lmask [i]);
    if ((packet_cam_key & setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_lmask [i]) === (setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_key [i] & setup_ip_db_cl.ip_db[0].ip_cam.shadow_cam_lmask [i]))
      {
//     matched_as_data = rxc_cl.setup_ip_db_cl.ip_db[0].ip_cam.shadow_adata [i];
       matched_as_data =        setup_ip_db_cl.ip_db[0].ip_cam.shadow_adata [i];

       packet_info.tcamm_index = i;
       packet_info.zc_flow_id  = matched_as_data[25:14];
       packet_info.drop_pkt    = matched_as_data[12];
       
       be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
        "IP_UTIL INFO: AT INDEX %d, MATCHED_AS_DATA = %h.\n",i,matched_as_data);

       tcam_match = 1'b1;
       if (neptune_mode)
         {
          be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
           "IP_UTIL INFO: AT INDEX %d,TCAM MATCH FOR CAM_KEY = %h IN NEPTUNE MODE for pkt_num = %d.\n", \
           i,packet_cam_key,pkt_num);
         }
       else
         {
          be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
           "IP_UTIL INFO: AT INDEX %d,TCAM MATCH FOR CAM_KEY = %h IN N2 MODE for pkt_num = %d.\n", \
           i,packet_cam_key,pkt_num);
         }
      }
    else
      {
       if (neptune_mode)
         {
          if (i >= 255)
            {
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
              "IP_UTIL INFO: NO TCAM MATCH FOR CAM_KEY = %h IN NEPTUNE MODE for pkt_num = %d.\n",packet_cam_key,pkt_num);
             end_of_tcam = 1'b1;
             packet_info.tcamm_index = 0;
             packet_info.zc_flow_id  = 12'h0;
            }
          else
            {
             i=i+1;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
              "IP_UTIL INFO: INCREMENTING TCAM INDEX FOR CAM_KEY = %h IN NEPTUNE MODE for pkt_num = %d.\n",
              packet_cam_key,pkt_num);
            }
         }
       else 
         {
          if (i >= 127)
            {
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
              "IP_UTIL INFO: NO TCAM MATCH FOR CAM_KEY = %h IN N2 MODE for pkt_num = %d.\n",packet_cam_key,pkt_num);
             end_of_tcam = 1'b1;
             packet_info.tcamm_index = 0;
             packet_info.zc_flow_id  = 12'h0;
            }
          else
            {
             i=i+1;
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
              "IP_UTIL INFO: INCREMENTING TCAM INDEX FOR CAM_KEY = %h IN N2 MODE for pkt_num = %d.\n",
              packet_cam_key,pkt_num);
            }
         } // else
      } // else
   } // while (!tcam_match && !end_of_tcam)

 //@@@@@@ Select RDC TBL NUM based on MAC/VLAN/TCAM RDC numbers @@@@@@
 if (tcam_match)
   {
    packet_info.tres = matched_as_data [11:10];
    packet_info.tzfvld = matched_as_data [1];
    packet_info.tcamhit = tcam_match;
/**************************************************************
ATTN: NEED TO KNOW WHAT TO DO AT THIS POINT
WHEN THE DISCARD BIT IS SET IN AS_DATA
   - Should we still select the correct rdc/offset/dma for ZCP?
***************************************************************/
    if (packet_info.flow.frame.frame_type =?= 5'bx0x1x)
      {         // ECC Enabled for TCAM/AS_DATA
       if (matched_as_data[13] === 1'b1 &&
           (packet_frame_class   === CL_TCP          ||          
            packet_frame_class   === CL_UDP          ||         
            packet_frame_class   === CL_TCP_FRAG     ||          
            packet_frame_class   === CL_UDP_FRAG     ||         
            packet_frame_class   === CL_IP_SEC_AH    ||  
            packet_frame_class   === CL_IP_SEC_ESP))
         {
          be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
          "IP_UTIL INFO: FOR INDEX %d, PKT_NUM = %d IS IPV4 ASSUMED ECC FOR AS_DATA.\n",i,pkt_num);
          ecc_failure_detected = ecc_err (pkt_num,packet_cam_key,matched_as_data, packet_info);
          if (!ecc_failure_detected)
            {
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
             "IP_UTIL INFO: FOR INDEX %d, ECC PASSED FOR CAM_KEY = %h for pkt_num = %d.\n",
              i, packet_cam_key,pkt_num);
             packet_info.asdata_disc    = matched_as_data[12];  // check disc bit
             predict_rdc_tbl_offset  = select_tcam_match_rdc (i, pkt_num, 
                                                              predicted_l2_rdc_tbl_num, 
                                                              matched_as_data,
                                                              packet_info);
            } 
          else
            {
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
             "IP_UTIL INFO: FOR INDEX %d, ECC FAILED FOR CAM_KEY = %h for pkt_num = %d.\n",
              i, packet_cam_key,pkt_num);
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
             "IP_UTIL INFO: FOR PKT_NUM %d, L2_RDC = %h is selected.\n",pkt_num,predicted_l2_rdc_tbl_num);
             predict_rdc_tbl_offset  = predicted_l2_rdc_tbl_num;
             packet_info.fflp_hw_err = 1'b1;
            } 
         }
       else                               // Even Parity Enabled for AS_DATA
         {
          be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
          "IP_UTIL INFO: FOR INDEX %d, PKT_NUM = %d IS IPV4 ASSUMED PARITY FOR AS_DATA.\n",i,pkt_num);
          parity_failure_detected = calculate_parity (i, pkt_num,matched_as_data);
          if (parity_failure_detected === 4'b000)
            {
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
             "IP_UTIL INFO: FOR INDEX %d, PARITY PASSED FOR CAM_KEY = %h for pkt_num = %d.\n",
              i, packet_cam_key,pkt_num);
             packet_info.asdata_disc    = matched_as_data[12];  // check disc bit
             predict_rdc_tbl_offset  = select_tcam_match_rdc (i, pkt_num, 
                                                              predicted_l2_rdc_tbl_num, 
                                                              matched_as_data,
                                                              packet_info);
            } 
          else
            {
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
             "IP_UTIL INFO: FOR INDEX %d, PARITY FAILED FOR CAM_KEY = %h for pkt_num = %d.\n",
              i, packet_cam_key,pkt_num);
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
             "IP_UTIL INFO: FOR PKT_NUM %d, L2_RDC = %h is selected.\n",pkt_num,predicted_l2_rdc_tbl_num);
             predict_rdc_tbl_offset  = predicted_l2_rdc_tbl_num;
             packet_info.fflp_hw_err = 1'b1;
            } 
         }
      } // if (packet_info.flow.frame.frame_type =?= 5'bx0x1x)
    else if (packet_info.flow.frame.frame_type =?= 5'bx1x1x)
      {
       parity_failure_detected = calculate_parity (i, pkt_num,matched_as_data);
       be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
       "IP_UTIL INFO: FOR INDEX %d, PKT_NUM = %d IS IPV6 ASSUMED PARITY ONLY FOR AS_DATA.\n",i,pkt_num);
       if (parity_failure_detected === 4'b000)
         {
          be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
          "IP_UTIL INFO: FOR INDEX %d, PARITY PASSED FOR CAM_KEY = %h for pkt_num = %d.\n",
           i, packet_cam_key,pkt_num);
          packet_info.asdata_disc    = matched_as_data[12];  // check disc bit
          predict_rdc_tbl_offset  = select_tcam_match_rdc (i, pkt_num,
                                                           predicted_l2_rdc_tbl_num,
                                                           matched_as_data,
                                                           packet_info);
         } 
       else
         {
          be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
          "IP_UTIL INFO: FOR INDEX %d, PARITY FAILED FOR CAM_KEY = %h for pkt_num = %d.\n",
           i, packet_cam_key,pkt_num);
          be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
          "IP_UTIL INFO: FOR PKT_NUM %d, L2_RDC = %h is selected.\n",pkt_num,predicted_l2_rdc_tbl_num);
          predict_rdc_tbl_offset  = predicted_l2_rdc_tbl_num;
          packet_info.fflp_hw_err = 1'b1;
         } 
      }
   } // if (tcam_match)
 else
   {
    packet_info.tcamm_index = 0;
    packet_info.zc_flow_id  = 12'h0;

    packet_info.tres = 2'b00;
    packet_info.tzfvld = 1'b0;
    packet_info.tcamhit = tcam_match;
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
    "IP_UTIL INFO: NO TCAM MATCH FOR PKT_NUM %d, L2_RDC = %h is selected.\n",pkt_num,predict_rdc_tbl_offset);

        if (packet_frame_class   === CL_TCP          ||          
            packet_frame_class   === CL_UDP          ||         
            packet_frame_class   === CL_TCP_FRAG     ||          
            packet_frame_class   === CL_UDP_FRAG     ||         
            packet_frame_class   === CL_IP_SEC_AH    ||  
            packet_frame_class   === CL_IP_SEC_ESP   ||
            packet_frame_class   === CL_TCP_IP_V6    ||
            packet_frame_class   === CL_UDP_IP_V6    ||
            packet_frame_class   === CL_IP_V6_SEC_AH || 
            packet_frame_class   === CL_IP_V6_SEC_ESP) 
          {
           generated_flow_key = generate_flow_key (pkt_num,packet_info);
           packet_info.flow_key = generated_flow_key;
           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
            "IP_UTIL INFO: FOR PKT_NUM %d FLOW_KEY = %h.\n",pkt_num,packet_info.flow_key );
           //@@ Check to see if external lookup is required @@
//         rd_addr = (FFLP_FLOW_ADDRESS_RANGE + FFLP_FLOW_PARTITION_SEL) + (predicted_l2_rdc_tbl_num*8);
//         gen_pio_drv.pio_rd(rd_addr, rd_data);
//         if (rd_data[16] === 1'b1)
           if (fflp_util.ext_lookup[predicted_l2_rdc_tbl_num] === 1'b1)
             {
              be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
               "IP_UTIL INFO: FOR PKT_NUM %d PERFORMING EXTERNAL LOOKUP.\n",pkt_num);
             }
           else
             {
              be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
               "IP_UTIL INFO: FOR PKT_NUM %d L3 CLASS, CALCULATE H1 FOR OFFSET, NO EXTERNAL LOOKUP IS REQUIRED.\n",pkt_num);
              calculated_H1 = calculate_H1 (pkt_num, predicted_l2_rdc_tbl_num, packet_info);

              predict_rdc_tbl_offset  = {calculated_H1[4:0],predicted_l2_rdc_tbl_num};
              be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
               "IP_UTIL INFO: FOR PKT_NUM %d L3 CLASS, OFFSET IS H1 = %h AND RDC IS FROM L2 = %h.\n",
                pkt_num,calculated_H1[4:0],predicted_l2_rdc_tbl_num);
             }
          }
        else
          {
           predict_rdc_tbl_offset  = {5'h0,predicted_l2_rdc_tbl_num};
           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
            "IP_UTIL INFO: FOR PKT_NUM %d NOT A L3 CLASS, OFFSET IS SET TO 0 AND RDC IS FROM L2 = %h.\n",
             pkt_num,predicted_l2_rdc_tbl_num);
          }
   }
 } // if (do_tcam_lookup)
else
 {
  packet_info.tcamm_index = 0;
  packet_info.zc_flow_id  = 12'h0;

  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
  "IP_UTIL INFO: NO TCAM LOOKUP FOR PKT_NUM %d, L2_RDC = %h is selected.\n",pkt_num,predict_rdc_tbl_offset);

      if (packet_frame_class   === CL_TCP          ||          
          packet_frame_class   === CL_UDP          ||         
          packet_frame_class   === CL_TCP_FRAG     ||          
          packet_frame_class   === CL_UDP_FRAG     ||         
          packet_frame_class   === CL_IP_SEC_AH    ||  
          packet_frame_class   === CL_IP_SEC_ESP   ||
          packet_frame_class   === CL_TCP_IP_V6    ||
          packet_frame_class   === CL_UDP_IP_V6    ||
          packet_frame_class   === CL_IP_V6_SEC_AH || 
          packet_frame_class   === CL_IP_V6_SEC_ESP) 
        {
         generated_flow_key = generate_flow_key (pkt_num,packet_info);
         packet_info.flow_key = generated_flow_key;
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
          "IP_UTIL INFO: FOR PKT_NUM %d FLOW_KEY = %h.\n",pkt_num,packet_info.flow_key );
         //@@ Check to see if external lookup is required @@
//       rd_addr = (FFLP_FLOW_ADDRESS_RANGE + FFLP_FLOW_PARTITION_SEL) + (predicted_l2_rdc_tbl_num*8);
//       gen_pio_drv.pio_rd(rd_addr, rd_data);
//       if (rd_data[16] === 1'b1)
         if (fflp_util.ext_lookup[predicted_l2_rdc_tbl_num] === 1'b1)
           {
            be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
             "IP_UTIL INFO: FOR PKT_NUM %d PERFORMING EXTERNAL LOOKUP.\n",pkt_num);
           }
         else
           {
            be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
             "IP_UTIL INFO: FOR PKT_NUM %d L3 CLASS, CALCULATE H1 FOR OFFSET, NO EXTERNAL LOOKUP IS REQUIRED.\n",pkt_num);
            calculated_H1 = calculate_H1 (pkt_num, predicted_l2_rdc_tbl_num, packet_info);

            predict_rdc_tbl_offset  = {calculated_H1[4:0],predicted_l2_rdc_tbl_num};
            be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
             "IP_UTIL INFO: FOR PKT_NUM %d L3 CLASS, OFFSET IS H1 = %h AND RDC IS FROM L2 = %h.\n",
              pkt_num,calculated_H1[4:0],predicted_l2_rdc_tbl_num);
           }
        }
      else
        {
         predict_rdc_tbl_offset  = {5'h0,predicted_l2_rdc_tbl_num};
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
          "IP_UTIL INFO: FOR PKT_NUM %d NOT A L3 CLASS, OFFSET IS SET TO 0 AND RDC IS FROM L2 = %h.\n",
           pkt_num,predicted_l2_rdc_tbl_num);
        }
 }
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
//@@ Predict dma channel from ZCP's rdc table based on the predicted @@
//@@ rdc_tbl num & offset (predict_rdc_tbl_offset) from FFLP         @@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
if (crc_err)
  {
   if (mac_port === 3'b000)
     {
//    rd_addr = RDC_DEF_PT0_RDC;
//    gen_pio_drv.pio_rd(rd_addr,rd_data);
      rd_data = fflp_util.rdc_def_pt0_rdc;
      predict_zcp_dma_chnl_offset = {8'h0,rd_data[4:0]};      
      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
       "IP_UTIL INFO: FOR PKT_NUM %d,P0 DEFAULT PREDICTED_DMA_CHNL = %h.\n",pkt_num,predict_zcp_dma_chnl_offset);
     }
   else if (mac_port === 3'b001)
     {
//    rd_addr = RDC_DEF_PT1_RDC;
//    gen_pio_drv.pio_rd(rd_addr,rd_data);
      rd_data = fflp_util.rdc_def_pt1_rdc;
      predict_zcp_dma_chnl_offset = {8'h0,rd_data[4:0]};      
      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
       "IP_UTIL INFO: FOR PKT_NUM %d,P1 DEFAULT PREDICTED_DMA_CHNL = %h.\n",pkt_num,predict_zcp_dma_chnl_offset);
     }
   else if (mac_port === 3'b010)
     {
//    rd_addr = RDC_DEF_PT2_RDC;
//    gen_pio_drv.pio_rd(rd_addr,rd_data);
      rd_data = fflp_util.rdc_def_pt2_rdc;
      predict_zcp_dma_chnl_offset = {8'h0,rd_data[4:0]};      
      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
       "IP_UTIL INFO: FOR PKT_NUM %d,P2 DEFAULT PREDICTED_DMA_CHNL = %h.\n",pkt_num,predict_zcp_dma_chnl_offset);
     }
   else if (mac_port === 3'b100)
     {
//    rd_addr = RDC_DEF_PT3_RDC;
//    gen_pio_drv.pio_rd(rd_addr,rd_data);
      rd_data = fflp_util.rdc_def_pt3_rdc;
      predict_zcp_dma_chnl_offset = {8'h0,rd_data[4:0]};      
      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
       "IP_UTIL INFO: FOR PKT_NUM %d,P3 DEFAULT PREDICTED_DMA_CHNL = %h.\n",pkt_num,predict_zcp_dma_chnl_offset);
     }
   else
     {
      predict_zcp_dma_chnl_offset = 13'hx;      
      be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
       "IP_UTIL INFO: FOR PKT_NUM %d, MAC PORT_NUM = %d is not defined.\n",pkt_num,mac_port);
     }
   //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   //@@ Calculate the default DMA Channel Value (location 0 of the
   //@@ RDC Tbl Num which is pointing to in ZCP Table.
   //@@ NOTE: Since Control FIFO does not contain info. about default
   //@@       RDC from RDMC per port deafult RDC values, then here the
   //@@       RDC_TBL_NUM + 0 (offset is 0) is used to get the ZCP's  
   //@@       location 0 DMA channel value.
   //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   zcp_rdc_tbl_shadow_index = ((predict_rdc_tbl_offset[2:0] * 16) + 0);
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
     "IP_UTIL INFO: CRC ERR: FOR PKT_NUM %d, FOR ZCP_RDC_TBL_SHADOW_INDEX = %d.\n",pkt_num,zcp_rdc_tbl_shadow_index);
   rd_data[4:0] = shadow_zcp_table [zcp_rdc_tbl_shadow_index];
   packet_info.default_dma_num = rd_data[4:0];
  }
else if (chksum_err) // Choose the entry 0 0f the sub-zcp rdc tabl
  {
   zcp_rdc_tbl_shadow_index = ((predict_rdc_tbl_offset[2:0] * 16) + 0);
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
     "IP_UTIL INFO: CHKSUM_ERR: FOR PKT_NUM %d, FOR ZCP_RDC_TBL_SHADOW_INDEX = %d.\n",pkt_num,zcp_rdc_tbl_shadow_index);
   rd_data[4:0] = shadow_zcp_table [zcp_rdc_tbl_shadow_index];
   //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   //@@ Calculate the default DMA Channel Value (location 0 of the
   //@@ RDC Tbl Num which is pointing to in ZCP Table.
   //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   packet_info.default_dma_num = rd_data[4:0];

   predict_zcp_dma_chnl_offset = {predict_rdc_tbl_offset,rd_data[4:0]};
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
     "IP_UTIL INFO: CHKSUM_ERR: FOR PKT_NUM %d, FOR SHADOW ZCP_RDC_TBL INDEX = %h, READ ZCP RDC_TBL DMA_CHNL_OFFSET = %h.\n",
      pkt_num,zcp_rdc_tbl_shadow_index,predict_zcp_dma_chnl_offset);
  }
else
  {
// rd_addr = ZCP_RDC_TBL + ((predict_rdc_tbl_offset[2:0] * 16 * 8) + (predict_rdc_tbl_offset[6:3] * 8));
// gen_pio_drv.pio_rd(rd_addr,rd_data);

   //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   //@@ Calculate the default DMA Channel Value (location 0 of the
   //@@ RDC Tbl Num which is pointing to in ZCP Table.
   //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   zcp_rdc_tbl_shadow_index = (predict_rdc_tbl_offset[2:0] * 16 + 0);
   default_dma_channel = shadow_zcp_table [zcp_rdc_tbl_shadow_index];
   packet_info.default_dma_num = default_dma_channel;

   zcp_rdc_tbl_shadow_index = (predict_rdc_tbl_offset[2:0] * 16) + (predict_rdc_tbl_offset[6:3]);
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
     "IP_UTIL INFO: FOR PKT_NUM %d, FOR ZCP_RDC_TBL_SHADOW_INDEX = %d.\n",pkt_num,zcp_rdc_tbl_shadow_index);
   rd_data[4:0] = shadow_zcp_table [zcp_rdc_tbl_shadow_index];

   predict_zcp_dma_chnl_offset = {predict_rdc_tbl_offset,rd_data[4:0]};
// be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
//   "IP_UTIL INFO: FOR PKT_NUM %d, AT ZCP_RDC_TBL_ADDR = %h, READ ZCP RDC_TBL DMA_CHNL_OFFSET = %h.\n",
//    pkt_num,rd_addr,predict_zcp_dma_chnl_offset);
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_zcp_dma_chnl_offset()",
     "IP_UTIL INFO: FOR PKT_NUM %d, FOR SHADOW ZCP_RDC_TBL INDEX = %h, READ ZCP RDC_TBL DMA_CHNL_OFFSET = %h.\n",
      pkt_num,zcp_rdc_tbl_shadow_index,predict_zcp_dma_chnl_offset);
  }

 packet_info.hash_index       = 3'b000;
 packet_info.hzfvld           = 1'b0;
 packet_info.hash_exact_match = 1'b0;
 packet_info.hash_hit         = 1'b0;
 packet_info.tt_succeed       = 1'b0;
 packet_info.tt_err           = 1'b0;
 packet_info.hash_value2      = 16'h0;
 packet_info.hash_value1      = 20'h0;
 packet_info.user_data        = 40'h0;
 packet_info.tt_hdr_len       = 16'h0;
 packet_info.tcp_payload_len  = 16'h0;
 packet_info.HoQ              = 16'h0;
 packet_info.first_byte_offset = 24'h0;
 packet_info.win_buf_offset   = 5'h0;
 packet_info.dmaw_type_1      = 2'h0;
 packet_info.reach_buf_end    = 1'b0;

}

function bit  setup_cam_ram_fcram_class:: tcam_lookup (integer pkt_num, Cpkt_info packet_info)
 {
  bit [63:0] shadow_how_tcam_key_reg; 
  bit [63:0] how_to_tcam_key; 
  bit [39:0] rd_addr; 
  bit        read_how_tcam_reg = 1'b0;

  case (packet_info.packet_class)
    {
     2:{
        read_how_tcam_reg = 1'b0;
        packet_info.class_matched = 1'b1;
       }
     3:{
        read_how_tcam_reg = 1'b0;
        packet_info.class_matched = 1'b1;
       }
     4:{
        rd_addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_4;
        read_how_tcam_reg = 1'b1;
        packet_info.class_matched = 1'b1;
        shadow_how_tcam_key_reg = fflp_util.fflp_how_tcam_key_cls_4;
       }
     5:{
        rd_addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_5;
        read_how_tcam_reg = 1'b1;
        packet_info.class_matched = 1'b1;
        shadow_how_tcam_key_reg = fflp_util.fflp_how_tcam_key_cls_5;
       }
     6:{
        rd_addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_6;
        read_how_tcam_reg = 1'b1;
        shadow_how_tcam_key_reg = fflp_util.fflp_how_tcam_key_cls_6;
        packet_info.class_matched = 1'b1;
       }
     7:{
        rd_addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_7;
        read_how_tcam_reg = 1'b1;
        shadow_how_tcam_key_reg = fflp_util.fflp_how_tcam_key_cls_7;
        packet_info.class_matched = 1'b1;
       }
     8:{
        rd_addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_8;
        read_how_tcam_reg = 1'b1;
        shadow_how_tcam_key_reg = fflp_util.fflp_how_tcam_key_cls_8;
        packet_info.class_matched = 1'b1;
       }
     9:{
        rd_addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_9;
        read_how_tcam_reg = 1'b1;
        shadow_how_tcam_key_reg = fflp_util.fflp_how_tcam_key_cls_9;
        packet_info.class_matched = 1'b1;
       }
     10:{
         rd_addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_A;
         read_how_tcam_reg = 1'b1;
         shadow_how_tcam_key_reg = fflp_util.fflp_how_tcam_key_cls_A;
         packet_info.class_matched = 1'b1;
        }
     11:{
         rd_addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_B;
         read_how_tcam_reg = 1'b1;
        shadow_how_tcam_key_reg = fflp_util.fflp_how_tcam_key_cls_B;
         packet_info.class_matched = 1'b1;
        }
     12:{
         rd_addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_C;
         read_how_tcam_reg = 1'b1;
        shadow_how_tcam_key_reg = fflp_util.fflp_how_tcam_key_cls_C;
         packet_info.class_matched = 1'b1;
        }
     13:{
         rd_addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_D;
         read_how_tcam_reg = 1'b1;
        shadow_how_tcam_key_reg = fflp_util.fflp_how_tcam_key_cls_D;
         packet_info.class_matched = 1'b1;
        }
     14:{
         rd_addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_E;
         read_how_tcam_reg = 1'b1;
        shadow_how_tcam_key_reg = fflp_util.fflp_how_tcam_key_cls_E;
         packet_info.class_matched = 1'b1;
        }
     15:{
         rd_addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_F;
         read_how_tcam_reg = 1'b1;
        shadow_how_tcam_key_reg = fflp_util.fflp_how_tcam_key_cls_F;
         packet_info.class_matched = 1'b1;
        }
     16:{
         read_how_tcam_reg = 1'b0;
         packet_info.class_matched = 1'b1;
        }
     17:{
         read_how_tcam_reg = 1'b0;
         packet_info.class_matched = 1'b1;
        }
     default:{
         packet_info.class_matched = 1'b0;
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::tcam_lookup()",
          "IP_UTIL INFO: FPR PKT_NUM = %d, PACKET_CLASS = %d IS NOT ONE OF THE 16 EXPECTED CLASSES.\n",
            pkt_num,packet_info.packet_class);
        }
    }

  if (read_how_tcam_reg)
    {
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::tcam_lookup()",
      "IP_UTIL INFO: FPR PKT_NUM = %d, PACKET_CLASS = %d SHADOW_HOW_TCAM_KEY_REG = %h.\n",
        pkt_num,packet_info.packet_class,shadow_how_tcam_key_reg);
//   gen_pio_drv.pio_rd(rd_addr, how_to_tcam_key);
     how_to_tcam_key = shadow_how_tcam_key_reg ;
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::tcam_lookup()",
      "IP_UTIL INFO: FPR PKT_NUM = %d, PACKET_CLASS = %d PIO    HOW_TCAM_KEY_REG = %h.\n",
        pkt_num,packet_info.packet_class,how_to_tcam_key);
     if (how_to_tcam_key[2] === 1'b1)
       {
        tcam_lookup = 1'b1;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::tcam_lookup()",
         "IP_UTIL INFO: FPR PKT_NUM = %d, PACKET_CLASS = %d TCAM LOOKUP IS EXPECTED.\n",
           pkt_num,packet_info.packet_class);
       }
     else
       {
        tcam_lookup = 1'b0;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::tcam_lookup()",
         "IP_UTIL INFO: FPR PKT_NUM = %d,1 PACKET_CLASS = %d TCAM LOOKUP IS NOT EXPECTED.\n",
           pkt_num,packet_info.packet_class);
       }
    }
  else
    {
     if ((packet_info.packet_class === 2)  ||
         (packet_info.packet_class === 3)  ||
         (packet_info.packet_class === 16) ||
         (packet_info.packet_class === 17))
       {
        tcam_lookup = 1'b1;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::tcam_lookup()",
         "IP_UTIL INFO: FPR PKT_NUM = %d, FOR PACKET_CLASS = %d GO AHEAD DO CAM LOOKUP.\n",
           pkt_num,packet_info.packet_class);
       }
     else
       {
        tcam_lookup = 1'b0;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::tcam_lookup()",
         "IP_UTIL INFO: FPR PKT_NUM = %d,2 PACKET_CLASS = %d TCAM LOOKUP IS NOT EXPECTED.\n",
           pkt_num,packet_info.packet_class);
       }
    }
 }

function bit [3:0] setup_cam_ram_fcram_class:: calculate_parity (integer i, integer pkt_num, bit [63:0] matched_as_data)
 {
  integer j;
  integer B0_even_parity_cnt = 0;
  integer B1_even_parity_cnt = 0;
  integer B2_even_parity_cnt = 0;
  integer B3_even_parity_cnt = 0;

  for (j=1;j<8;j++)
   {
    if (matched_as_data[j] === 1'b1)
      {
       B0_even_parity_cnt = B0_even_parity_cnt + 1;
      }
   }

  for (j=8;j<16;j++)
   {
    if (matched_as_data[j] === 1'b1)
      {
       B1_even_parity_cnt = B1_even_parity_cnt + 1;
      }
   }

  for (j=16;j<24;j++)
   {
    if (matched_as_data[j] === 1'b1)
      {
       B2_even_parity_cnt = B2_even_parity_cnt + 1;
      }
   }

  for (j=24;j<26;j++)
   {
    if (matched_as_data[j] === 1'b1)
      {
       B3_even_parity_cnt = B3_even_parity_cnt + 1;
      }
   }

  if (B0_even_parity_cnt === 0 ||
      B0_even_parity_cnt === 2 ||
      B0_even_parity_cnt === 4 ||
      B0_even_parity_cnt === 6 ||
      B0_even_parity_cnt === 8)
    {
     if (matched_as_data[26] !== 1'b0)
       {
        calculate_parity[0] = 1'b1;
        be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, EVEN PARITY FAILED FOR B0 OF AS_DATA = %h.\n",
         i,pkt_num,matched_as_data);
       }    
     else
       {
        calculate_parity[0] = 1'b0;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, EVEN PARITY PASSED FOR B0 OF AS_DATA = %h.\n",
         i,pkt_num,matched_as_data);
       }    
    }
  else if (B0_even_parity_cnt === 1 ||
           B0_even_parity_cnt === 3 ||
           B0_even_parity_cnt === 5 ||
           B0_even_parity_cnt === 7)
    {
     if (matched_as_data[26] !== 1'b1)
       {
        calculate_parity[0] = 1'b1;
        be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, EVEN PARITY FAILED FOR B0 OF AS_DATA = %h.\n",
        i,pkt_num,matched_as_data);
       }    
     else
       {
        calculate_parity[0] = 1'b0;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, EVEN PARITY PASSED FOR B0 OF AS_DATA = %h.\n",
        i,pkt_num,matched_as_data);
       }    
    }
  else
    {
     be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_parity()",
     "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, B0_even_parity_cnt = %d is not expected.\n",
     i,pkt_num,B0_even_parity_cnt);
    }

  if (B1_even_parity_cnt === 0 ||
      B1_even_parity_cnt === 2 ||
      B1_even_parity_cnt === 4 ||
      B1_even_parity_cnt === 6 ||
      B1_even_parity_cnt === 8)
    {
     if (matched_as_data[27] !== 1'b0)
       {
        calculate_parity[1] = 1'b1;
        be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, EVEN PARITY FAILED FOR B1 OF AS_DATA = %h.\n",
        i,pkt_num,matched_as_data);
       }    
     else
       {
        calculate_parity[1] = 1'b0;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, EVEN PARITY PASSED FOR B1 OF AS_DATA = %h.\n",
        i,pkt_num,matched_as_data);
       }    
    }
  else if (B1_even_parity_cnt === 1 ||
           B1_even_parity_cnt === 3 ||
           B1_even_parity_cnt === 5 ||
           B1_even_parity_cnt === 7)
    {
     if (matched_as_data[27] !== 1'b1)
       {
        calculate_parity[1] = 1'b1;
        be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, EVEN PARITY FAILED FOR B1 OF AS_DATA = %h.\n",
        i,pkt_num,matched_as_data);
       }    
     else
       {
        calculate_parity[1] = 1'b0;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, EVEN PARITY PASSED FOR B1 OF AS_DATA = %h.\n",
        i,pkt_num,matched_as_data);
       }    
    }
  else
    {
     be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_parity()",
     "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, B1_even_parity_cnt = %d is not expected.\n",
     i,pkt_num,B1_even_parity_cnt);
    }

  if (B2_even_parity_cnt === 0 ||
      B2_even_parity_cnt === 2 ||
      B2_even_parity_cnt === 4 ||
      B2_even_parity_cnt === 6 ||
      B2_even_parity_cnt === 8)
    {
     if (matched_as_data[28] !== 1'b0)
       {
        calculate_parity[2] = 1'b1;
        be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d,E EVEN PARITY FAILED FOR B2 OF AS_DATA = %h.\n",
        i,pkt_num,matched_as_data);
       }    
     else
       {
        calculate_parity[2] = 1'b0;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, EVEN PARITY PASSED FOR B2 OF AS_DATA = %h.\n",
        i,pkt_num,matched_as_data);
       }    
    }
  else if (B2_even_parity_cnt === 1 ||
           B2_even_parity_cnt === 3 ||
           B2_even_parity_cnt === 5 ||
           B2_even_parity_cnt === 7)
    {
     if (matched_as_data[28] !== 1'b1)
       {
        calculate_parity[2] = 1'b1;
        be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d,O EVEN PARITY FAILED FOR B2 OF AS_DATA = %h.\n",
        i,pkt_num,matched_as_data);
       }    
     else
       {
        calculate_parity[2] = 1'b0;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, EVEN PARITY PASSED FOR B2 OF AS_DATA = %h.\n",
        i,pkt_num,matched_as_data);
       }    
    }
  else
    {
     be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_parity()",
     "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, B2_even_parity_cnt = %d is not expected.\n",
     i,pkt_num,B2_even_parity_cnt);
    }

  if (B3_even_parity_cnt === 0 ||
      B3_even_parity_cnt === 2)
    {
     if (matched_as_data[29] !== 1'b0)
       {
        calculate_parity[3] = 1'b1;
        be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, EVEN PARITY FAILED FOR B3 OF AS_DATA = %h.\n",
        i,pkt_num,matched_as_data);
       }    
     else
       {
        calculate_parity[3] = 1'b0;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, EVEN PARITY PASSED FOR B3 OF AS_DATA = %h.\n",
        i,pkt_num,matched_as_data);
       }    
    }
  else if (B3_even_parity_cnt === 1)  
    {
     if (matched_as_data[29] !== 1'b1)
       {
        calculate_parity[3] = 1'b1;
        be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, EVEN PARITY FAILED FOR B3 OF AS_DATA = %h.\n",
        i,pkt_num,matched_as_data);
       }    
     else
       {
        calculate_parity[3] = 1'b0;
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_parity()",
        "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, EVEN PARITY PASSED FOR B3 OF AS_DATA = %h.\n",
        i,pkt_num,matched_as_data);
       }    
    }
  else
    {
     be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::calculate_parity()",
     "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, B3_even_parity_cnt = %d is not expected.\n",
     i,pkt_num,B3_even_parity_cnt);
    }
  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_parity()",
  "IP_UTIL INFO: FOR TCAM_INDEX = %d, PKT_NUM %d, CALCULTED PARITY IS %h.\n",i,pkt_num,calculate_parity);
 }

function bit [7:0] setup_cam_ram_fcram_class:: select_tcam_match_rdc (integer index,
                                                              integer pkt_num,
                                                              bit [2:0] predicted_l2_rdc_tbl_num, 
                                                              bit [63:0] matched_as_data, 
                                                              Cpkt_info packet_info)
 {
  integer packet_frame_class;
  bit [39:0] rd_addr;
  bit [63:0] rd_data;
  bit [383:0] generated_flow_key = 384'h0;
  bit [31:0] calculated_H1 = 32'h0;

  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::select_tcam_match_rdc()",
   "IP_UTIL INFO: PKT_NUM %d & INDEX = %d, FOR TCAM MATCH L2_RDC_TBL_NUM = %h.\n",pkt_num,index,matched_as_data[9:7]);

  packet_frame_class = packet_info.flow.frame.frame_class;

//  if (matched_as_data[12] === 1'b1)
//    {
//     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::select_tcam_match_rdc()",
//      "IP_UTIL INFO: FOR PKT_NUM %d & INDEX = %d, DISCARD BIT IS SET IN AS_DATA.\n",pkt_num,index);
//     select_tcam_match_rdc = 7'hxx;
//    } 
//  else
//    {
     if (matched_as_data[11:10] === 2'b00)
       {
        // NOTE: Need to add SCTP class type to below as well
        if (packet_frame_class   === CL_TCP          ||          
            packet_frame_class   === CL_UDP          ||         
            packet_frame_class   === CL_TCP_FRAG     ||          
            packet_frame_class   === CL_UDP_FRAG     ||         
            packet_frame_class   === CL_IP_SEC_AH    ||  
            packet_frame_class   === CL_IP_SEC_ESP   ||
            packet_frame_class   === CL_TCP_IP_V6    ||
            packet_frame_class   === CL_UDP_IP_V6    ||
            packet_frame_class   === CL_IP_V6_SEC_AH || 
            packet_frame_class   === CL_IP_V6_SEC_ESP) 
          {
           generated_flow_key = generate_flow_key (pkt_num,packet_info);
           packet_info.flow_key = generated_flow_key;
           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::select_tcam_match_rdc()",
            "IP_UTIL INFO: FOR PKT_NUM %d FLOW_KEY = %h.\n",pkt_num,packet_info.flow_key );
           //@@ Check to see if external lookup is required @@
//         rd_addr = (FFLP_FLOW_ADDRESS_RANGE + FFLP_FLOW_PARTITION_SEL) + (predicted_l2_rdc_tbl_num*8);
//         gen_pio_drv.pio_rd(rd_addr, rd_data);
           rd_data = fflp_util.ext_lookup[predicted_l2_rdc_tbl_num];
           if (rd_data[16] === 1'b1)
             {
              be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::select_tcam_match_rdc()",
               "IP_UTIL INFO: FOR PKT_NUM %d PERFORMING EXTERNAL LOOKUP.\n",pkt_num);
             }
           else
             {
              be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::select_tcam_match_rdc()",
               "IP_UTIL INFO: FOR PKT_NUM %d L3 CLASS, CALCULATE H1, NO EXTERNAL LOOKUP IS REQUIRED.\n",pkt_num);
              calculated_H1 = calculate_H1 (pkt_num, predicted_l2_rdc_tbl_num, packet_info);
             }
           
           select_tcam_match_rdc = {calculated_H1[4:0],predicted_l2_rdc_tbl_num}; 
          }
        else 
          {
           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::select_tcam_match_rdc()",
            "IP_UTIL INFO: PKT_NUM %d & INDEX = %d, FOR TCAM MATCH L2_RDC_TBL_NUM = %h IS SELECTED WITH FLOW.\n",pkt_num,index);
           select_tcam_match_rdc = {5'h0,predicted_l2_rdc_tbl_num}; 
          }
       }
     else if (matched_as_data[11:10] === 2'b01)
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::select_tcam_match_rdc()",
         "IP_UTIL INFO: PKT_NUM %d & INDEX = %d, FOR TCAM MATCH USE L2_RDC_TBL_NUM = %h & AS_DATA OFFSET = %h WITH NO LFOW.\n",
          pkt_num,index,predicted_l2_rdc_tbl_num,matched_as_data[6:2]);
        select_tcam_match_rdc = {matched_as_data[6:2],predicted_l2_rdc_tbl_num}; 
       }
     else if (matched_as_data[11:10] === 2'b10)
       {
        if (packet_frame_class   === CL_TCP          ||          
            packet_frame_class   === CL_UDP          ||         
            packet_frame_class   === CL_TCP_FRAG     ||          
            packet_frame_class   === CL_UDP_FRAG     ||         
            packet_frame_class   === CL_IP_SEC_AH    ||  
            packet_frame_class   === CL_IP_SEC_ESP   ||
            packet_frame_class   === CL_TCP_IP_V6    ||
            packet_frame_class   === CL_UDP_IP_V6    ||
            packet_frame_class   === CL_IP_V6_SEC_AH || 
            packet_frame_class   === CL_IP_V6_SEC_ESP) 
          {
           generated_flow_key = generate_flow_key (pkt_num,packet_info);
           packet_info.flow_key = generated_flow_key;
           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::select_tcam_match_rdc()",
            "IP_UTIL INFO: FOR PKT_NUM %d FLOW_KEY = %h.\n",pkt_num,packet_info.flow_key );
           //@@ Check to see if external lookup is required @@
//         rd_addr = (FFLP_FLOW_ADDRESS_RANGE + FFLP_FLOW_PARTITION_SEL) + (predicted_l2_rdc_tbl_num*8);
//         gen_pio_drv.pio_rd(rd_addr, rd_data);
           rd_data = fflp_util.ext_lookup[predicted_l2_rdc_tbl_num];
           if (rd_data[16] === 1'b1)
             {
              be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::select_tcam_match_rdc()",
               "IP_UTIL INFO: FOR PKT_NUM %d PERFORMING EXTERNAL LOOKUP.\n",pkt_num);
             }
           else
             {
              be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::select_tcam_match_rdc()",
               "IP_UTIL INFO: FOR PKT_NUM %d L3 CLASS, CALCULATE H1 FOR OFFSET, NO EXTERNAL LOOKUP IS REQUIRED.\n",pkt_num);
              calculated_H1 = calculate_H1 (pkt_num, predicted_l2_rdc_tbl_num, packet_info);
             }
           
           select_tcam_match_rdc = {calculated_H1[4:0],matched_as_data[9:7]}; 
          }
        else 
          {
           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::select_tcam_match_rdc()",
            "IP_UTIL INFO: PKT_NUM %d & INDEX = %d, FOR TCAM MATCH AS_DATA RDC_TBL_NUM = %h IS SELECTED WITH NO FLOW.\n",pkt_num,index);
           select_tcam_match_rdc = {5'h0,matched_as_data[9:7]}; 
          }
       }
     else if (matched_as_data[11:10] === 2'b11)
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::select_tcam_match_rdc()",
         "IP_UTIL INFO: PKT_NUM %d & INDEX = %d, FOR TCAM MATCH USE AS_DATA RDC_TBL_NUM = %h & AS_DATA OFFSET = %h WITH NO LFOW.\n",
          pkt_num,index,predicted_l2_rdc_tbl_num,matched_as_data[6:2]);
        select_tcam_match_rdc = {matched_as_data[6:2],matched_as_data[9:7]}; 
       }
//    }
 }

function bit [2:0] setup_cam_ram_fcram_class:: predict_l2_rdc_tbl_num (integer pkt_num, Cpkt_info packet_info)
 {
  integer iport;
  bit       mac_da_matched = 1'b0;
  bit [2:0] matched_vlan_rdctblnum = 3'b000;
  bit       matched_vlan_vpr       = 1'b0;
  bit [2:0] matched_mac_rdctblnum = 3'b000;
  bit       matched_mac_mpr       = 1'b0;
  bit [4:0] packet_frame_type = 5'h0;
  bit [2:0] packet_mac_port = 3'b000;
  bit [11:0] packet_tci = 12'h0;
  bit        vlan_parity0    = 1'bx;
  bit        vlan_parity1    = 1'bx;
  bit [2:0]  vlan_rdctblnum0 = 3'b000;
  bit        vlan_vpr0 = 1'b0;
  bit [2:0]  vlan_rdctblnum1 = 3'b000;
  bit        vlan_vpr1 = 1'b0;
  bit [2:0]  vlan_rdctblnum2 = 3'b000;
  bit        vlan_vpr2 = 1'b0;
  bit [2:0]  vlan_rdctblnum3 = 3'b000;
  bit        vlan_vpr3 = 1'b0;
  bit [39:0] addr;
  bit [63:0] rd_data;
  bit [17:0] ip_db_vt_vlan;
//bit [1:0] vlan_parity_error = 2'b00;
  bit [47:0]  pkt_ipdst_addr;

 iport = packet_info.mac_prt;
 pkt_ipdst_addr = packet_info.flow.dst_node.l2_addr;
 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
  "IP_UTIL INFO: IPORT = %d for PKT_NUM = %d.\n",iport,pkt_num);
 case(iport)
  {
   0:
     {
      if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[0].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[0].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[0].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
  "IP_UTIL INFO: IPORT = %d for PKT_NUM = %d, 0 MATCHED_MAC_RDCTBLNUM = %h.\n",iport,pkt_num,matched_mac_rdctblnum);
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[1].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[1].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[1].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
  "IP_UTIL INFO: IPORT = %d for PKT_NUM = %d, 1 MATCHED_MAC_RDCTBLNUM = %h.\n",iport,pkt_num,matched_mac_rdctblnum);
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[2].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[2].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[2].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[3].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[3].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[3].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[4].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[4].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[4].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[5].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[5].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[5].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[6].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[6].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[6].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[7].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[7].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[7].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[8].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[8].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[8].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[9].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[9].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[9].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[10].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[10].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[10].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[11].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[11].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[11].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[12].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[12].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[12].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[13].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[13].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[13].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[14].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[14].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[14].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[15].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[15].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[15].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else
        {
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
          "IP_UTIL INFO: Port0 for DA = %h no Match is expected for PKT_NUM = %d\n",pkt_ipdst_addr,pkt_num);
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
          "IP_UTIL INFO: Port0 for DA = %h Packet expected to be dropped for PKT_NUM = %d\n",pkt_ipdst_addr,pkt_num);
        }
     }
   1:
     {
      if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[16].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[16].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[16].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[17].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[17].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[17].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[18].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[18].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[18].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[19].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[19].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[19].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[20].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[20].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[20].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[21].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[21].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[21].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[22].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[22].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[22].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[23].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[23].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[23].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[24].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[24].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[24].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[25].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[25].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[25].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[26].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[26].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[26].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[27].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[27].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[27].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[28].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[28].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[28].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[29].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[29].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[29].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[30].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[30].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[30].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[31].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[31].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[31].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else
        {
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
          "IP_UTIL INFO: Port1 for DA = %h no Match is expected for PKT_NUM = %d\n",pkt_ipdst_addr,pkt_num);
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
          "IP_UTIL INFO: Port1 for DA = %h Packet expected to be dropped for PKT_NUM = %d\n",pkt_ipdst_addr,pkt_num);
        }
     }
   2:
     {
      if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[32].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[32].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[32].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[33].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[33].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[33].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[34].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[34].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[34].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[35].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[35].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[35].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[36].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[36].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[36].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[37].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[37].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[37].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[38].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[38].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[38].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[39].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[39].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[39].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else
        {
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
          "IP_UTIL INFO: Port2 for DA = %h no Match is expected for PKT_NUM = %d\n",pkt_ipdst_addr,pkt_num);
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
          "IP_UTIL INFO: Port2 for DA = %h Packet expected to be dropped for PKT_NUM = %d\n",pkt_ipdst_addr,pkt_num);
        }
     }
   3:
     {
      if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[40].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[40].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[40].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[41].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[41].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[41].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[42].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[42].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[42].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[43].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[43].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[43].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[44].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[44].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[44].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[45].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[45].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[45].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[46].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[46].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[46].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else if (pkt_ipdst_addr === setup_ip_db_cl.ip_db[47].ip_mac.mac_da)
        {
         matched_mac_rdctblnum = setup_ip_db_cl.ip_db[47].ip_mac.mac_rdctblnum;
         matched_mac_mpr = setup_ip_db_cl.ip_db[47].ip_mac.mac_mpr;
         mac_da_matched = 1'b1;
        }
      else
        {
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
          "IP_UTIL INFO: Port3 for DA = %h no Match is expected for PKT_NUM = %d\n",pkt_ipdst_addr,pkt_num);
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
          "IP_UTIL INFO: Port3 for DA = %h Packet expected to be dropped for PKT_NUM = %d\n",pkt_ipdst_addr,pkt_num);
         mac_da_matched = 1'b0;
        }
     }
  } // case(iport)

packet_info.maccheck = mac_da_matched;

be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
  "IP_UTIL INFO: FOR PKT_NUM = %d MATCHED_MAC_RDCTBLNUM = %h.\n",pkt_num,matched_mac_rdctblnum);
 //@@@@ Find out the rdc_tbl_num based on VLAN if the packet is tagged @@@@
 packet_frame_type = packet_info.flow.frame.frame_type;

     //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     //@@@@@@ Predict the vlan rdc_tbl_num & mpr @@@@@@@
     //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  if (mac_da_matched && packet_frame_type[2])
    {
     packet_tci = packet_info.flow.src_node.tci;

     //@@@@@@ Get the vlan tables value from ip_db Vlan Table @@@@@@
     vlan_parity0    = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.parity0;
     vlan_parity1    = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.parity1;
     vlan_rdctblnum0 = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.rdctblnum0;
     vlan_vpr0       = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.vpr0;
     vlan_rdctblnum1 = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.rdctblnum1;
     vlan_vpr1       = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.vpr1;
     vlan_rdctblnum2 = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.rdctblnum2;
     vlan_vpr2       = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.vpr2;
     vlan_rdctblnum3 = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.rdctblnum3;
     vlan_vpr3       = setup_ip_db_cl.ip_db[packet_tci[11:0]].ip_vlan.vpr3;

     ip_db_vt_vlan   = {vlan_parity1,vlan_parity0,
                        vlan_vpr3,vlan_rdctblnum3,vlan_vpr2,vlan_rdctblnum2,
                        vlan_vpr1,vlan_rdctblnum1,vlan_vpr0,vlan_rdctblnum0};

     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
     "FOR IP_DB[%d], vlan_rdctblnum0 = %h, vlan_vpr0 = %h.\n",packet_tci[11:0],vlan_rdctblnum0,vlan_vpr0);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
     "FOR IP_DB[%d], vlan_rdctblnum1 = %h, vlan_vpr1 = %h.\n",packet_tci[11:0],vlan_rdctblnum1,vlan_vpr1);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
     "FOR IP_DB[%d], KH VLAN_PARITY  = %h.\n",packet_tci[11:0],{vlan_parity1,vlan_parity0});

     //@@@@@@ Get the vlan tables value from RTL Vlan Table @@@@@@
     addr = {FFLP_VLAN_TBL_ADDRESS_RANGE + 8*packet_tci[11:0]};
//   gen_pio_drv.pio_rd(addr, rd_data);
     rd_data   = {46'h0,ip_db_vt_vlan};  // read from ip_db instead of pio_rd

     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
     "FOR IP_DB[%d], SHADOW VLAN_ENTRY READ = %h VLAN_ADDR = %h.\n",packet_tci[11:0],rd_data,addr);

     vlan_parity_error = verify_vlan_tbl_parity (packet_tci[11:0], ip_db_vt_vlan, rd_data[17:0]);

     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
     "FOR VLAN ID %h AND VLAN_REG_ADDR = %h, RTL_VLAN_ENTRY = %h.\n",
       packet_tci[11:0],{FFLP_VLAN_TBL_ADDRESS_RANGE + 8*packet_tci[11:0]},rd_data[17:0]);

     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
     "FOR IP_DB[%d], PACKET_FRAME_TYPE = %h, PACKET_MAC_PORT = %d.\n",packet_tci[11:0],packet_frame_type,iport);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
     "FOR VLAN ID %h, vlan_parity_error = %h.\n",packet_tci[11:0],vlan_parity_error);

   case (vlan_parity_error)
    {
     2'b00:
      {
       case (iport)
           {
            0: {
                  matched_vlan_rdctblnum = vlan_rdctblnum0;
                  matched_vlan_vpr       = vlan_vpr0;
                  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
                  "FOR IP_DB[%d], iport = %h, matched_vlan_rdctblnum = %h, matched_vlan_vpr = %h.\n",
                   packet_tci[11:0],iport,matched_vlan_rdctblnum,matched_vlan_vpr);
                 }
            1: {
                  matched_vlan_rdctblnum = vlan_rdctblnum1;
                  matched_vlan_vpr       = vlan_vpr1;
                  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
                  "FOR IP_DB[%d], iport = %h, matched_vlan_rdctblnum = %h, matched_vlan_vpr = %h.\n",
                   packet_tci[11:0],iport,matched_vlan_rdctblnum,matched_vlan_vpr);
                 }
            2: {
                  matched_vlan_rdctblnum = vlan_rdctblnum2;
                  matched_vlan_vpr       = vlan_vpr2;
                  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
                  "FOR IP_DB[%d], iport = %h, matched_vlan_rdctblnum = %h, matched_vlan_vpr = %h.\n",
                   packet_tci[11:0],iport,matched_vlan_rdctblnum,matched_vlan_vpr);
                 }
            3: {
                  matched_vlan_rdctblnum = vlan_rdctblnum3;
                  matched_vlan_vpr       = vlan_vpr3;
                  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
                  "FOR IP_DB[%d], iport = %h, matched_vlan_rdctblnum = %h, matched_vlan_vpr = %h.\n",
                   packet_tci[11:0],iport,matched_vlan_rdctblnum,matched_vlan_vpr);
                 }
            default: {
  
                 }
           }
  
       be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
          "FOR IP_DB[%d], MATCHED_MAC_MPR = %h, MATCHED_VLAN_MPR = %h.\n",packet_tci[11:0],matched_mac_mpr,matched_vlan_vpr);
  
       case ({matched_mac_mpr,matched_vlan_vpr})
           {
            {1'b0,1'b0}: {predict_l2_rdc_tbl_num = matched_mac_rdctblnum;
                 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
                  "MAC RDCTBLNUM %h was predicted as L2RDCTBLNUM for packet %d.\n",predict_l2_rdc_tbl_num,pkt_num);
                }
            {1'b0,1'b1}: {predict_l2_rdc_tbl_num = matched_vlan_rdctblnum;
                 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
                  "VLAN RDCTBLNUM %h was predicted as L2RDCTBLNUM for packet %d.\n",predict_l2_rdc_tbl_num,pkt_num);
                }
            {1'b1,1'b0}: {predict_l2_rdc_tbl_num = matched_mac_rdctblnum;
                 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
                  "MAC RDCTBLNUM %h was predicted as L2RDCTBLNUM for packet %d.\n",predict_l2_rdc_tbl_num,pkt_num);
                }
            {1'b1,1'b1}: {predict_l2_rdc_tbl_num = matched_vlan_rdctblnum;
                 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
                  "VLAN RDCTBLNUM %h was predicted as L2RDCTBLNUM for packet %d.\n",predict_l2_rdc_tbl_num,pkt_num);
                }
           }
       }
      2'b01:
       {
        be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
          "IP_UTIL[%d]: FOR VLAN ID %h, VLAN PARITY mis-compare reported for LSB.\n",packet_tci[11:0],packet_tci[11:0]);
        be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
         "IP_UTIL[%d]: FOR VLAN ID %h, because of VLAN PARITY using MAC_RDC_NUM = %h.\n",
           packet_tci[11:0],packet_tci[11:0],matched_mac_rdctblnum);
        predict_l2_rdc_tbl_num = matched_mac_rdctblnum;
        packet_info.fflp_hw_err = 1'b1;
       }
      2'b10:
       {
        be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
          "IP_UTIL[%d]: FOR VLAN ID %h, VLAN PARITY mis-compare reported for MSB.\n",packet_tci[11:0],packet_tci[11:0]);
        be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
         "IP_UTIL[%d]: FOR VLAN ID %h, because of VLAN PARITY using MAC_RDC_NUM = %h.\n",
           packet_tci[11:0],packet_tci[11:0],matched_mac_rdctblnum);
        predict_l2_rdc_tbl_num = matched_mac_rdctblnum;
        packet_info.fflp_hw_err = 1'b1;
       }
      2'b11:
       {
        be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
          "IP_UTIL[%d]: FOR VLAN ID %h, VLAN PARITY mis-compare reported for LSB & MSB.\n",packet_tci[11:0],packet_tci[11:0]);
        be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
         "IP_UTIL[%d]: FOR VLAN ID %h, because of VLAN PARITY using MAC_RDC_NUM = %h.\n",
           packet_tci[11:0],packet_tci[11:0],matched_mac_rdctblnum);
        predict_l2_rdc_tbl_num = matched_mac_rdctblnum;
        packet_info.fflp_hw_err = 1'b1;
       }
    }
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
      "IP_UTIL INFO: FOR PKT_NUM = %d TAG PKT PREDICT_L2_RDC_TBL_NUM = %h.\n",pkt_num,predict_l2_rdc_tbl_num);
   } // if (packet_frame_type[2])
  else // Not a VLAN packet
    {
     predict_l2_rdc_tbl_num = matched_mac_rdctblnum;
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::predict_l2_rdc_tbl_num()",
      "IP_UTIL INFO: FOR PKT_NUM = %d NO TAG PKT PREDICT_L2_RDC_TBL_NUM = %h.\n",pkt_num,predict_l2_rdc_tbl_num);
    }

}

function bit [199:0] setup_cam_ram_fcram_class:: generate_pkt_cam_key(bit [2:0] predicted_l2_rdc_tbl_num, 
                                                              Cpkt_info packet_info)
{
 bit tuple_type;
 bit nop;
 bit [199:0] cam_key;

 bit [63:0]  shadow_fflp_how_tcam_key_cls_C;
 bit [63:0]  shadow_fflp_how_tcam_key_cls_D;
 bit [63:0]  shadow_fflp_how_tcam_key_cls_E;
 bit [63:0]  shadow_fflp_how_tcam_key_cls_F;


 bit [2:0]   mac_port         = 3'h0;
 bit [31:0]  ip_dst_addr      = 32'h0;
 bit [31:0]  ip_src_addr      = 32'h0;
 bit [127:0] ipv6_addr        = 128'h0;
 bit [127:0] ipv6_dst_addr    = 128'h0;
 bit [127:0] ipv6_src_addr    = 128'h0;
 bit [15:0]  src_tcp_udp_port = 16'h0;
 bit [15:0]  dst_tcp_udp_port = 16'h0;
 bit [7:0]   tos              = 8'h0;
 bit [31:0]  spi              = 32'h0;

 bit [4:0]   pkt_class;
 bit [7:0]   pkt_protocol;
 bit [7:0]   pkt_next_hdr;

//   nop      = setup_ip_db_cl.ip_db[i].ip_cam.nop;     
     if (packet_info.flow.frame.frame_class === CL_TCP_FRAG       ||
         packet_info.flow.frame.frame_class === CL_UDP_FRAG       ||
         packet_info.flow.frame.frame_class === CL_IP_FRAG)
       {
        nop      = 1'b1;
        src_tcp_udp_port = 16'h0;
        dst_tcp_udp_port = 16'h0;
       }
     else
       {
        nop      = 1'b0;
        src_tcp_udp_port = packet_info.flow.tup.src_tcp_udp_port;
        dst_tcp_udp_port = packet_info.flow.tup.dst_tcp_udp_port;
       }
     packet_info.noport = nop;

     if (packet_info.flow.frame.frame_class === CL_TCP        ||
         packet_info.flow.frame.frame_class === CL_UDP        ||
         packet_info.flow.frame.frame_class === CL_TCP_FRAG   ||
         packet_info.flow.frame.frame_class === CL_UDP_FRAG   ||
         packet_info.flow.frame.frame_class === CL_IP_SEC_AH  ||
         packet_info.flow.frame.frame_class === CL_IP_SEC_ESP ||
         packet_info.flow.frame.frame_class === CL_ARP        ||
         packet_info.flow.frame.frame_class === CL_RARP)
       {
        tuple_type = 0; // 5tuple
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
        "FOR PACKET_INFO, TUPLE_TYPE IS IPV4 5-TUPLE.\n");
       }
     else
       {
        tuple_type = 1; // 4tuple
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
        "FOR PACKET_INFO, TUPLE_TYPE IS IPV6 4-TUPLE.\n");
       }

     ip_dst_addr      = packet_info.flow.dst_node.ip_addr;
     ip_src_addr      = packet_info.flow.src_node.ip_addr;
     ipv6_dst_addr    = packet_info.flow.dst_node.ipv6_addr;
     ipv6_src_addr    = packet_info.flow.src_node.ipv6_addr;
//   src_tcp_udp_port = packet_info.flow.tup.src_tcp_udp_port;
//   dst_tcp_udp_port = packet_info.flow.tup.dst_tcp_udp_port;
     tos              = packet_info.flow.src_node.tos;
     spi              = packet_info.flow.src_node.spi;

     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
        "FOR PACKET_INFO, IP_DST_ADDR = %h.\n",ip_dst_addr);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
        "FOR PACKET_INFO, IP_SRC_ADDR = %h.\n",ip_src_addr);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
        "FOR PACKET_INFO, SRC_TCP_UDP_PORT = %h.\n",src_tcp_udp_port);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
        "FOR PACKET_INFO, DST_TCP_UDP_PORT = %h.\n",dst_tcp_udp_port);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
        "FOR PACKET_INFO, SPI = %h.\n",spi);
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
        "FOR PACKET_INFO, FRAME_CLASS = %d.\n",packet_info.flow.frame.frame_class);

     //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     //@@ Generate the CAM Keys for 256 CAM Entries @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     if ((packet_info.flow.frame.frame_type =?= 5'bx0x1x) &&
         (tuple_type === 1'b0))  // 5tuple type
       {
        case (packet_info.flow.frame.frame_class)
         {
          CL_TCP:{
                  if (packet_info.prog_class7_4_match)
                    {
                     pkt_class = packet_info.packet_class;
                    }
                  else
                    {
                     pkt_class = CLASS_8;
                     packet_info.packet_class = CLASS_8;
                    }
                  pkt_protocol = PROTOCOL_TCP;

                  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
                     "FOR PACKET_INFO, PKT_NUM = %d PKT_CLASS = %h.\n",packet_info.pkt_num,pkt_class);
                 }
          CL_TCP_FRAG:{
                  if (packet_info.prog_class7_4_match)
                    {
                     pkt_class = packet_info.packet_class;
                    }
                  else
                    {
//NEW                pkt_class = CLASS_0;
//NEW                packet_info.packet_class = CLASS_0;
                     pkt_class = CLASS_8;
                     packet_info.packet_class = CLASS_8;
                    }
                  pkt_protocol = PROTOCOL_TCP;

                  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
                     "FOR PACKET_INFO, PKT_NUM = %d PKT_CLASS = %h.\n",packet_info.pkt_num,pkt_class);
                 }
          CL_UDP:{
                  if (packet_info.prog_class7_4_match)
                    {
                     pkt_class = packet_info.packet_class;
                    }
                  else
                    {
                     pkt_class = CLASS_9;
                     packet_info.packet_class = CLASS_9;
                    }
                  pkt_protocol = PROTOCOL_UDP;

                  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
                     "FOR PACKET_INFO, PKT_NUM = %d PKT_CLASS = %h.\n",packet_info.pkt_num,pkt_class);
                 }
          CL_UDP_FRAG:{
                  if (packet_info.prog_class7_4_match)
                    {
                     pkt_class = packet_info.packet_class;
                    }
                  else
                    {
//NEW                pkt_class = CLASS_0;
//NEW                packet_info.packet_class = CLASS_0;
                     pkt_class = CLASS_9;
                     packet_info.packet_class = CLASS_9;
                    }
                  pkt_protocol = PROTOCOL_UDP;

                  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
                     "FOR PACKET_INFO, PKT_NUM = %d PKT_CLASS = %h.\n",packet_info.pkt_num,pkt_class);
                 }
          CL_IP_SEC_AH:
                 {
                  pkt_class = CLASS_10;
                  packet_info.packet_class = CLASS_10;
                  pkt_protocol = PROTOCOL_IPSEC_AH;
                  src_tcp_udp_port = spi[31:16];
                  dst_tcp_udp_port = spi[15:0];

                  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
                     "FOR PACKET_INFO, PKT_NUM = %d PKT_CLASS = %h.\n",packet_info.pkt_num,pkt_class);
                 }
          CL_IP_SEC_ESP:
                 {
                  pkt_class = CLASS_10;
                  packet_info.packet_class = CLASS_10;
                  pkt_protocol = PROTOCOL_IPSEC_ESP;
                  src_tcp_udp_port = spi[31:16];
                  dst_tcp_udp_port = spi[15:0];

                  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
                     "FOR PACKET_INFO, PKT_NUM = %d PKT_CLASS = %h.\n",packet_info.pkt_num,pkt_class);
                 }
/*
          CL_SCTP_IP_V4:
                 {
                  pkt_class    = CLASS_11;
                  packet_info.packet_class = CLASS_11;
                  pkt_protocol = PROTOCOL_SCTP;
                 }
*/
          CL_ARP:
                 {
                  if (packet_info.prog_class3_2_match)
                    {
                     pkt_class = packet_info.packet_class;
                    }
                  else
                    {
                     pkt_class = CLASS_16;
                     packet_info.packet_class = CLASS_16;
                    }
//                pkt_class    = CLASS_16;
                  pkt_protocol = 8'h0;
                  src_tcp_udp_port = 16'h0;
                  dst_tcp_udp_port = 16'h0;
                  ip_src_addr = 32'h0;
                  ip_dst_addr = 32'h0;
                 }  
          CL_RARP:
                 {
                  if (packet_info.prog_class3_2_match)
                    {
                     pkt_class = packet_info.packet_class;
                    }
                  else
                    {
                     pkt_class = CLASS_17;
                     packet_info.packet_class = CLASS_17;
                    }
//                pkt_class    = CLASS_17;
                  pkt_protocol = 8'h0;
                  src_tcp_udp_port = 16'h0;
                  dst_tcp_udp_port = 16'h0;
                  ip_src_addr = 32'h0;
                  ip_dst_addr = 32'h0;
                 }  
          default:
                 {
                  be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
                    "FOR PACKET_INFO, Unknown 5tuple frame_class %d detected.\n",packet_info.flow.frame.frame_class);
                 }
         }
        cam_key = {pkt_class,
                   3'b000,
                   {2'b00,predicted_l2_rdc_tbl_num},
                   nop,
                   74'h0,
                   tos,
                   pkt_protocol,
                   src_tcp_udp_port,
                   dst_tcp_udp_port,
                   ip_src_addr,
                   ip_dst_addr};

        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
          "FOR PACKET_INFO, Generated 5TUPLE CAM KEY pkt_class = %h.\n",pkt_class);
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
          "FOR PACKET_INFO, Generated 5TUPLE CAM KEY l2_rdc_tbl_num = %h.\n",predicted_l2_rdc_tbl_num);
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
          "FOR PACKET_INFO, Generated 5TUPLE CAM KEY nop = %h.\n",nop);
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
          "FOR PACKET_INFO, Generated 5TUPLE CAM KEY tos = %h.\n",tos);
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
          "FOR PACKET_INFO, Generated 5TUPLE CAM KEY pkt_protocol = %h.\n",pkt_protocol);
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
          "FOR PACKET_INFO, Generated 5TUPLE CAM KEY src_tcp_udp_port = %h.\n",src_tcp_udp_port);
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
          "FOR PACKET_INFO, Generated 5TUPLE CAM KEY dst_tcp_udp_port = %h.\n",dst_tcp_udp_port);
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
          "FOR PACKET_INFO, Generated 5TUPLE CAM KEY ip_src_addr = %h.\n",ip_src_addr);
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
          "FOR PACKET_INFO, Generated 5TUPLE CAM KEY ip_dst_addr = %h.\n",ip_dst_addr);

        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
          "FOR PACKET_INFO, FOR PKT_NUM = %d Generated 5TUPLE CAM KEY = %h.\n",packet_info.pkt_num,cam_key);
       }
     else if ((packet_info.flow.frame.frame_type =?= 5'bx1x1x) &&
         (tuple_type === 1'b1))  // 4tuple type
       {
        case (packet_info.flow.frame.frame_class)
         {
          CL_TCP_IP_V6:{
                  if (packet_info.prog_class7_4_match)
                    {
                     pkt_class = packet_info.packet_class;
                    }
                  else
                    {
                     pkt_class = CLASS_12;
                     packet_info.packet_class = CLASS_12;
                    }
                  pkt_next_hdr = PROTOCOL_TCP;
                  //@@@@ READ SHADOW OF addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_C;
                  shadow_fflp_how_tcam_key_cls_C = fflp_util.fflp_how_tcam_key_cls_C;
                  if (shadow_fflp_how_tcam_key_cls_C[0] === 1'b0)
                    {
                     ipv6_addr = ipv6_dst_addr;                      }
                  else
                    {
                     ipv6_addr = ipv6_src_addr;                      }

                  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
                     "FOR PACKET_INFO, PKT_NUM = %d PKT_CLASS = %h.\n",packet_info.pkt_num,pkt_class);
                 }
          CL_UDP_IP_V6:{
                  if (packet_info.prog_class7_4_match)
                    {
                     pkt_class = packet_info.packet_class;
                    }
                  else
                    {
                     pkt_class = CLASS_13;
                     packet_info.packet_class = CLASS_13;
                    }
                  pkt_next_hdr = PROTOCOL_UDP;
                  //@@@@ READ SHADOW OF addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_D;
                  shadow_fflp_how_tcam_key_cls_D = fflp_util.fflp_how_tcam_key_cls_D;
                  if (shadow_fflp_how_tcam_key_cls_D[0] === 1'b0)
                    {
                     ipv6_addr = ipv6_dst_addr;                      }
                  else
                    {
                     ipv6_addr = ipv6_src_addr;                      }

                  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
                     "FOR PACKET_INFO, PKT_NUM = %d PKT_CLASS = %h.\n",packet_info.pkt_num,pkt_class);
                 }
          CL_IP_V6_SEC_AH:
                 {
                  pkt_class = CLASS_14;
                  packet_info.packet_class = CLASS_14;
                  pkt_next_hdr = PROTOCOL_IPSEC_AH;
                  src_tcp_udp_port = spi[31:16];
                  dst_tcp_udp_port = spi[15:0];
                  //@@@@ READ SHADOW OF addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_E;
                  shadow_fflp_how_tcam_key_cls_E = fflp_util.fflp_how_tcam_key_cls_E;
                  if (shadow_fflp_how_tcam_key_cls_E[0] === 1'b0)
                    {
                     ipv6_addr = ipv6_dst_addr;                      }
                  else
                    {
                     ipv6_addr = ipv6_src_addr;                      }

                  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
                     "FOR PACKET_INFO, PKT_NUM = %d PKT_CLASS = %h.\n",packet_info.pkt_num,pkt_class);
                 }
          CL_IP_V6_SEC_ESP:
                 {
                  pkt_class = CLASS_14;
                  packet_info.packet_class = CLASS_14;
                  pkt_next_hdr = PROTOCOL_IPSEC_ESP;
                  src_tcp_udp_port = spi[31:16];
                  dst_tcp_udp_port = spi[15:0];
                  //@@@@ READ SHADOW OF addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_E;
                  shadow_fflp_how_tcam_key_cls_E = fflp_util.fflp_how_tcam_key_cls_E;
                  if (shadow_fflp_how_tcam_key_cls_E[0] === 1'b0)
                    {
                     ipv6_addr = ipv6_dst_addr;                      }
                  else
                    {
                     ipv6_addr = ipv6_src_addr;                      }

                  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
                     "FOR PACKET_INFO, PKT_NUM = %d PKT_CLASS = %h.\n",packet_info.pkt_num,pkt_class);
                 }
/*
          CL_SCTP_IP_V6:
                 {
                  pkt_class    = CLASS_15;
                  packet_info.packet_class = CLASS_15;
                  pkt_next_hdr = PROTOCOL_SCTP;
                  //@@@@ READ SHADOW OF addr = FFLP_ADDRESS_RANGE + FFLP_HOW_TCAM_KEY_CLS_F;
                  shadow_fflp_how_tcam_key_cls_F = fflp_util.fflp_how_tcam_key_cls_F;
                  if (shadow_fflp_how_tcam_key_cls_F[0] === 1'b0)
                    {
                     ipv6_addr = ipv6_dst_addr;                      }
                  else
                    {
                     ipv6_addr = ipv6_src_addr;                      }
                 }
*/
          default:
                 {
                  be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
                    "FOR PACKET_INFO, Unknown 4tuple frame_class %d detected.\n",packet_info.flow.frame.frame_class);
                 }
         }
        cam_key = {pkt_class,
                   3'b000,
                   {2'b00,predicted_l2_rdc_tbl_num},
                   nop,
                   10'h0,
                   tos,
                   pkt_next_hdr,
                   src_tcp_udp_port,
                   dst_tcp_udp_port,
                   ipv6_addr};

        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_pkt_cam_key()",
          "FOR PACKET_INFO, FOR PKT_NUM = %d Generated 4TUPLE CAM KEY = %h.\n",packet_info.pkt_num,cam_key);
  }
 generate_pkt_cam_key = cam_key;
}

function bit [4:0] setup_cam_ram_fcram_class:: program_zcp_rdc_tbl (bit user_program,
                                                                    integer rdc_tbl_index, 
                                                                    bit [2:0] prog_mode, 
                                                                    bit [4:0] dma_chnl)
// prog_mode = 3'b000 DO NOT PROGRAM and provide the dma_chnl at the given rdc_tbl_index.
// prog_mode = 3'b001 use dma_chnl and program only at the given rdc_tbl_index. provide the dma_chnl at the given rdc_tbl_index.
// prog_mode = 3'b010 Not used.
// prog_mode = 3'b011 program the whole rdc tbl using random dma_chnl values 0-15. 
// prog_mode = 3'b100 program the whole rdc tbl using pre-defined random dma_chnl values 0-15.
// prog_mode = 3'b101 program the whole rdc tbl using dma_chnl values 0-15 (sweep). 
// prog_mode = 3'b110 program the whole rdc tbl using dma_chnl values 15-0 (sweep. 
// prog_mode = 3'b111 program the whole rdc tbl using shifted RDC value per sub-block (per 16 entries).
{
 bit [39:0] address;
 bit [39:0] rd_address;
 bit [39:0] wr_address;
 bit [63:0] wr_data;
 bit [63:0] rd_data;
 bit [4:0]  dma_chnl_value;
 integer    start_dma_chnl_value = 0;
 bit [4:0]  dma_chnl_val[128];
 bit [4:0]  user_dma_chnl[256];
 bit [4:0]  port0_dmc_default_dma;
 bit [4:0]  port1_dmc_default_dma;
 bit [4:0]  port2_dmc_default_dma;
 bit [4:0]  port3_dmc_default_dma;

 integer i,j,n,k;
 integer fdi = 0;

for (i=0;i<256;i++)
   {
    user_dma_chnl[i] = 5'h0;
   }

if(user_program)
{
 fdi = fopen("/vobs/neptune/verif/env/niu/rxc_sat/vera/fflp/zcp_rdc_tbl.dat","r",VERBOSE);
 if (fdi === 0)
   {
    be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
      "IP_UTIL INFO: In user_program mode could not opem file zcp_rdc_tbl.dat for programing ZCP RDC Tbale.\n");
   }
 else
   {
    for (i=0;i<128;i++)
       {
        user_dma_chnl[i] = freadb(fdi);
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
         "IP_UTIL INFO: At index = %d USER_DMA_CHNL_VALUE[%d] = %h.\n", i,i,user_dma_chnl[i]);
       } 
    for (i=0;i<128;i++)
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
          "IP_UTIL INFO: PROGRAMMING ZCP RDC TABLE FOR i = %d.\n",i);
        wr_address = ZCP_RDC_TBL + (i*8);
        wr_data = {59'h0,user_dma_chnl[i]};
        gen_pio_drv.pio_wr(wr_address,wr_data);
        shadow_zcp_table [i] = dma_chnl[i];
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
         "IP_UTIL INFO:I = %d IN ZCP RDC_TBL IN USER_MODE, WRITING DMA_CHNL_VALUE[%d] = %h AT ADDRESS = %h.\n",
          i,i,user_dma_chnl[i],wr_address);
        if (i === rdc_tbl_index)
          {
           repeat(10) @(posedge CLOCK);
           rd_address = ZCP_RDC_TBL + (rdc_tbl_index*8);
           gen_pio_drv.pio_rd(rd_address,rd_data);
           program_zcp_rdc_tbl = rd_data[4:0];

           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
             "IP_UTIL INFO: PROG_MODE = %h at address = %h read dma_chnl value = %h.\n",prog_mode,rd_address,program_zcp_rdc_tbl);
          }
  
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
          "IP_UTIL INFO: PROG_MODE = %h at address = %h wrote dma_chnl value = %h.\n",prog_mode,wr_address,dma_chnl_value);
       }
   }
}
else
{
 if (prog_mode =?= 3'b000)
// prog_mode = 3'b0xx DO NOT PROGRAM and provide the dma_chnl at the given rdc_tbl_index.
   {
//  address = ZCP_RDC_TBL + (rdc_tbl_index*8);
//  gen_pio_drv.pio_rd(address,rd_data);
//  program_zcp_rdc_tbl = rd_data[4:0];
    program_zcp_rdc_tbl = shadow_zcp_table [rdc_tbl_index];

//  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
//    "IP_UTIL INFO: PROG_MODE = %h at address = %h read dma_chnl value = %h.\n",prog_mode,address,program_zcp_rdc_tbl);
    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
      "IP_UTIL INFO: PROG_MODE = %h at index = %h shadow read dma_chnl value = %h.\n",prog_mode,rdc_tbl_index,program_zcp_rdc_tbl);
   }
 else if (prog_mode === 3'b001)
// prog_mode = 3'b001 use dma_chnl and program only at the given rdc_tbl_index. provide the dma_chnl at the given rdc_tbl_index.
   {
    address = ZCP_RDC_TBL + (rdc_tbl_index*8);
    wr_data = {59'h0,dma_chnl};
    gen_pio_drv.pio_wr(address,wr_data);
    shadow_zcp_table [rdc_tbl_index] = dma_chnl;
    if (get_plus_arg (CHECK, "PIO_RD_ZCP_TABLE"))
      {
       repeat(10) @(posedge CLOCK);
       gen_pio_drv.pio_rd(address,rd_data);
       program_zcp_rdc_tbl = rd_data[4:0];
      }

    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
      "IP_UTIL INFO: PROG_MODE = %h at address = %h wrote dma_chnl value = %h.\n",prog_mode,address,dma_chnl);

    be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
      "IP_UTIL INFO: PROG_MODE = %h AT INDEX = %d, address = %h wrote to shadow_zcp_table [%d] = %h.\n",
       prog_mode,rdc_tbl_index,address,rdc_tbl_index,shadow_zcp_table [rdc_tbl_index]);
   }
 else if (prog_mode === 3'b011)
// prog_mode = 3'b011 program the whole rdc tbl using random dma_chnl values 0-15.
   {
    for (i=0;i<128;i++)
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
          "IP_UTIL INFO: PROGRAMMING ZCP RDC TABLE FOR i = %d.\n",i);
        random_value8 = random();
        dma_chnl_value = random_value8%5'b10000;
        wr_address = ZCP_RDC_TBL + (i*8);
        wr_data = {59'h0,dma_chnl_value};
        gen_pio_drv.pio_wr(wr_address,wr_data);
        shadow_zcp_table [i] = dma_chnl_value;
    if (get_plus_arg (CHECK, "PIO_RD_ZCP_TABLE"))
      {
       if (i === rdc_tbl_index)
         {
          repeat(10) @(posedge CLOCK);
          rd_address = ZCP_RDC_TBL + (rdc_tbl_index*8);
          gen_pio_drv.pio_rd(rd_address,rd_data);
          program_zcp_rdc_tbl = rd_data[4:0];
   
           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
             "IP_UTIL INFO: PROG_MODE = %h at address = %h read dma_chnl value = %h.\n",prog_mode,rd_address,program_zcp_rdc_tbl);
         }
      }
   
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
          "IP_UTIL INFO: PROG_MODE = %h at address = %h wrote dma_chnl value = %h.\n",prog_mode,wr_address,dma_chnl_value);
   
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
          "IP_UTIL INFO: PROG_MODE = %h AT INDEX = %d, address = %h wrote to shadow_zcp_table[%d] = %h.\n",
           prog_mode,i,wr_address,i,dma_chnl_value);

//      if (dma_chnl_value === 5'b00000)
//        {
//         dma_chnl_value = 5'b01111;
//        }
//      else
//        {
//         dma_chnl_value = dma_chnl_value - 1;
//        }
       }
   }
 else if (prog_mode === 3'b100)
// prog_mode = 3'b100 program the whole rdc tbl using pre-defined random dma_chnl values 0-15.
   {
    for (i=0;i<128;i++)
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
          "IP_UTIL INFO: PROGRAMMING ZCP RDC TABLE FOR i = %d.\n",i);
        dma_chnl_value = setup_ip_db_cl.pre_def_rand_rdc[i];
        wr_address = ZCP_RDC_TBL + (i*8);
        wr_data = {59'h0,dma_chnl_value};
        gen_pio_drv.pio_wr(wr_address,wr_data);
        shadow_zcp_table [i] = dma_chnl_value;
    if (get_plus_arg (CHECK, "PIO_RD_ZCP_TABLE"))
      {
       if (i === rdc_tbl_index)
         {
          repeat(10) @(posedge CLOCK);
          rd_address = ZCP_RDC_TBL + (rdc_tbl_index*8);
          gen_pio_drv.pio_rd(rd_address,rd_data);
          program_zcp_rdc_tbl = rd_data[4:0];
   
           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
             "IP_UTIL INFO: PROG_MODE = %h at address = %h read dma_chnl value = %h.\n",prog_mode,rd_address,program_zcp_rdc_tbl);
         }
      }
   
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
          "IP_UTIL INFO: PROG_MODE = %h at address = %h wrote dma_chnl value = %h.\n",prog_mode,wr_address,dma_chnl_value);
   
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
          "IP_UTIL INFO: PROG_MODE = %h AT INDEX = %d, address = %h wrote to shadow_zcp_table[%d] = %h.\n",
           prog_mode,i,wr_address,i,dma_chnl_value);

//      if (dma_chnl_value === 5'b00000)
//        {
//         dma_chnl_value = 5'b01111;
//        }
//      else
//        {
//         dma_chnl_value = dma_chnl_value - 1;
//        }
       }
   }
 else if (prog_mode === 3'b101)
// prog_mode = 3'b101 program the whole rdc tbl using dma_chnl values 0-15 (sweep).
   {
    dma_chnl_value = 5'b00000;
//  for (i=0;i<8;i++)
//     {
//      for (j=i;j<(16+i);j++)
//         {
//          dma_chnl_val[n] = j;
//          be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
//           "IP_UTIL INFO: FOR ZCP RDC TABLE WROTE J = %h TO DMA_CHNL_VAL[%d] = %h.\n",n,dma_chnl_val[n]);
//          n++;
//         }
//     }
    for (i=0;i<128;i++)
       {
 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
   "IP_UTIL INFO: PROGRAMMING ZCP RDC TABLE FOR i = %d.\n",i);
        wr_address = ZCP_RDC_TBL + (i*8);
        wr_data = {59'h0,dma_chnl_value};
        gen_pio_drv.pio_wr(wr_address,wr_data);
        shadow_zcp_table [i] = dma_chnl_value;
 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
  "IP_UTIL INFO:I = %d IN ZCP RDC_TBL FOR PROG_MODE = %h WRITING DMA_CHNL_VALUE = %h AT ADDRESS = %h.\n",
   i,prog_mode,dma_chnl_value,wr_address);
    if (get_plus_arg (CHECK, "PIO_RD_ZCP_TABLE"))
      {
       if (i === rdc_tbl_index)
         {
          repeat(10) @(posedge CLOCK);
          rd_address = ZCP_RDC_TBL + (rdc_tbl_index*8);
          gen_pio_drv.pio_rd(rd_address,rd_data);
          program_zcp_rdc_tbl = rd_data[4:0];
 
 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
   "IP_UTIL INFO: PROG_MODE = %h at address = %h read dma_chnl value = %h.\n",prog_mode,rd_address,program_zcp_rdc_tbl);
         }
      }
       
 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
   "IP_UTIL INFO: PROG_MODE = %h at address = %h wrote dma_chnl value = %h.\n",prog_mode,wr_address,dma_chnl_value);
 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
   "IP_UTIL INFO: PROG_MODE = %h AT INDEX = %d, address = %h wrote to shadow_zcp_table[%d] = %h.\n",
    prog_mode,i,wr_address,i,dma_chnl_value);
  
        if (dma_chnl_value === 5'b01111)
          {
           dma_chnl_value = 5'b00000;
          }
        else
          {
           dma_chnl_value = dma_chnl_value + 1;
          }
       }
   }
 else if (prog_mode === 3'b110)
// prog_mode = 3'b110 program the whole rdc tbl using dma_chnl values 15-0 (sweep).
   {
    dma_chnl_value = 5'b01111;
    for (i=0;i<128;i++)
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
          "IP_UTIL INFO: PROGRAMMING ZCP RDC TABLE FOR i = %d.\n",i);
        wr_address = ZCP_RDC_TBL + (i*8);
        wr_data = {59'h0,dma_chnl_value};
        gen_pio_drv.pio_wr(wr_address,wr_data);
        shadow_zcp_table [i] = dma_chnl_value;
    if (get_plus_arg (CHECK, "PIO_RD_ZCP_TABLE"))
      {
       if (i === rdc_tbl_index)
         {
          repeat(10) @(posedge CLOCK);
          rd_address = ZCP_RDC_TBL + (rdc_tbl_index*8);
          gen_pio_drv.pio_rd(rd_address,rd_data);
          program_zcp_rdc_tbl = rd_data[4:0];
   
           be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
             "IP_UTIL INFO: PROG_MODE = %h at address = %h read dma_chnl value = %h.\n",prog_mode,rd_address,program_zcp_rdc_tbl);
         }
      }
  
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
          "IP_UTIL INFO: PROG_MODE = %h at address = %h wrote dma_chnl value = %h.\n",prog_mode,wr_address,dma_chnl_value);
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
          "IP_UTIL INFO: PROG_MODE = %h AT INDEX = %d, address = %h wrote to shadow_zcp_table[%d] = %h.\n",
           prog_mode,i,wr_address,i,dma_chnl_value);
   
        if (dma_chnl_value === 5'b00000)
          {
           dma_chnl_value = 5'b01111;
          }
        else
          {
           dma_chnl_value = dma_chnl_value - 1;
          }
      }
   }
 else if (prog_mode === 3'b111)
// prog_mode = 3'b111 program the whole rdc tbl using shifted value in each sub-table0-15.
   {
    for (i=0;i<8;i++)
       {
        start_dma_chnl_value = i;
        for (j=0;j<16;j++)
           {
//          dma_chnl_value = dma_chnl_value + j;
            dma_chnl_value = start_dma_chnl_value + j;
            wr_address = ZCP_RDC_TBL + (((i*16)+j)*8);
            dma_chnl_value = {1'b0,dma_chnl_value[3:0]};
            wr_data = {59'h0,dma_chnl_value};
            gen_pio_drv.pio_wr(wr_address,wr_data);
            shadow_zcp_table [((i*16)+j)] = dma_chnl_value;

            be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
              "IP_UTIL INFO: PROGRAMMING ZCP RDC TABLE FOR i = %d, J = %d, ((i*16)+j) = %d.\n",i,j,((i*16)+j));
            be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
              "IP_UTIL INFO: FOR ((i*16)+j) = %d, DMA_CHNL_VALUE = %h, WR_ADDRESS = %h.\n",
                 ((i*16)+j),dma_chnl_value,wr_address);
           }
       }
   }
 else
   {
    be_msg_fflp.print(e_mesg_error, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
      "IP_UTIL INFO: PROG_MODE = %h is ilegal value.\n",prog_mode);
   }
} // else of "user_program"

 if (get_plus_arg (CHECK, "DUMP_ZCP_TBL_SHADOW"))
   {
    for (k=0;k<128;k++)
       {
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::program_zcp_rdc_tbl()",
          "IP_UTIL INFO: ZCP TBL SHADOW READ AT INDEX %d = %h.\n",k,shadow_zcp_table[k]);
       }
   }
}

function bit [383:0] setup_cam_ram_fcram_class:: generate_flow_key (integer pkt_num,
                                                                    //bit [2:0] predicted_l2_rdc_tbl_num, 
                                                                    // bit [63:0] matched_as_data, 
                                                                    Cpkt_info packet_info)
 {
  bit [39:0] rd_addr;
  bit [63:0] rd_data;
  bit [63:0] how_to_flow_key;

  bit [3:0]   flow_key_vlan_valid = 4'h0;
  bit [47:0]  flow_key_da_addr = 48'h0;
  bit [11:0]  flow_key_tci = 12'h0;
  bit [127:0] flow_key_ipsrc_addr = 128'h0;
  bit [127:0] flow_key_ipdst_addr = 128'h0;
  bit [15:0]  flow_key_L4_0 = 16'h0;
  bit [15:0]  flow_key_L4_1 = 16'h0;
  bit [7:0]   flow_key_protocol = 8'h0;
  bit [1:0]   flow_key_port = 2'h0;
  bit [63:0]  shadow_fflp_how_flow_key = 0;

  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
   "IP_UTIL INFO: PACKET_CLASS = %d.\n",packet_info.packet_class);

  //@@ Get instruction from HOW_TO_FLOW_KEY register for @@
  //@@ how to build flow key                             @@
  case (packet_info.packet_class)
    {
     4:{
        rd_addr = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_4;
        shadow_fflp_how_flow_key = fflp_util.fflp_how_flow_key_cls_4;
       }
     5:{
        rd_addr = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_5;
        shadow_fflp_how_flow_key = fflp_util.fflp_how_flow_key_cls_5;
       }
     6:{
        rd_addr = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_6;
        shadow_fflp_how_flow_key = fflp_util.fflp_how_flow_key_cls_6;
       }
     7:{
        rd_addr = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_7;
        shadow_fflp_how_flow_key = fflp_util.fflp_how_flow_key_cls_7;
       }
     8:{
        rd_addr = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_8;
        shadow_fflp_how_flow_key = fflp_util.fflp_how_flow_key_cls_8;
       }
     9:{
        rd_addr = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_9;
        shadow_fflp_how_flow_key = fflp_util.fflp_how_flow_key_cls_9;
       }
     10:{
         rd_addr = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_A;
         shadow_fflp_how_flow_key = fflp_util.fflp_how_flow_key_cls_A;
        }
     11:{
         rd_addr = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_B;
         shadow_fflp_how_flow_key = fflp_util.fflp_how_flow_key_cls_B;
        }
     12:{
         rd_addr = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_C;
         shadow_fflp_how_flow_key = fflp_util.fflp_how_flow_key_cls_C;
        }
     13:{
         rd_addr = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_D;
         shadow_fflp_how_flow_key = fflp_util.fflp_how_flow_key_cls_D;
        }
     14:{
         rd_addr = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_E;
         shadow_fflp_how_flow_key = fflp_util.fflp_how_flow_key_cls_E;
        }
     15:{
         rd_addr = FFLP_FLOW_ADDRESS_RANGE + FFLP_HOW_FLOW_KEY_CLS_F;
         shadow_fflp_how_flow_key = fflp_util.fflp_how_flow_key_cls_F;
        }
     default:{
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
          "IP_UTIL INFO: FOR L2 PACKET_CLASS = %d USE L2 RDC TBL RESULT.\n",packet_info.packet_class);
        }
    }
//gen_pio_drv.pio_rd(rd_addr, how_to_flow_key);
  how_to_flow_key = shadow_fflp_how_flow_key;
  if (packet_info.flow.frame.frame_type[2] === 1'b0)
    {
     flow_key_vlan_valid = 4'h0;
    }
  else
    {
     flow_key_vlan_valid = 4'hf;
    }

  if (how_to_flow_key[9] === 1'b1)  // MAC PORT  
    {
     flow_key_port = packet_info.mac_prt;
    }
   else
    {
     flow_key_port = 2'b00;
    }

  if (how_to_flow_key[8] === 1'b1)  // DA ADDRESS
    {
     flow_key_da_addr  = packet_info.flow.dst_node.l2_addr;
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
       "IP_UTIL INFO: FOR PKT_NUM %d PACKET_INFO DA MAC_ADDR   = %h..\n",pkt_num,packet_info.flow.dst_node.l2_addr);
    }
   else
    {
     flow_key_da_addr  = 48'h0;
    }

  if (how_to_flow_key[7] === 1'b1)  // VLAN TAG
    {
     flow_key_tci  = packet_info.flow.src_node.tci[11:0];
    }
   else
    {
     flow_key_tci  = 12'h0;
    }

  if (how_to_flow_key[6] === 1'b1)  // IP_SRC ADDR
    {
     if (packet_info.flow.frame.frame_type[3] === 1'b0)
       {
        flow_key_ipsrc_addr = {96'h0,packet_info.flow.src_node.ip_addr};
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
          "IP_UTIL INFO: FOR PKT_NUM %d PACKET_INFO V4 IPSRC_ADDR = %h..\n",pkt_num,packet_info.flow.src_node.ip_addr);
       }
     else
       {
        flow_key_ipsrc_addr = {packet_info.flow.src_node.ipv6_addr};
       }
    }
   else
    {
     flow_key_ipsrc_addr  = 128'h0;
    }

  if (how_to_flow_key[5] === 1'b1)  // IP_DST ADDR
    {
     if (packet_info.flow.frame.frame_type[3] === 1'b0)
       {
        flow_key_ipdst_addr = {96'h0,packet_info.flow.dst_node.ip_addr};
        be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
          "IP_UTIL INFO: FOR PKT_NUM %d PACKET_INFO V4 IPDST_ADDR = %h..\n",pkt_num,packet_info.flow.dst_node.ip_addr);
       }
     else
       {
        flow_key_ipdst_addr = {packet_info.flow.dst_node.ipv6_addr};
       }
    }
   else
    {
     flow_key_ipdst_addr  = 128'h0;
    }

  if (how_to_flow_key[4] === 1'b1)  // PROTOCOL/NEXT HEADER
    {
     flow_key_protocol  = packet_info.protocol;
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
       "IP_UTIL INFO:0 FOR PKT_NUM %d FLOW_KEY_PROTOCOL = %h..\n",pkt_num,flow_key_protocol);
    }
   else
    {
     flow_key_protocol  = 8'h0;
     be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
       "IP_UTIL INFO:1 FOR PKT_NUM %d FLOW_KEY_PROTOCOL = %h..\n",pkt_num,flow_key_protocol);
    }

  case (how_to_flow_key[3:2])
    {
     2'b00:  // not selected
        {
         flow_key_L4_0 = 16'h0;
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
           "IP_UTIL INFO:00 FOR PKT_NUM %d FLOW_KEY_L4_0 = %h..\n",pkt_num,flow_key_L4_0);
        }
     2'b01:  // reserved 
        {
         flow_key_L4_0 = 16'h0;
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
           "IP_UTIL INFO:01 FOR PKT_NUM %d FLOW_KEY_L4_0 = %h..\n",pkt_num,flow_key_L4_0);
        }
     2'b10:  // SRC_PORT (for tcp)
        {
         if (packet_info.protocol === PROTOCOL_TCP)
           {
            flow_key_L4_0 = packet_info.flow.tup.src_tcp_udp_port;       // TCP
           }
         else if (packet_info.protocol === PROTOCOL_UDP)
           {
            flow_key_L4_0 = packet_info.flow.tup.src_tcp_udp_port;       // UDP
           }
         else if (packet_info.protocol === PROTOCOL_IPSEC_AH)
           {

           }
         else if (packet_info.protocol === PROTOCOL_IPSEC_ESP)
           {

           }
         else if (packet_info.protocol === PROTOCOL_SCTP)
           {
            flow_key_L4_0 = packet_info.flow.tup.src_tcp_udp_port;       // SCTP
           }
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
           "IP_UTIL INFO:10 FOR PKT_NUM %d FLOW_KEY_L4_0 = %h..\n",pkt_num,flow_key_L4_0);
        }
     2'b11:  // SEQ_NUM (for tcp)/UDP LENGTH
        {
         if (packet_info.protocol === PROTOCOL_TCP)
           {
            flow_key_L4_0 = packet_info.flow.tx_param.last_seqno[31:16]; // TCP
           }
         else if (packet_info.protocol === PROTOCOL_UDP)
           {
//KHKH      flow_key_L4_0 = packet_info.flow.tx_param.udp_len;           // UDP  
           }
         else if (packet_info.protocol === PROTOCOL_IPSEC_AH)
           {

           }
         else if (packet_info.protocol === PROTOCOL_IPSEC_ESP)
           {

           }
         else if (packet_info.protocol === PROTOCOL_SCTP)
           {
//KHKH      flow_key_L4_0 = packet_info.flow.tx_param.verif_tag[31:16];  // SCTP
           }
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
           "IP_UTIL INFO:11 FOR PKT_NUM %d FLOW_KEY_L4_0 = %h..\n",pkt_num,flow_key_L4_0);
        }
    }

  case (how_to_flow_key[1:0])
    {
     2'b00:  // not selected
        {
         flow_key_L4_1 = 16'h0;
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
           "IP_UTIL INFO:00 FOR PKT_NUM %d FLOW_KEY_L4_1 = %h..\n",pkt_num,flow_key_L4_1);
        }
     2'b01:  // reserved 
        {
         flow_key_L4_1 = 16'h0;
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
           "IP_UTIL INFO:01 FOR PKT_NUM %d FLOW_KEY_L4_1 = %h..\n",pkt_num,flow_key_L4_1);
        }
     2'b10:  // SRC_PORT (for tcp)
        {
         if (packet_info.protocol === PROTOCOL_TCP)
           {
            flow_key_L4_1 = packet_info.flow.tup.dst_tcp_udp_port;       // TCP
           }
         else if (packet_info.protocol === PROTOCOL_UDP)
           {
            flow_key_L4_1 = packet_info.flow.tup.dst_tcp_udp_port;       // UDP
           }
         else if (packet_info.protocol === PROTOCOL_IPSEC_AH)
           {

           }
         else if (packet_info.protocol === PROTOCOL_IPSEC_ESP)
           {

           }
         else if (packet_info.protocol === PROTOCOL_SCTP)
           {
            flow_key_L4_1 = packet_info.flow.tup.dst_tcp_udp_port;       // SCTP
           }
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
           "IP_UTIL INFO:10 FOR PKT_NUM %d FLOW_KEY_L4_1 = %h..\n",pkt_num,flow_key_L4_1);
        }
     2'b11:  // SEQ_NUM (for tcp)/UDP LENGTH
        {
         if (packet_info.protocol === PROTOCOL_TCP)
           {
            flow_key_L4_1 = packet_info.flow.tx_param.last_seqno[31:16]; // TCP
           }
         else if (packet_info.protocol === PROTOCOL_UDP)
           {
//KHKH      flow_key_L4_1 = packet_info.flow.tx_param.udp_chksum;        // UDP  
           }
         else if (packet_info.protocol === PROTOCOL_IPSEC_AH)
           {

           }
         else if (packet_info.protocol === PROTOCOL_IPSEC_ESP)
           {

           }
         else if (packet_info.protocol === PROTOCOL_SCTP)
           {
//KHKH      flow_key_L4_1 = packet_info.flow.tx_param.verif_tag[15:0];   // SCTP
           }
         be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
           "IP_UTIL INFO:11 FOR PKT_NUM %d FLOW_KEY_L4_1 = %h..\n",pkt_num,flow_key_L4_1);
        }
    }

  generate_flow_key = {flow_key_vlan_valid, 
                       flow_key_da_addr, 
                       flow_key_tci,
                       flow_key_ipsrc_addr,
                       flow_key_ipdst_addr,
                       flow_key_L4_0,
                       flow_key_L4_1,
                       flow_key_protocol,
                       flow_key_port,
                       22'h0};

   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
     "IP_UTIL INFO: FOR PKT_NUM = %d, FLOW_KEY_VLAN_VALID = %h.\n",pkt_num,flow_key_vlan_valid);
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
     "IP_UTIL INFO: FOR PKT_NUM = %d, FLOW_KEY_DA_ADDR    = %h.\n",pkt_num,flow_key_da_addr);
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
     "IP_UTIL INFO: FOR PKT_NUM = %d, FLOW_KEY_TCI        = %h.\n",pkt_num,flow_key_tci);
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
     "IP_UTIL INFO: FOR PKT_NUM = %d, FLOW_KEY_IPSRC_ADDR = %h.\n",pkt_num,flow_key_ipsrc_addr);
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
     "IP_UTIL INFO: FOR PKT_NUM = %d, FLOW_KEY_IPDST_ADDR = %h.\n",pkt_num,flow_key_ipdst_addr);
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
     "IP_UTIL INFO: FOR PKT_NUM = %d, FLOW_KEY_L4_0       = %h.\n",pkt_num,flow_key_L4_0);
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
     "IP_UTIL INFO: FOR PKT_NUM = %d, FLOW_KEY_L4_1       = %h.\n",pkt_num,flow_key_L4_1);
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
     "IP_UTIL INFO: FOR PKT_NUM = %d, FLOW_KEY_PROTOCOL   = %h.\n",pkt_num,flow_key_protocol);
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
     "IP_UTIL INFO: FOR PKT_NUM = %d, FLOW_KEY_PORT       = %h.\n",pkt_num,flow_key_port);
   be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::generate_flow_key()",
     "IP_UTIL INFO: FOR PKT_NUM = %d, GENERATED FLOW_KEY  = %h.\n",pkt_num,generate_flow_key);
 
 }

function bit [31:0] setup_cam_ram_fcram_class:: calculate_H1 (//integer index,
                                                              integer pkt_num,
                                                              bit [2:0] predicted_l2_rdc_tbl_num,
                                                             // bit [63:0] matched_as_data,
                                                              Cpkt_info packet_info)
 {
  bit [39:0]  rd_addr;
  bit [63:0]  rd_data;
  bit [63:0]  initial_h1_poly_tmp;
  bit [32:0]  initial_h1_poly;
  bit [383:0] flow_key = 384'h0;
  bit [32:0]  shtol_h1poly = 33'h0;
  bit [32:0]  hash_tmp = 33'h0;
  bit [63:0]  flow_keyb[6];
  bit [63:0]  flow_keyb_tmp;
  integer i, j;

  //@@ Get the Initial H1POLY from H1POLY(FZC_FFLP+0x40060 Regiater @@
//rd_addr = FFLP_FLOW_ADDRESS_RANGE + FFLP_FLOW_H1POLY;
//gen_pio_drv.pio_rd(rd_addr, initial_h1_poly_tmp);
  initial_h1_poly_tmp = fflp_util.fflp_flow_h1poly;

  initial_h1_poly = initial_h1_poly_tmp[32:0];
  shtol_h1poly    = initial_h1_poly_tmp[32:0];

  flow_key = packet_info.flow_key;
  flow_keyb[0] = flow_key[63:0];
  flow_keyb[1] = flow_key[127:64];
  flow_keyb[2] = flow_key[191:128];
  flow_keyb[3] = flow_key[255:192];
  flow_keyb[4] = flow_key[319:256];
  flow_keyb[5] = flow_key[383:320];

  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
    "IP_UTIL INFO: FOR PACKET_NUM = %d INITIAL_H1_POLY = %h.\n",pkt_num,initial_h1_poly);
  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
    "IP_UTIL INFO: FOR PACKET_NUM = %d SHTOL_H1_POLY = %h.\n",pkt_num,shtol_h1poly);
  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
    "IP_UTIL INFO: FOR PACKET_NUM = %d FLOW_KEY = %h.\n",pkt_num,flow_key);
  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
    "IP_UTIL INFO: FOR PACKET_NUM = %d FLOW_KEYB[0] = %h.\n",pkt_num,flow_keyb[0]);
  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
    "IP_UTIL INFO: FOR PACKET_NUM = %d FLOW_KEYB[1] = %h.\n",pkt_num,flow_keyb[1]);
  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
    "IP_UTIL INFO: FOR PACKET_NUM = %d FLOW_KEYB[2] = %h.\n",pkt_num,flow_keyb[2]);
  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
    "IP_UTIL INFO: FOR PACKET_NUM = %d FLOW_KEYB[3] = %h.\n",pkt_num,flow_keyb[3]);
  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
    "IP_UTIL INFO: FOR PACKET_NUM = %d FLOW_KEYB[4] = %h.\n",pkt_num,flow_keyb[4]);
  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
    "IP_UTIL INFO: FOR PACKET_NUM = %d FLOW_KEYB[5] = %h.\n",pkt_num,flow_keyb[5]);

  for (i=0;i<6;i++)
     {
      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
       "IP_UTIL INFO: FOR PKT_NUM = %d 0 VALUE OF I = %d.\n", pkt_num,i);
      for (j=63;j>=0;j--)
         {
          be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
           "IP_UTIL INFO: FOR PKT_NUM = %d 0 VALUE OF J = %d.\n", pkt_num,j);
          if (j === 63)
            {
             flow_keyb_tmp = flow_keyb[i];
            }
          else
            {
             flow_keyb_tmp = flow_keyb_tmp;
            }
//        shtol_h1poly = initial_h1_poly << 1;
          shtol_h1poly = shtol_h1poly << 1;
          if (shtol_h1poly[32] ^ flow_keyb_tmp[j])
            {
             be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
              "IP_UTIL INFO: FOR PKT_NUM = %d DOING XOR for I = %d AND J = %d.\n", pkt_num,i,j);
             shtol_h1poly = {1'b0,(shtol_h1poly[31:0] ^ H1_CRC_32C_POLY)};
            }
          else
            {
             shtol_h1poly = {1'b0, shtol_h1poly[31:0]};
            }
          be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
           "IP_UTIL INFO: FOR PKT_NUM = %d 1 VALUE OF J = %d.\n", pkt_num,j);
         }
      be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
       "IP_UTIL INFO: FOR PKT_NUM = %d 1 VALUE OF I = %d.\n", pkt_num,i);
     }

  calculate_H1 = shtol_h1poly[31:0];
  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_H1()",
    "IP_UTIL INFO: FOR PACKET_NUM = %d CALCULATED H1 HASH = %h.\n",pkt_num,calculate_H1);

 }

task setup_cam_ram_fcram_class:: program_fcram()
{
}

function bit  setup_cam_ram_fcram_class:: ecc_err (integer pkt_num,
                                                   bit [199:0] packet_cam_key, 
				                   bit [63:0] matched_as_data,
		                                   Cpkt_info packet_info) 
 {
  bit [129:0]  tcam_adata;
  bit [15:0]   syndrome;
  bit          ecc_err_l = 1'b0;
  bit          ecc_err_h = 1'b0;

  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::ecc_err()",
    "IP_UTIL INFO: FOR PACKET_NUM = %d TCAM_KEY = %h, MATCHED_AS_DATA = %h.\n",pkt_num,packet_cam_key,matched_as_data);

  tcam_adata = {matched_as_data[25:1],1'b0,packet_cam_key[103:0]};
  syndrome   = matched_as_data[41:26];

  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::ecc_err()",
    "IP_UTIL INFO: FOR PACKET_NUM = %d TCAM_ADATA = %h, SYNDROME = %h.\n",pkt_num,tcam_adata,syndrome);

  ecc_err_l  = check_ecc (tcam_adata[64:0],syndrome[7:0]);
  ecc_err_h  = check_ecc (tcam_adata[129:65],syndrome[15:8]);

  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::ecc_err()",
    "IP_UTIL INFO: FOR PACKET_NUM = %d ECC_ERR_L = %h, ECC_ERR_H = %h.\n",pkt_num,ecc_err_l,ecc_err_h);

  ecc_err = ecc_err_h | ecc_err_l; 

  be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::ecc_err()",
    "IP_UTIL INFO: FOR PACKET_NUM = %d ECC_ERR = %h.\n",pkt_num,ecc_err);

//THIS WILL BE A PLACE TO STORE THE ecc_err for the packet in packet_info
 
 }

function bit  setup_cam_ram_fcram_class:: check_ecc (bit [64:0] tcam_adata, 
				                     bit [7:0] syndrome)
{
 bit [72:0] din;
 bit [7:0] syn;
 
 din = {tcam_adata,syndrome};

 syn[7] = din[70] ^ din[67] ^ din[65] ^ din[62] ^ din[60] ^ din[57] ^ din[54] ^ din[51] ^ din[48] ^ din[46] ^ din[44] ^ din[40] ^ din[38] ^ din[36] ^ din[32] ^ din[31] ^ din[27] ^ din[24] ^ din[23] ^ din[19] ^ din[18] ^ din[15] ^ din[13] ^ din[12] ^ din[10] ^ din[9] ^ din[7];
 syn[6] = din[70] ^ din[68] ^ din[65] ^ din[62] ^ din[59] ^ din[57] ^ din[55] ^ din[52] ^ din[49] ^ din[47] ^ din[43] ^ din[41] ^ din[39] ^ din[35] ^ din[33] ^ din[30] ^ din[27] ^ din[26] ^ din[22] ^ din[19] ^ din[17] ^ din[15] ^ din[14] ^ din[12] ^ din[10] ^ din[9] ^ din[6];
 syn[5] = din[71] ^ din[68] ^ din[65] ^ din[63] ^ din[60] ^ din[58] ^ din[54] ^ din[52] ^ din[49] ^ din[46] ^ din[44] ^ din[42] ^ din[38] ^ din[37] ^ din[34] ^ din[30] ^ din[29] ^ din[25] ^ din[22] ^ din[21] ^ din[20] ^ din[15] ^ din[14] ^ din[12] ^ din[11] ^ din[9] ^ din[8] ^ din[5];
 syn[4] = din[71] ^ din[68] ^ din[66] ^ din[63] ^ din[60] ^ din[57] ^ din[56] ^ din[53] ^ din[50] ^ din[47] ^ din[45] ^ din[41] ^ din[39] ^ din[36] ^ din[33] ^ din[31] ^ din[28] ^ din[25] ^ din[24] ^ din[20] ^ din[18] ^ din[16] ^ din[14] ^ din[12] ^ din[11] ^ din[9] ^ din[4];
 syn[3] = din[71] ^ din[69] ^ din[66] ^ din[64] ^ din[61] ^ din[58] ^ din[55] ^ din[52] ^ din[50] ^ din[47] ^ din[44] ^ din[42] ^ din[40] ^ din[36] ^ din[35] ^ din[32] ^ din[28] ^ din[26] ^ din[23] ^ din[21] ^ din[19] ^ din[16] ^ din[14] ^ din[13] ^ din[11] ^ din[9] ^ din[8] ^ din[3];
 syn[2] = din[72] ^ din[69] ^ din[66] ^ din[63] ^ din[61] ^ din[58] ^ din[55] ^ din[53] ^ din[51] ^ din[48] ^ din[45] ^ din[43] ^ din[39] ^ din[38] ^ din[34] ^ din[31] ^ din[29] ^ din[27] ^ din[23] ^ din[22] ^ din[17] ^ din[16] ^ din[14] ^ din[13] ^ din[11] ^ din[10] ^ din[8] ^ din[2];
 syn[1] = din[72] ^ din[69] ^ din[67] ^ din[64] ^ din[62] ^ din[59] ^ din[56] ^ din[53] ^ din[50] ^ din[48] ^ din[46] ^ din[42] ^ din[40] ^ din[37] ^ din[34] ^ din[33] ^ din[30] ^ din[26] ^ din[24] ^ din[20] ^ din[17] ^ din[16] ^ din[15] ^ din[13] ^ din[11] ^ din[10] ^ din[8] ^ din[1];
 syn[0] = din[72] ^ din[70] ^ din[67] ^ din[64] ^ din[61] ^ din[59] ^ din[56] ^ din[54] ^ din[51] ^ din[49] ^ din[45] ^ din[43] ^ din[41] ^ din[37] ^ din[35] ^ din[32] ^ din[29] ^ din[28] ^ din[25] ^ din[21] ^ din[18] ^ din[16] ^ din[15] ^ din[13] ^ din[12] ^ din[10] ^ din[8] ^ din[0];

 if (syn == 8'b00000000)
   {
    check_ecc = 1'b0;
   }
 else
   {
    check_ecc = 1'b1;
   }

}

function bit [7:0] setup_cam_ram_fcram_class:: calculate_ecc_syndrome (bit [64:0] din)
{
 bit [7:0] syn;
 
 syn[7] = din[62] ^ din[59] ^ din[57] ^ din[54] ^ din[52] ^ din[49] ^ din[46] ^ din[43] ^ din[40] ^ din[38] ^ din[36] ^ din[32] ^ din[30] ^ din[28] ^ din[24] ^ din[23] ^ din[19] ^ din[16] ^ din[15] ^ din[11] ^ din[10] ^ din[7] ^ din[5] ^ din[4] ^ din[2] ^ din[1];
 syn[6] = din[62] ^ din[60] ^ din[57] ^ din[54] ^ din[51] ^ din[49] ^ din[47] ^ din[44] ^ din[41] ^ din[39] ^ din[35] ^ din[33] ^ din[31] ^ din[27] ^ din[25] ^ din[22] ^ din[19] ^ din[18] ^ din[14] ^ din[11] ^ din[9] ^ din[7] ^ din[6] ^ din[4] ^ din[2] ^ din[1];
 syn[5] = din[63] ^ din[60] ^ din[57] ^ din[55] ^ din[52] ^ din[50] ^ din[46] ^ din[44] ^ din[41] ^ din[38] ^ din[36] ^ din[34] ^ din[30] ^ din[29] ^ din[26] ^ din[22] ^ din[21] ^ din[17] ^ din[14] ^ din[13] ^ din[12] ^ din[7] ^ din[6] ^ din[4] ^ din[3] ^ din[1] ^ din[0];
 syn[4] = din[63] ^ din[60] ^ din[58] ^ din[55] ^ din[52] ^ din[49] ^ din[48] ^ din[45] ^ din[42] ^ din[39] ^ din[37] ^ din[33] ^ din[31] ^ din[28] ^ din[25] ^ din[23] ^ din[20] ^ din[17] ^ din[16] ^ din[12] ^ din[10] ^ din[8] ^ din[6] ^ din[4] ^ din[3] ^ din[1];
 syn[3] = din[63] ^ din[61] ^ din[58] ^ din[56] ^ din[53] ^ din[50] ^ din[47] ^ din[44] ^ din[42] ^ din[39] ^ din[36] ^ din[34] ^ din[32] ^ din[28] ^ din[27] ^ din[24] ^ din[20] ^ din[18] ^ din[15] ^ din[13] ^ din[11] ^ din[8] ^ din[6] ^ din[5] ^ din[3] ^ din[1] ^ din[0];
 syn[2] = din[64] ^ din[61] ^ din[58] ^ din[55] ^ din[53] ^ din[50] ^ din[47] ^ din[45] ^ din[43] ^ din[40] ^ din[37] ^ din[35] ^ din[31] ^ din[30] ^ din[26] ^ din[23] ^ din[21] ^ din[19] ^ din[15] ^ din[14] ^ din[9] ^ din[8] ^ din[6] ^ din[5] ^ din[3] ^ din[2] ^ din[0];
 syn[1] = din[64] ^ din[61] ^ din[59] ^ din[56] ^ din[54] ^ din[51] ^ din[48] ^ din[45] ^ din[42] ^ din[40] ^ din[38] ^ din[34] ^ din[32] ^ din[29] ^ din[26] ^ din[25] ^ din[22] ^ din[18] ^ din[16] ^ din[12] ^ din[9] ^ din[8] ^ din[7] ^ din[5] ^ din[3] ^ din[2] ^ din[0];
 syn[0] = din[64] ^ din[62] ^ din[59] ^ din[56] ^ din[53] ^ din[51] ^ din[48] ^ din[46] ^ din[43] ^ din[41] ^ din[37] ^ din[35] ^ din[33] ^ din[29] ^ din[27] ^ din[24] ^ din[21] ^ din[20] ^ din[17] ^ din[13] ^ din[10] ^ din[8] ^ din[7] ^ din[5] ^ din[4] ^ din[2] ^ din[0];

 calculate_ecc_syndrome = syn;

 be_msg_fflp.print(e_mesg_info, *, "setup_cam_ram_fcram_class::calculate_ecc_syndrome()",
   "CALCULATED_ECC_SYNDROME = %h.\n",syn);
}

